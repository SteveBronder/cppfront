
//  Copyright 2022-2026 Herb Sutter
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//  Part of the Cppfront Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://github.com/hsutter/cppfront/blob/main/LICENSE for license information.


//===========================================================================
//  Reverse-mode autodiff implementation
//  Extracted from reflect.h2
//===========================================================================

#include "reflect.h"

cpp2: namespace = {

meta: namespace = {

/**
 * @brief Empty base class to suppress assignment operator generation.
 *
 * When a Cpp2 type has a base class, cppfront generates only a constructor
 * (with member initializer list) rather than both constructor and assignment
 * operator. This is needed because function_declaration has deleted copy
 * assignment but move assignment is fine.
 */
reverse_autodiff_base: type = { }

/**
 * @brief Context for reverse-mode IR construction and naming.
 */
reverse_autodiff_context: type = {
    this: reverse_autodiff_base = ();

    /// Function being transformed.
    public mf  : meta::function_declaration;

    /// Suffix used for value temporaries.
    public value_suffix: std::string = "_val";
    /// Suffix used for adjoint temporaries.
    public adj_suffix  : std::string = "_adj";

    /**
     * @brief Initialize the reverse context.
     * @param mf_ Function being transformed.
     * @return No return value.
     */
    operator=:(out this, mf_: meta::function_declaration) = {
        mf  = mf_;
    }

    /**
     * @brief Create a value name with the configured suffix.
     * @param base Base identifier.
     * @return Value name with suffix.
     */
    make_value_name: (this, base: std::string) -> std::string = {
        if base == "_" {
            return base;
        }
        return base + value_suffix;
    }

    /**
     * @brief Create an adjoint name with the configured suffix.
     * @param base Base identifier.
     * @return Adjoint name with suffix.
     */
    make_adj_name: (this, base: std::string) -> std::string = {
        if base == "_" {
            return base;
        }
        return base + adj_suffix;
    }
}

//-----------------------------------------------------------------------
//
//  Dual-Type IR Infrastructure
//
//  Wraps meta reflection types with AD-specific metadata, enabling
//  transformation without rebuilding AST structure.
//
//-----------------------------------------------------------------------

/**
 * @brief Derive a value name from an original identifier.
 * @param original Base identifier name.
 * @return Value name with _val suffix.
 */
make_value_name: (original: std::string) -> std::string = {
    if original == "_" {
        return original;
    }
    return original + "_val";
}

/**
 * @brief Derive an adjoint name from an original identifier.
 * @param original Base identifier name.
 * @return Adjoint name with _adj suffix.
 */
make_adjoint_name: (original: std::string) -> std::string = {
    if original == "_" {
        return original;
    }
    return original + "_adj";
}

/**
 * @brief Generic dual-type wrapper pairing a meta type with user-provided metadata.
 *
 * The dual-type approach wraps meta reflection types (meta::expression, meta::statement)
 * with AD-specific metadata, avoiding the need to rebuild AST structure.
 *
 * @tparam MetaType The wrapped meta reflection type.
 * @tparam Metadata User-provided metadata type.
 */
ad_dual: <MetaType, Metadata> type = {
    public meta : MetaType;
    public data : Metadata;

    /// Constructor with explicit meta and data
    operator=: (out this, m: MetaType, d: Metadata) = {
        meta = m;
        data = d;
    }

    /**
     * @brief Wrap a meta type with default-constructed metadata.
     * @param m Meta type to wrap.
     * @return Dual-type wrapper.
     */
    wrap: (m: MetaType) -> ad_dual<MetaType, Metadata> = {
        return ad_dual<MetaType, Metadata>(m, Metadata());
    }

    /**
     * @brief Delegate to_string to the underlying meta type.
     * @return String representation from meta type.
     */
    to_string: (this) -> std::string = {
        return meta.to_string();
    }
}

/**
 * @brief Metadata for expressions during AD transformation.
 *
 * Tracks whether an expression affects gradients (is_active).
 */
ad_expr_metadata: type = {
    public is_active : bool = false;  // Does this expression affect gradients?

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}
}

/**
 * @brief Metadata for statements during AD transformation.
 *
 * Tracks whether a statement is an accumulation (+=) operation.
 */
ad_stmt_metadata: type = {
    public is_accumulation : bool = false;  // Is this a += statement?

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}
}

/**
 * @brief String-based substitution context for dual-type rule application.
 *
 * Maps parameter names to their string replacements. Used during
 * rule body substitution where we transform to_string() output.
 */
ad_string_substitution_context: type = {
    public substitutions : std::map<std::string, std::string> = ();

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    /**
     * @brief Add a substitution mapping.
     * @param name Parameter name to substitute.
     * @param replacement String to substitute in place of the parameter.
     */
    add: (inout this, name: std::string, replacement: std::string) = {
        substitutions[name] = replacement;
    }

    /**
     * @brief Apply all substitutions to a text string.
     *
     * Replaces all occurrences of parameter names with their replacements.
     * Uses word-boundary matching to avoid partial replacements.
     *
     * @param text Text to transform.
     * @return Text with all substitutions applied.
     */
    apply: (this, text: std::string) -> std::string = {
        result: std::string = text;
        for substitutions do (sub) {
            name := sub.first;
            replacement := sub.second;
            // Simple word-boundary replacement
            pos: size_t = 0;
            while true {
                pos = result.find(name, pos);
                if pos == std::string::npos {
                    break;
                }
                // Check word boundaries
                before_ok := pos == 0 || !std::isalnum(result[pos - 1]) && result[pos - 1] != '_';
                end_pos := pos + name.size();
                after_ok := end_pos >= result.size() || !std::isalnum(result[end_pos]) && result[end_pos] != '_';
                if before_ok && after_ok {
                    result = result.substr(0, pos) + replacement + result.substr(end_pos);
                    pos += replacement.size();
                } else {
                    pos++;
                }
            }
        }
        return result;
    }

    /**
     * @brief Check if a substitution exists for a name.
     * @param name Parameter name to check.
     * @return true if a substitution exists.
     */
    has: (this, name: std::string) -> bool = {
        return substitutions.find(name) != substitutions.end();
    }

    /**
     * @brief Get the replacement for a name.
     * @param name Parameter name to look up.
     * @return Replacement string, or empty string if not found.
     */
    get: (this, name: std::string) -> std::string = {
        it := substitutions.find(name);
        if it != substitutions.end() {
            return it*.second;
        }
        return "";
    }
}

//-----------------------------------------------------------------------
//
//  Built-in AD Rules Namespace
//
//  Standard ad_rule_* types for operators and common math functions.
//  These are automatically discovered by the autodiff metafunction.
//
//-----------------------------------------------------------------------

ad: namespace = {

// =============================================================================
// Basic Arithmetic Operators
// =============================================================================

// Rule for addition: d/dx (x + y) = 1, d/dy (x + y) = 1
ad_rule_add: type = {
    name: std::string = "+";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = x + y;

    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += res_adj;
        y_adj += res_adj;
    }
}

// Rule for subtraction: d/dx (x - y) = 1, d/dy (x - y) = -1
ad_rule_sub: type = {
    name: std::string = "-";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = x - y;

    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += res_adj;
        y_adj -= res_adj;
    }
}

// Rule for multiplication: d/dx (x * y) = y, d/dy (x * y) = x
ad_rule_mul: type = {
    name: std::string = "*";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = x * y;

    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += y_val * res_adj;
        y_adj += x_val * res_adj;
    }
}

// Rule for division: d/dx (x / y) = 1/y, d/dy (x / y) = -x/y^2
ad_rule_div: type = {
    name: std::string = "/";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = x / y;

    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += res_adj / y_val;
        y_adj -= x_val / (y_val * y_val) * res_adj;
    }
}

// Rule for unary negation: d/dx (-x) = -1
ad_rule_neg: type = {
    name: std::string = "unary-";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = -x;

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj -= res_adj;
    }
}

// =============================================================================
// Exponential and Logarithmic Functions
// =============================================================================

// Rule for exp(x): d/dx exp(x) = exp(x)
ad_rule_exp: type = {
    name: std::string = "exp";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::exp(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += res_val * res_adj;
    }
}

// Rule for log(x): d/dx log(x) = 1/x
ad_rule_log: type = {
    name: std::string = "log";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::log(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += res_adj / x_val;
    }
}

// =============================================================================
// Power Functions
// =============================================================================

// Rule for sqrt(x): d/dx sqrt(x) = 0.5/sqrt(x)
ad_rule_sqrt: type = {
    name: std::string = "sqrt";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::sqrt(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += 0.5 * res_adj / res_val;
    }
}

// Rule for pow(x, y): d/dx = y*x^(y-1), d/dy = x^y * log(x)
ad_rule_pow: type = {
    name: std::string = "pow";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = std::pow(x, y);

    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += y_val * res_val / x_val * res_adj;
        y_adj += res_val * std::log(x_val) * res_adj;
    }
}

// =============================================================================
// Trigonometric Functions
// =============================================================================

// Rule for sin(x): d/dx sin(x) = cos(x)
ad_rule_sin: type = {
    name: std::string = "sin";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::sin(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += std::cos(x_val) * res_adj;
    }
}

// Rule for cos(x): d/dx cos(x) = -sin(x)
ad_rule_cos: type = {
    name: std::string = "cos";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::cos(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj -= std::sin(x_val) * res_adj;
    }
}

// Rule for tan(x): d/dx tan(x) = sec^2(x) = 1 + tan^2(x)
ad_rule_tan: type = {
    name: std::string = "tan";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::tan(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += (1.0 + res_val * res_val) * res_adj;
    }
}

// =============================================================================
// Hyperbolic Functions
// =============================================================================

// Rule for sinh(x): d/dx sinh(x) = cosh(x)
ad_rule_sinh: type = {
    name: std::string = "sinh";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::sinh(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += std::cosh(x_val) * res_adj;
    }
}

// Rule for cosh(x): d/dx cosh(x) = sinh(x)
ad_rule_cosh: type = {
    name: std::string = "cosh";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::cosh(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += std::sinh(x_val) * res_adj;
    }
}

// Rule for tanh(x): d/dx tanh(x) = 1 - tanh^2(x)
ad_rule_tanh: type = {
    name: std::string = "tanh";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::tanh(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += (1.0 - res_val * res_val) * res_adj;
    }
}

// =============================================================================
// Other Common Functions
// =============================================================================

// Rule for abs(x): d/dx |x| = sign(x)
ad_rule_abs: type = {
    name: std::string = "abs";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = std::abs(x);

    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        if x_val != 0.0 {
            x_adj += (x_val / res_val) * res_adj;
        }
    }
}

}  // namespace ad

//-----------------------------------------------------------------------
//
//  Typed AD IR definitions for reverse-mode autodiff
//
//-----------------------------------------------------------------------

//-----------------------------------------------------------------------
//  Type System - Compositional type representation
//-----------------------------------------------------------------------

/**
 * @brief Type kinds for AD IR type system.
 *
 * Enables compositional type representation where complex types
 * are built from simpler ones (e.g., const double& = const_(ref_(double_))).
 */
ad_type_kind: @enum type = {
    auto_;          // auto keyword
    void_;          // void
    int_;           // int
    size_t_;        // size_t
    double_;        // double
    float_;         // float
    bool_;          // bool
    char_;          // char
    named;          // Named type (e.g., std::vector<double>, custom types)
    const_;         // const T (inner type in inner_type)
    ref;            // T& (inner type in inner_type)
    rvalue_ref;     // T&& (inner type in inner_type)
    pointer;        // T* (inner type in inner_type)
    array;          // T[N] (inner type in inner_type, size in array_size)
    template_;      // Template instantiation T<Args...> (name + type_args)
}

/**
 * @brief Compositional type representation for AD IR.
 *
 * Types are represented as trees where qualifiers and modifiers
 * wrap inner types. This enables type transformations as tree operations.
 *
 * Examples:
 * - double -> ad_type_kind::double_
 * - const double -> ad_type_kind::const_ with inner = double_
 * - double& -> ad_type_kind::ref with inner = double_
 * - const double& -> ad_type_kind::const_ with inner = (ref with inner = double_)
 * - std::vector<double> -> ad_type_kind::template_ with name="std::vector", type_args=[double_]
 */
ad_type: type = {
    public kind       : ad_type_kind = ad_type_kind::double_;
    public name       : std::string = "";                      // For named/template types
    public inner_type : std::shared_ptr<ad_type> = ();         // For const/ref/ptr/array
    public type_args  : std::vector<ad_type> = ();             // For template types
    public array_size : int = 0;                               // For array types

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    // ===== Factory methods for primitive types =====

    /**
     * @brief Create an auto type.
     * @return auto type node.
     */
    make_auto: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::auto_;
        return t;
    }

    /**
     * @brief Create a void type.
     * @return void type node.
     */
    make_void: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::void_;
        return t;
    }

    /**
     * @brief Create an int type.
     * @return int type node.
     */
    make_int: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::int_;
        return t;
    }

    /**
     * @brief Create a size_t type.
     * @return size_t type node.
     */
    make_size_t: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::size_t_;
        return t;
    }

    /**
     * @brief Create a double type.
     * @return double type node.
     */
    make_double: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::double_;
        return t;
    }

    /**
     * @brief Create a float type.
     * @return float type node.
     */
    make_float: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::float_;
        return t;
    }

    /**
     * @brief Create a bool type.
     * @return bool type node.
     */
    make_bool: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::bool_;
        return t;
    }

    /**
     * @brief Create a char type.
     * @return char type node.
     */
    make_char: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::char_;
        return t;
    }

    // ===== Factory methods for composite types =====

    /**
     * @brief Create a named type (non-template).
     * @param type_name Fully qualified type name.
     * @return Named type node.
     */
    make_named: (type_name: std::string) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::named;
        t.name = type_name;
        return t;
    }

    /**
     * @brief Create a const-qualified type.
     * @param inner The type being const-qualified.
     * @return const T type node.
     */
    make_const: (inner: ad_type) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::const_;
        t.inner_type = std::make_shared<ad_type>(inner);
        return t;
    }

    /**
     * @brief Create an lvalue reference type.
     * @param inner The type being referenced.
     * @return T& type node.
     */
    make_ref: (inner: ad_type) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::ref;
        t.inner_type = std::make_shared<ad_type>(inner);
        return t;
    }

    /**
     * @brief Create an rvalue reference type.
     * @param inner The type being referenced.
     * @return T&& type node.
     */
    make_rvalue_ref: (inner: ad_type) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::rvalue_ref;
        t.inner_type = std::make_shared<ad_type>(inner);
        return t;
    }

    /**
     * @brief Create a pointer type.
     * @param inner The pointed-to type.
     * @return T* type node.
     */
    make_pointer: (inner: ad_type) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::pointer;
        t.inner_type = std::make_shared<ad_type>(inner);
        return t;
    }

    /**
     * @brief Create an array type.
     * @param inner Element type.
     * @param size Array size (0 for unsized).
     * @return T[N] type node.
     */
    make_array: (inner: ad_type, size: int) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::array;
        t.inner_type = std::make_shared<ad_type>(inner);
        t.array_size = size;
        return t;
    }

    /**
     * @brief Create a template instantiation type.
     * @param template_name Template name (e.g., "std::vector").
     * @param args Template type arguments.
     * @return Template type node.
     */
    make_template: (template_name: std::string, args: std::vector<ad_type>) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::template_;
        t.name = template_name;
        t.type_args = args;
        return t;
    }

    // ===== Convenience factory methods for common patterns =====

    /**
     * @brief Create a const reference type (const T&).
     * @param inner The type being const-referenced.
     * @return const T& type node.
     */
    make_const_ref: (inner: ad_type) -> ad_type = {
        return make_const(make_ref(inner));
    }

    /**
     * @brief Create std::vector<T> type.
     * @param elem Element type.
     * @return std::vector<T> type node.
     */
    make_std_vector: (elem: ad_type) -> ad_type = {
        args: std::vector<ad_type> = ();
        args.push_back(elem);
        return make_template("std::vector", args);
    }

    // ===== Type query methods =====

    /**
     * @brief Check if this type is const-qualified.
     * @return true if const-qualified.
     */
    is_const: (this) -> bool = {
        return kind == ad_type_kind::const_;
    }

    /**
     * @brief Check if this type is a reference.
     * @return true if lvalue or rvalue reference.
     */
    is_reference: (this) -> bool = {
        return kind == ad_type_kind::ref || kind == ad_type_kind::rvalue_ref;
    }

    /**
     * @brief Check if this type is a pointer.
     * @return true if pointer type.
     */
    is_pointer: (this) -> bool = {
        return kind == ad_type_kind::pointer;
    }

    /**
     * @brief Get the underlying type, stripping qualifiers and modifiers.
     * @return Base type (recursive unwrap).
     */
    get_base_type: (this) -> ad_type = {
        if inner_type != nullptr {
            return inner_type*.get_base_type();
        }
        return this;
    }
}

/**
 * @brief Convert ad_type to string representation for code emission.
 * @param t Type to convert.
 * @return String representation of the type.
 */
ad_type_to_string: (t: ad_type) -> std::string = {
    if t.kind == ad_type_kind::auto_    { return "auto"; }
    if t.kind == ad_type_kind::void_    { return "void"; }
    if t.kind == ad_type_kind::int_     { return "int"; }
    if t.kind == ad_type_kind::size_t_  { return "size_t"; }
    if t.kind == ad_type_kind::double_  { return "double"; }
    if t.kind == ad_type_kind::float_   { return "float"; }
    if t.kind == ad_type_kind::bool_    { return "bool"; }
    if t.kind == ad_type_kind::char_    { return "char"; }
    if t.kind == ad_type_kind::named    { return t.name; }

    if t.kind == ad_type_kind::const_ {
        if t.inner_type != nullptr {
            return "const " + ad_type_to_string(t.inner_type*);
        }
        return "const";
    }
    if t.kind == ad_type_kind::ref {
        if t.inner_type != nullptr {
            return ad_type_to_string(t.inner_type*) + "&";
        }
        return "&";
    }
    if t.kind == ad_type_kind::rvalue_ref {
        if t.inner_type != nullptr {
            return ad_type_to_string(t.inner_type*) + "&&";
        }
        return "&&";
    }
    if t.kind == ad_type_kind::pointer {
        if t.inner_type != nullptr {
            return ad_type_to_string(t.inner_type*) + "*";
        }
        return "*";
    }
    if t.kind == ad_type_kind::array {
        if t.inner_type != nullptr {
            if t.array_size > 0 {
                return ad_type_to_string(t.inner_type*) + "[" + std::to_string(t.array_size) + "]";
            }
            return ad_type_to_string(t.inner_type*) + "[]";
        }
        return "[]";
    }
    if t.kind == ad_type_kind::template_ {
        result: std::string = t.name + "<";
        (copy first: bool = true)
        for t.type_args do (arg) {
            if !first { result += ", "; }
            first = false;
            result += ad_type_to_string(arg);
        }
        result += ">";
        return result;
    }
    return "unknown_type";
}

//-----------------------------------------------------------------------
//  Operation kinds for AD expressions
//-----------------------------------------------------------------------

/**
 * @brief Operation kinds for AD expressions.
 *
 * These tags identify the operation type for expression nodes in the AD IR.
 * Binary operators (+, -, *, /) are handled explicitly by the builder.
 * Function calls (sin, cos, exp, log, etc.) use the call tag.
 */
ad_op_kind: @enum type = {
    // Arithmetic operators
    add;        // Binary addition
    sub;        // Binary subtraction
    mul;        // Binary multiplication
    div;        // Binary division
    mod;        // Binary modulo
    neg;        // Unary negation
    pos;        // Unary plus

    // Increment/Decrement
    pre_inc;    // Prefix increment (++x)
    pre_dec;    // Prefix decrement (--x)
    post_inc;   // Postfix increment (x++)
    post_dec;   // Postfix decrement (x--)

    // Comparison operators
    eq;         // Equal (==)
    ne;         // Not equal (!=)
    lt;         // Less than (<)
    gt;         // Greater than (>)
    le;         // Less or equal (<=)
    ge;         // Greater or equal (>=)
    spaceship;  // Three-way comparison (<=>)

    // Logical operators
    land;       // Logical AND (&&)
    lor;        // Logical OR (||)
    lnot;       // Logical NOT (!)

    // Bitwise operators
    band;       // Bitwise AND (&)
    bor;        // Bitwise OR (|)
    bxor;       // Bitwise XOR (^)
    bnot;       // Bitwise NOT (~)
    shl;        // Left shift (<<)
    shr;        // Right shift (>>)

    // Pointer/Reference operators
    deref;      // Dereference (*)
    addr_of;    // Address-of (&)

    // Assignment operators (for compound assignments)
    assign;     // Simple assignment (=)
    assign_add; // Add-assign (+=)
    assign_sub; // Subtract-assign (-=)
    assign_mul; // Multiply-assign (*=)
    assign_div; // Divide-assign (/=)
    assign_mod; // Modulo-assign (%=)
    assign_band;// Bitwise AND-assign (&=)
    assign_bor; // Bitwise OR-assign (|=)
    assign_bxor;// Bitwise XOR-assign (^=)
    assign_shl; // Left shift-assign (<<=)
    assign_shr; // Right shift-assign (>>=)

    // Member access operators
    dot;        // Member access (.)
    arrow;      // Pointer member access (->)

    // Function call (unchanged from before)
    call;       // Function call (differentiation rules looked up by name)
    literal;    // Numeric literal
    identifier; // Variable reference
}

/**
 * @brief Expression node kinds for AD IR.
 *
 * Distinguishes between different expression forms in the typed IR.
 * Extended to cover all C++ expression forms needed in autodiff rules.
 */
ad_expr_kind: @enum type = {
    // Values
    literal;        // Numeric/string literal (e.g., 3.0, "hello")
    identifier;     // Variable reference (e.g., x)

    // Operations
    unary;          // Unary operation (e.g., -x, !x, ++x)
    binary;         // Binary operation (e.g., x + y, x && y)
    ternary;        // Conditional expression (a ? b : c)

    // Access
    member;         // Member access (obj.member or obj->member)
    subscript;      // Array/container subscript (arr[i])

    // Calls
    call;           // Function call (e.g., sin(x), std::abs(y))
    method_call;    // Method call (obj.method(args))

    // Type operations
    cast;           // Type cast (static_cast<T>(x))
    construct;      // Constructor call (T(args) or T{args})

    // Special
    paren;          // Parenthesized expression ((expr))
    lambda;         // Lambda expression ([captures](params) { body })
    initializer_list; // Initializer list ({a, b, c})
}

/**
 * @brief Statement node kinds for AD IR.
 *
 * Distinguishes between different statement forms in the typed IR.
 * Extended to support loops, jumps, and all compound assignment forms.
 */
ad_stmt_kind: @enum type = {
    // Declarations
    decl;           // Local variable declaration (name: type = init)

    // Assignments
    assign;         // Simple assignment (x = expr)
    compound_assign;// Compound assignment (x += expr, x -= expr, etc.)
                    // Uses op field to determine the compound operator

    // Legacy compound assignments (kept for backward compatibility)
    assign_add;     // Add-assignment statement (+=) - prefer compound_assign

    // Control flow
    if_stmt;        // If statement with optional else
    for_stmt;       // C-style for loop (for init; cond; incr { body })
    foreach_stmt;   // Range-based for loop (for item in range { body })
    while_stmt;     // While loop (while cond { body })
    do_while_stmt;  // Do-while loop (do { body } while cond)
    switch_stmt;    // Switch statement (switch expr { cases })

    // Jumps
    return_;        // Return statement
    break_stmt;     // Break statement
    continue_stmt;  // Continue statement

    // Blocks
    compound;       // Compound statement/block ({ stmts })
    expr_stmt;      // Expression statement (expr;) - alias for expr

    // Legacy
    expr;           // Expression statement (kept for backward compatibility)
    raw_code;       // Raw code string - DEPRECATED, to be removed

    // Exception handling (future)
    try_catch;      // Try-catch block
    throw_stmt;     // Throw statement
}

/**
 * @brief Typed IR expression node.
 *
 * Represents an expression in the AD IR. The `kind` field determines
 * how other fields are interpreted:
 * - literal: `name` holds the literal value string
 * - identifier: `name` holds the variable name
 * - unary: `op` holds the operation, `args[0]` is the operand
 * - binary: `op` holds the operation, `args[0]` and `args[1]` are operands
 * - ternary: `args[0]` is condition, `args[1]` is then-expr, `args[2]` is else-expr
 * - member: `args[0]` is object, `member_name` is member, `op` is dot/arrow
 * - subscript: `args[0]` is array/container, `args[1]` is index
 * - call: `name` is function name, `args` are arguments, `type_args` for template args
 * - method_call: `args[0]` is object, `name` is method, `args[1..]` are call arguments
 * - cast: `name` is cast kind (static_cast etc), `cast_type` is target type, `args[0]` is expr
 * - construct: `name` is type name, `args` are constructor arguments
 * - paren: `args[0]` is inner expression
 * - lambda: `lambda_body` holds the body statements, `lambda_params` holds parameters
 * - initializer_list: `args` holds the list elements
 */
ad_expr: type = {
    public kind         : ad_expr_kind = ad_expr_kind::literal;
    public type_name    : std::string = "";                       // Result type (string form)
    public expr_type    : std::shared_ptr<ad_type> = ();          // Result type (structured form)
    public name         : std::string = "";                       // For identifiers/literals/calls
    public op           : ad_op_kind  = ad_op_kind::add;          // Operation kind
    public args         : std::vector<ad_expr> = ();              // Operands/arguments
    public member_name  : std::string = "";                       // For member access
    public type_args    : std::vector<ad_type> = ();              // Template type arguments
    public cast_type    : std::shared_ptr<ad_type> = ();          // Target type for casts
    public lambda_params: std::vector<std::pair<std::string, std::string>> = (); // Lambda params (name, type)
    public lambda_body  : std::shared_ptr<std::vector<ad_stmt>> = (); // Lambda body (forward decl workaround)

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    // ===== Factory methods for basic expressions =====

    /**
     * @brief Create a literal expression.
     * @param value Literal value as string.
     * @param type_name_ Type of the literal.
     * @return Literal expression node.
     */
    make_literal: (value: std::string, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::literal;
        e.name = value;
        e.type_name = type_name_;
        e.op = ad_op_kind::literal;
        return e;
    }

    /**
     * @brief Create a literal expression with structured type.
     * @param value Literal value as string.
     * @param t Structured type.
     * @return Literal expression node.
     */
    make_literal_typed: (value: std::string, t: ad_type) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::literal;
        e.name = value;
        e.type_name = ad_type_to_string(t);
        e.expr_type = std::make_shared<ad_type>(t);
        e.op = ad_op_kind::literal;
        return e;
    }

    /**
     * @brief Create an identifier expression.
     * @param name_ Variable name.
     * @param type_name_ Type of the variable.
     * @return Identifier expression node.
     */
    make_identifier: (name_: std::string, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::identifier;
        e.name = name_;
        e.type_name = type_name_;
        e.op = ad_op_kind::identifier;
        return e;
    }

    /**
     * @brief Create an identifier expression with structured type.
     * @param name_ Variable name.
     * @param t Structured type.
     * @return Identifier expression node.
     */
    make_identifier_typed: (name_: std::string, t: ad_type) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::identifier;
        e.name = name_;
        e.type_name = ad_type_to_string(t);
        e.expr_type = std::make_shared<ad_type>(t);
        e.op = ad_op_kind::identifier;
        return e;
    }

    // ===== Factory methods for operations =====

    /**
     * @brief Create a unary expression.
     * @param op_ Operation kind (e.g., neg, lnot, pre_inc).
     * @param operand Operand expression.
     * @param type_name_ Result type.
     * @return Unary expression node.
     */
    make_unary: (op_: ad_op_kind, operand: ad_expr, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::unary;
        e.op = op_;
        e.type_name = type_name_;
        e.args.push_back(operand);
        return e;
    }

    /**
     * @brief Create a binary expression.
     * @param op_ Operation kind (e.g., add, mul, lt, land).
     * @param lhs Left operand.
     * @param rhs Right operand.
     * @param type_name_ Result type.
     * @return Binary expression node.
     */
    make_binary: (op_: ad_op_kind, lhs: ad_expr, rhs: ad_expr, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::binary;
        e.op = op_;
        e.type_name = type_name_;
        e.args.push_back(lhs);
        e.args.push_back(rhs);
        return e;
    }

    /**
     * @brief Create a ternary (conditional) expression.
     * @param condition Condition expression.
     * @param then_expr Expression if condition is true.
     * @param else_expr Expression if condition is false.
     * @param type_name_ Result type.
     * @return Ternary expression node.
     */
    make_ternary: (condition: ad_expr, then_expr: ad_expr, else_expr: ad_expr,
                   type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::ternary;
        e.type_name = type_name_;
        e.args.push_back(condition);
        e.args.push_back(then_expr);
        e.args.push_back(else_expr);
        return e;
    }

    // ===== Factory methods for access expressions =====

    /**
     * @brief Create a member access expression (obj.member or obj->member).
     * @param object Object expression.
     * @param member Member name.
     * @param is_arrow true for ->, false for .
     * @param type_name_ Result type.
     * @return Member access expression node.
     */
    make_member: (object: ad_expr, member: std::string, is_arrow: bool,
                  type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::member;
        if is_arrow { e.op = ad_op_kind::arrow; }
        else        { e.op = ad_op_kind::dot; }
        e.member_name = member;
        e.type_name = type_name_;
        e.args.push_back(object);
        return e;
    }

    /**
     * @brief Create a subscript expression (arr[index]).
     * @param array Array/container expression.
     * @param index Index expression.
     * @param type_name_ Result type (element type).
     * @return Subscript expression node.
     */
    make_subscript: (array: ad_expr, index: ad_expr, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::subscript;
        e.type_name = type_name_;
        e.args.push_back(array);
        e.args.push_back(index);
        return e;
    }

    // ===== Factory methods for calls =====

    /**
     * @brief Create a function call expression.
     * @param func_name Function name.
     * @param op_ Operation kind (call or specific like sin).
     * @param call_args Arguments to the function.
     * @param type_name_ Result type.
     * @return Call expression node.
     */
    make_call: (func_name: std::string, op_: ad_op_kind, call_args: std::vector<ad_expr>, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::call;
        e.name = func_name;
        e.op = op_;
        e.type_name = type_name_;
        e.args = call_args;
        return e;
    }

    /**
     * @brief Create a function call with template arguments.
     * @param func_name Function name.
     * @param call_args Arguments to the function.
     * @param template_args Template type arguments.
     * @param type_name_ Result type.
     * @return Call expression node with template arguments.
     */
    make_template_call: (func_name: std::string, call_args: std::vector<ad_expr>,
                         template_args: std::vector<ad_type>, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::call;
        e.name = func_name;
        e.op = ad_op_kind::call;
        e.type_name = type_name_;
        e.args = call_args;
        e.type_args = template_args;
        return e;
    }

    /**
     * @brief Create a method call expression (obj.method(args)).
     * @param object Object expression.
     * @param method_name Method name.
     * @param call_args Arguments to the method.
     * @param type_name_ Result type.
     * @return Method call expression node.
     */
    make_method_call: (object: ad_expr, method_name: std::string,
                       call_args: std::vector<ad_expr>, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::method_call;
        e.name = method_name;
        e.op = ad_op_kind::call;
        e.type_name = type_name_;
        e.args.push_back(object);
        for call_args do (arg) {
            e.args.push_back(arg);
        }
        return e;
    }

    // ===== Factory methods for type operations =====

    /**
     * @brief Create a type cast expression.
     * @param cast_kind Cast kind ("static_cast", "dynamic_cast", "reinterpret_cast", "const_cast", or "").
     * @param target_type Target type.
     * @param expr Expression to cast.
     * @param type_name_ Result type name.
     * @return Cast expression node.
     */
    make_cast: (cast_kind: std::string, target_type: ad_type, expr: ad_expr,
                type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::cast;
        e.name = cast_kind;  // "static_cast", etc.
        e.type_name = type_name_;
        e.cast_type = std::make_shared<ad_type>(target_type);
        e.args.push_back(expr);
        return e;
    }

    /**
     * @brief Create a constructor call expression (T(args) or T{args}).
     * @param type_name_ Type being constructed.
     * @param construct_args Constructor arguments.
     * @return Constructor expression node.
     */
    make_construct: (type_name_: std::string, construct_args: std::vector<ad_expr>) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::construct;
        e.name = type_name_;
        e.type_name = type_name_;
        e.args = construct_args;
        return e;
    }

    // ===== Factory methods for special expressions =====

    /**
     * @brief Create a parenthesized expression.
     * @param inner Inner expression.
     * @return Parenthesized expression node.
     */
    make_paren: (inner: ad_expr) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::paren;
        e.type_name = inner.type_name;
        e.args.push_back(inner);
        return e;
    }

    /**
     * @brief Create an initializer list expression ({a, b, c}).
     * @param elements List elements.
     * @param type_name_ Result type (e.g., "std::initializer_list<int>").
     * @return Initializer list expression node.
     */
    make_initializer_list: (elements: std::vector<ad_expr>, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::initializer_list;
        e.type_name = type_name_;
        e.args = elements;
        return e;
    }

    // ===== Convenience factory methods =====

    /**
     * @brief Create an integer literal.
     * @param value Integer value.
     * @return Integer literal expression.
     */
    make_int_literal: (value: int) -> ad_expr = {
        return make_literal(std::to_string(value), "int");
    }

    /**
     * @brief Create a double literal.
     * @param value Double value.
     * @return Double literal expression.
     */
    make_double_literal: (value: double) -> ad_expr = {
        return make_literal(std::to_string(value), "double");
    }

    /**
     * @brief Create a boolean literal.
     * @param value Boolean value.
     * @return Boolean literal expression.
     */
    make_bool_literal: (value: bool) -> ad_expr = {
        if value { return make_literal("true", "bool"); }
        return make_literal("false", "bool");
    }
}

/**
 * @brief Typed IR statement node.
 *
 * Represents a statement in the AD IR. The `kind` field determines
 * how other fields are interpreted:
 * - decl: `target` is variable name, `type_name`/`decl_type` is its type, `expr` is initializer
 * - assign: `target` is variable name, `expr` is the value
 * - compound_assign: `target` is variable, `op` determines operator, `expr` is value
 * - expr/expr_stmt: `expr` is the expression to evaluate
 * - return_: `expr` is the return value
 * - compound: `stmts` contains nested statements
 * - if_stmt: `expr` is condition, `stmts` is then-branch, `else_stmts` is else-branch
 * - for_stmt: `init_stmt` is init, `expr` is condition, `incr_expr` is increment, `stmts` is body
 * - foreach_stmt: `target` is loop var, `type_name` is var type, `range_expr` is range, `stmts` is body
 * - while_stmt: `expr` is condition, `stmts` is body
 * - do_while_stmt: `stmts` is body, `expr` is condition
 * - break_stmt/continue_stmt: no additional fields
 * - switch_stmt: `expr` is switch expression, `switch_cases` holds case/default blocks
 */
ad_stmt: type = {
    public kind       : ad_stmt_kind = ad_stmt_kind::expr;
    public target     : std::string = "";                      // Variable name for decl/assign
    public type_name  : std::string = "";                      // Type string for declarations
    public decl_type  : std::shared_ptr<ad_type> = ();         // Structured type for declarations
    public op         : ad_op_kind = ad_op_kind::assign;       // For compound_assign
    public expr       : ad_expr = ();                          // Main expression
    public stmts      : std::vector<ad_stmt> = ();             // Body statements
    public else_stmts : std::vector<ad_stmt> = ();             // Else branch for if_stmt

    // Loop-specific fields
    public init_stmt  : std::shared_ptr<ad_stmt> = ();         // for(init; ...; ...)
    public incr_expr  : ad_expr = ();                          // for(...; ...; incr)
    public range_expr : ad_expr = ();                          // foreach range expression

    // Switch-specific fields (case value expr, case body statements)
    public switch_cases: std::vector<std::pair<ad_expr, std::vector<ad_stmt>>> = ();
    public default_case: std::vector<ad_stmt> = ();            // default case body

    // Exception handling fields
    public catch_var  : std::string = "";                      // catch(Type catch_var)
    public catch_type : std::string = "";                      // catch type
    public catch_stmts: std::vector<ad_stmt> = ();             // catch body

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    // ===== Factory methods for declarations and assignments =====

    /**
     * @brief Create a declaration statement.
     * @param name Variable name.
     * @param type_name_ Variable type.
     * @param init Initializer expression.
     * @return Declaration statement node.
     */
    make_decl: (name: std::string, type_name_: std::string, init: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::decl;
        s.target = name;
        s.type_name = type_name_;
        s.expr = init;
        return s;
    }

    /**
     * @brief Create a declaration statement with structured type.
     * @param name Variable name.
     * @param t Structured type.
     * @param init Initializer expression.
     * @return Declaration statement node.
     */
    make_decl_typed: (name: std::string, t: ad_type, init: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::decl;
        s.target = name;
        s.type_name = ad_type_to_string(t);
        s.decl_type = std::make_shared<ad_type>(t);
        s.expr = init;
        return s;
    }

    /**
     * @brief Create an assignment statement.
     * @param name Target variable name.
     * @param value Value expression.
     * @return Assignment statement node.
     */
    make_assign: (name: std::string, value: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::assign;
        s.target = name;
        s.expr = value;
        return s;
    }

    /**
     * @brief Create a compound assignment statement (+=, -=, *=, /=, etc.).
     * @param name Target variable name.
     * @param op_ Compound assignment operator (assign_add, assign_sub, etc.).
     * @param value Value expression.
     * @return Compound assignment statement node.
     */
    make_compound_assign: (name: std::string, op_: ad_op_kind, value: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::compound_assign;
        s.target = name;
        s.op = op_;
        s.expr = value;
        return s;
    }

    /**
     * @brief Create an add-assignment statement (+=).
     * @param name Target variable name.
     * @param value Value expression to add.
     * @return Add-assignment statement node.
     * @note Legacy method - prefer make_compound_assign for new code.
     */
    make_assign_add: (name: std::string, value: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::assign_add;
        s.target = name;
        s.expr = value;
        return s;
    }

    /**
     * @brief Create a subtract-assignment statement (-=).
     * @param name Target variable name.
     * @param value Value expression to subtract.
     * @return Subtract-assignment statement node.
     */
    make_assign_sub: (name: std::string, value: ad_expr) -> ad_stmt = {
        return make_compound_assign(name, ad_op_kind::assign_sub, value);
    }

    /**
     * @brief Create a multiply-assignment statement (*=).
     * @param name Target variable name.
     * @param value Value expression to multiply.
     * @return Multiply-assignment statement node.
     */
    make_assign_mul: (name: std::string, value: ad_expr) -> ad_stmt = {
        return make_compound_assign(name, ad_op_kind::assign_mul, value);
    }

    /**
     * @brief Create a divide-assignment statement (/=).
     * @param name Target variable name.
     * @param value Value expression to divide.
     * @return Divide-assignment statement node.
     */
    make_assign_div: (name: std::string, value: ad_expr) -> ad_stmt = {
        return make_compound_assign(name, ad_op_kind::assign_div, value);
    }

    // ===== Factory methods for expression and return statements =====

    /**
     * @brief Create an expression statement.
     * @param e Expression to evaluate.
     * @return Expression statement node.
     */
    make_expr: (e: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::expr;
        s.expr = e;
        return s;
    }

    /**
     * @brief Create a return statement.
     * @param value Return value expression.
     * @return Return statement node.
     */
    make_return: (value: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::return_;
        s.expr = value;
        return s;
    }

    // ===== Factory methods for control flow =====

    /**
     * @brief Create a compound statement.
     * @param nested Nested statements.
     * @return Compound statement node.
     */
    make_compound: (nested: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::compound;
        s.stmts = nested;
        return s;
    }

    /**
     * @brief Create an if statement.
     * @param condition Condition expression.
     * @param then_body Statements for the then branch.
     * @param else_body Statements for the else branch (may be empty).
     * @return If statement node.
     */
    make_if: (condition: ad_expr, then_body: std::vector<ad_stmt>,
              else_body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::if_stmt;
        s.expr = condition;
        s.stmts = then_body;
        s.else_stmts = else_body;
        return s;
    }

    /**
     * @brief Create a C-style for loop.
     * @param init Initialization statement.
     * @param condition Loop condition.
     * @param increment Increment expression.
     * @param body Loop body statements.
     * @return For loop statement node.
     */
    make_for: (init: ad_stmt, condition: ad_expr, increment: ad_expr,
               body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::for_stmt;
        s.init_stmt = std::make_shared<ad_stmt>(init);
        s.expr = condition;
        s.incr_expr = increment;
        s.stmts = body;
        return s;
    }

    /**
     * @brief Create a range-based for loop (foreach).
     * @param var_name Loop variable name.
     * @param var_type Loop variable type.
     * @param range Range expression.
     * @param body Loop body statements.
     * @return Foreach loop statement node.
     */
    make_foreach: (var_name: std::string, var_type: std::string,
                   range: ad_expr, body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::foreach_stmt;
        s.target = var_name;
        s.type_name = var_type;
        s.range_expr = range;
        s.stmts = body;
        return s;
    }

    /**
     * @brief Create a while loop.
     * @param condition Loop condition.
     * @param body Loop body statements.
     * @return While loop statement node.
     */
    make_while: (condition: ad_expr, body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::while_stmt;
        s.expr = condition;
        s.stmts = body;
        return s;
    }

    /**
     * @brief Create a do-while loop.
     * @param body Loop body statements.
     * @param condition Loop condition (checked after body).
     * @return Do-while loop statement node.
     */
    make_do_while: (body: std::vector<ad_stmt>, condition: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::do_while_stmt;
        s.stmts = body;
        s.expr = condition;
        return s;
    }

    // ===== Factory methods for jump statements =====

    /**
     * @brief Create a break statement.
     * @return Break statement node.
     */
    make_break: () -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::break_stmt;
        return s;
    }

    /**
     * @brief Create a continue statement.
     * @return Continue statement node.
     */
    make_continue: () -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::continue_stmt;
        return s;
    }

    // ===== Factory methods for switch statement =====

    /**
     * @brief Create a switch statement.
     * @param switch_expr Expression to switch on.
     * @param cases Vector of (case_value, case_body) pairs.
     * @param default_body Default case body (may be empty).
     * @return Switch statement node.
     */
    make_switch: (switch_expr: ad_expr,
                  cases: std::vector<std::pair<ad_expr, std::vector<ad_stmt>>>,
                  default_body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::switch_stmt;
        s.expr = switch_expr;
        s.switch_cases = cases;
        s.default_case = default_body;
        return s;
    }

    // ===== Factory methods for exception handling =====

    /**
     * @brief Create a try-catch statement.
     * @param try_body Try block statements.
     * @param catch_type_ Exception type to catch.
     * @param catch_var_ Variable name for caught exception.
     * @param catch_body Catch block statements.
     * @return Try-catch statement node.
     */
    make_try_catch: (try_body: std::vector<ad_stmt>,
                     catch_type_: std::string, catch_var_: std::string,
                     catch_body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::try_catch;
        s.stmts = try_body;
        s.catch_type = catch_type_;
        s.catch_var = catch_var_;
        s.catch_stmts = catch_body;
        return s;
    }

    /**
     * @brief Create a throw statement.
     * @param throw_expr Expression to throw.
     * @return Throw statement node.
     */
    make_throw: (throw_expr: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::throw_stmt;
        s.expr = throw_expr;
        return s;
    }

    // ===== Legacy factory methods =====

    /**
     * @brief Create a raw code statement for inlined rule bodies.
     * @param code Raw Cpp2 code string to emit.
     * @return Raw code statement node.
     * @deprecated Will be removed after IR-based rule substitution is complete.
     */
    make_raw_code: (code: std::string) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::raw_code;
        s.target = code;  // Store raw code in target field
        return s;
    }
}

/**
 * @brief Typed IR parameter declaration.
 *
 * Represents a function parameter or return value in the AD IR.
 */
ad_param: type = {
    public name      : std::string = "";
    public type_name : std::string = "";
    public pass      : passing_style = passing_style::in;
    public is_active : bool = false;

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    /**
     * @brief Create a parameter.
     * @param name_ Parameter name.
     * @param type_name_ Parameter type.
     * @param pass_ Passing style.
     * @param is_active_ Whether the parameter is active for AD.
     * @return Parameter node.
     */
    make: (name_: std::string, type_name_: std::string, pass_: passing_style, is_active_: bool) -> ad_param = {
        p: ad_param = ();
        p.name = name_;
        p.type_name = type_name_;
        p.pass = pass_;
        p.is_active = is_active_;
        return p;
    }
}

/**
 * @brief Typed IR for a reverse-mode function.
 *
 * Contains the complete IR representation of a function being transformed
 * for reverse-mode autodiff, including parameters, returns, and the
 * forward/reverse pass statements.
 */
ad_function_ir: type = {
    public name    : std::string = "";
    public params  : std::vector<ad_param> = ();
    public returns : std::vector<ad_param> = ();
    public forward : std::vector<ad_stmt>  = ();
    public reverse : std::vector<ad_stmt>  = ();

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}
}

//-----------------------------------------------------------------------
//
//  AD IR debug dump functions
//
//-----------------------------------------------------------------------

/**
 * @brief Convert ad_op_kind to string for debug output.
 * @param op Operation kind.
 * @return String representation.
 */
ad_op_kind_to_string: (op: ad_op_kind) -> std::string = {
    // Arithmetic
    if op == ad_op_kind::add        { return "add"; }
    if op == ad_op_kind::sub        { return "sub"; }
    if op == ad_op_kind::mul        { return "mul"; }
    if op == ad_op_kind::div        { return "div"; }
    if op == ad_op_kind::mod        { return "mod"; }
    if op == ad_op_kind::neg        { return "neg"; }
    if op == ad_op_kind::pos        { return "pos"; }

    // Increment/Decrement
    if op == ad_op_kind::pre_inc    { return "pre_inc"; }
    if op == ad_op_kind::pre_dec    { return "pre_dec"; }
    if op == ad_op_kind::post_inc   { return "post_inc"; }
    if op == ad_op_kind::post_dec   { return "post_dec"; }

    // Comparison
    if op == ad_op_kind::eq         { return "eq"; }
    if op == ad_op_kind::ne         { return "ne"; }
    if op == ad_op_kind::lt         { return "lt"; }
    if op == ad_op_kind::gt         { return "gt"; }
    if op == ad_op_kind::le         { return "le"; }
    if op == ad_op_kind::ge         { return "ge"; }
    if op == ad_op_kind::spaceship  { return "spaceship"; }

    // Logical
    if op == ad_op_kind::land       { return "land"; }
    if op == ad_op_kind::lor        { return "lor"; }
    if op == ad_op_kind::lnot       { return "lnot"; }

    // Bitwise
    if op == ad_op_kind::band       { return "band"; }
    if op == ad_op_kind::bor        { return "bor"; }
    if op == ad_op_kind::bxor       { return "bxor"; }
    if op == ad_op_kind::bnot       { return "bnot"; }
    if op == ad_op_kind::shl        { return "shl"; }
    if op == ad_op_kind::shr        { return "shr"; }

    // Pointer/Reference
    if op == ad_op_kind::deref      { return "deref"; }
    if op == ad_op_kind::addr_of    { return "addr_of"; }

    // Assignment
    if op == ad_op_kind::assign     { return "assign"; }
    if op == ad_op_kind::assign_add { return "assign_add"; }
    if op == ad_op_kind::assign_sub { return "assign_sub"; }
    if op == ad_op_kind::assign_mul { return "assign_mul"; }
    if op == ad_op_kind::assign_div { return "assign_div"; }
    if op == ad_op_kind::assign_mod { return "assign_mod"; }
    if op == ad_op_kind::assign_band{ return "assign_band"; }
    if op == ad_op_kind::assign_bor { return "assign_bor"; }
    if op == ad_op_kind::assign_bxor{ return "assign_bxor"; }
    if op == ad_op_kind::assign_shl { return "assign_shl"; }
    if op == ad_op_kind::assign_shr { return "assign_shr"; }

    // Member access
    if op == ad_op_kind::dot        { return "dot"; }
    if op == ad_op_kind::arrow      { return "arrow"; }

    // Other
    if op == ad_op_kind::call       { return "call"; }
    if op == ad_op_kind::literal    { return "literal"; }
    if op == ad_op_kind::identifier { return "identifier"; }

    return "unknown";
}

//-----------------------------------------------------------------------
//
//  IR-based parameter substitution for rule bodies
//
//-----------------------------------------------------------------------

/**
 * @brief Substitution context maps parameter names to IR expressions.
 *
 * Used during rule body parsing to replace parameter names (like res_val,
 * x_adj) with the actual IR expressions for those values/adjoints.
 */
ad_substitution_context: type = {
    public substitutions : std::vector<std::pair<std::string, ad_expr>> = ();

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    /**
     * @brief Add a substitution mapping.
     * @param param_name Parameter name to substitute (e.g., "res_val", "x_adj").
     * @param expr IR expression to substitute in place of the parameter.
     */
    add: (inout this, param_name: std::string, expr: ad_expr) = {
        substitutions.push_back(std::make_pair(param_name, expr));
    }

    /**
     * @brief Find a substitution for a parameter name.
     * @param name Parameter name to look up.
     * @param result Output parameter for the found expression.
     * @return true if found, false otherwise.
     */
    find: (this, name: std::string, inout result: ad_expr) -> bool = {
        for substitutions do (sub) {
            if sub.first == name {
                result = sub.second;
                return true;
            }
        }
        return false;
    }

    /**
     * @brief Check if a name has a substitution.
     * @param name Parameter name to check.
     * @return true if a substitution exists for this name.
     */
    has: (this, name: std::string) -> bool = {
        for substitutions do (sub) {
            if sub.first == name {
                return true;
            }
        }
        return false;
    }

    /**
     * @brief Get the number of substitutions.
     * @return Number of substitution mappings.
     */
    size: (this) -> int = {
        return substitutions.ssize();
    }
}

/**
 * @brief Substitute parameter names in an IR expression.
 *
 * Recursively walks the expression tree and replaces identifier nodes
 * whose names match entries in the substitution context.
 *
 * @param expr Expression to process.
 * @param ctx Substitution context mapping names to replacement expressions.
 * @return New expression with substitutions applied.
 */
substitute_expr_params: (expr: ad_expr, ctx: ad_substitution_context) -> ad_expr = {
    // Check if this is an identifier that should be substituted
    if expr.kind == ad_expr_kind::identifier {
        substituted: ad_expr = ();
        if ctx.find(expr.name, substituted) {
            return substituted;
        }
        return expr;
    }

    // For literals, return as-is
    if expr.kind == ad_expr_kind::literal {
        return expr;
    }

    // For unary expressions, substitute in the operand
    if expr.kind == ad_expr_kind::unary {
        if !expr.args.empty() {
            new_operand: ad_expr = substitute_expr_params(expr.args[0], ctx);
            return ad_expr::make_unary(expr.op, new_operand, expr.type_name);
        }
        return expr;
    }

    // For binary expressions, substitute in both operands
    if expr.kind == ad_expr_kind::binary {
        if expr.args.ssize() >= 2 {
            new_lhs: ad_expr = substitute_expr_params(expr.args[0], ctx);
            new_rhs: ad_expr = substitute_expr_params(expr.args[1], ctx);
            return ad_expr::make_binary(expr.op, new_lhs, new_rhs, expr.type_name);
        }
        return expr;
    }

    // For function calls, substitute in the arguments
    if expr.kind == ad_expr_kind::call {
        new_args: std::vector<ad_expr> = ();
        for expr.args do (arg) {
            new_args.push_back(substitute_expr_params(arg, ctx));
        }
        return ad_expr::make_call(expr.name, expr.op, new_args, expr.type_name);
    }

    return expr;
}

/**
 * @brief Substitute parameter names in an IR statement.
 *
 * Recursively processes the statement and any nested expressions/statements,
 * replacing identifier names according to the substitution context.
 *
 * @param stmt Statement to process.
 * @param ctx Substitution context mapping names to replacement expressions.
 * @return New statement with substitutions applied.
 */
substitute_stmt_params: (stmt: ad_stmt, ctx: ad_substitution_context) -> ad_stmt = {
    if stmt.kind == ad_stmt_kind::decl {
        // Substitute in the initializer expression
        new_init: ad_expr = substitute_expr_params(stmt.expr, ctx);
        // Also check if the target name should be substituted
        new_target: std::string = stmt.target;
        target_expr: ad_expr = ();
        if ctx.find(stmt.target, target_expr) && target_expr.kind == ad_expr_kind::identifier {
            new_target = target_expr.name;
        }
        return ad_stmt::make_decl(new_target, stmt.type_name, new_init);
    }

    if stmt.kind == ad_stmt_kind::assign {
        new_value: ad_expr = substitute_expr_params(stmt.expr, ctx);
        // Check if target should be substituted
        new_target: std::string = stmt.target;
        target_expr: ad_expr = ();
        if ctx.find(stmt.target, target_expr) && target_expr.kind == ad_expr_kind::identifier {
            new_target = target_expr.name;
        }
        return ad_stmt::make_assign(new_target, new_value);
    }

    if stmt.kind == ad_stmt_kind::assign_add {
        new_value: ad_expr = substitute_expr_params(stmt.expr, ctx);
        // Check if target should be substituted
        new_target: std::string = stmt.target;
        target_expr: ad_expr = ();
        if ctx.find(stmt.target, target_expr) && target_expr.kind == ad_expr_kind::identifier {
            new_target = target_expr.name;
        }
        return ad_stmt::make_assign_add(new_target, new_value);
    }

    if stmt.kind == ad_stmt_kind::expr {
        new_expr: ad_expr = substitute_expr_params(stmt.expr, ctx);
        return ad_stmt::make_expr(new_expr);
    }

    if stmt.kind == ad_stmt_kind::return_ {
        new_value: ad_expr = substitute_expr_params(stmt.expr, ctx);
        return ad_stmt::make_return(new_value);
    }

    if stmt.kind == ad_stmt_kind::compound {
        new_stmts: std::vector<ad_stmt> = ();
        for stmt.stmts do (s) {
            new_stmts.push_back(substitute_stmt_params(s, ctx));
        }
        return ad_stmt::make_compound(new_stmts);
    }

    if stmt.kind == ad_stmt_kind::if_stmt {
        new_cond: ad_expr = substitute_expr_params(stmt.expr, ctx);
        new_then: std::vector<ad_stmt> = ();
        for stmt.stmts do (s) {
            new_then.push_back(substitute_stmt_params(s, ctx));
        }
        new_else: std::vector<ad_stmt> = ();
        for stmt.else_stmts do (s) {
            new_else.push_back(substitute_stmt_params(s, ctx));
        }
        return ad_stmt::make_if(new_cond, new_then, new_else);
    }

    // For raw_code, we can't substitute (it's a string), return as-is
    return stmt;
}

//-----------------------------------------------------------------------
//
//  Subtask 3: ad_rule registry + discovery
//
//-----------------------------------------------------------------------

/**
 * @brief Metadata for a discovered user-defined AD rule type.
 *
 * An ad_rule is a nested type inside a @autodiff<"reverse"> annotated type
 * that declares `name`, `n_args`, `is_member`, `forward`, and `reverse` members.
 * These rules override the default differentiation for specific function calls.
 */
ad_rule_meta: type = {
    public name      : std::string = "";
    public n_args    : int = 0;
    public is_member : bool = false;
    public rule_type : std::string = "";  // Type name for debug
    public forward_body : std::string = "";  // Forward function body (for debug/emit)
    public reverse_body : std::string = "";  // Reverse function body (for debug/emit)

    // NEW: Store AST statements from the reverse() function body for IR-based parsing
    // This enables proper IR-based substitution instead of string manipulation
    public reverse_body_stmts : std::vector<statement> = ();
    public has_reverse_body_stmts : bool = false;

    /// Default constructor
    operator=: (out this) = {}

    // ad_rule_meta is move-only because it contains std::vector<statement>
    // and statement has deleted copy assignment (it's @polymorphic_base)

    /// Move constructor
    operator=: (out this, move that) = {
        name = that.name;
        n_args = that.n_args;
        is_member = that.is_member;
        rule_type = that.rule_type;
        forward_body = that.forward_body;
        reverse_body = that.reverse_body;
        reverse_body_stmts = that.reverse_body_stmts;
        has_reverse_body_stmts = that.has_reverse_body_stmts;
    }

    /**
     * @brief Create rule metadata.
     * @param name_ Rule name (matches function name).
     * @param n_args_ Number of arguments.
     * @param is_member_ Whether this is a member function rule.
     * @param rule_type_ Name of the rule type (for debug).
     * @return Rule metadata.
     */
    make: (name_: std::string, n_args_: int, is_member_: bool, rule_type_: std::string) -> ad_rule_meta = {
        r: ad_rule_meta = ();
        r.name = name_;
        r.n_args = n_args_;
        r.is_member = is_member_;
        r.rule_type = rule_type_;
        return r;
    }
}

/**
 * @brief Result of applying an AD rule's reverse body.
 *
 * Contains the generated IR statements.
 * All data is owned by this result - no references to registry internals.
 * If ir_success is false, the caller MUST fail with an error - there is no fallback.
 */
ad_reverse_rule_result: type = {
    public found           : bool = false;              // Whether rule exists
    public ir_stmts        : std::vector<ad_stmt> = (); // Generated IR statements
    public ir_success      : bool = false;              // Whether IR parsing succeeded
    public rule_type       : std::string = "";          // For debug messages
    public error_message   : std::string = "";          // Error description if parsing failed

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make_not_found: () -> ad_reverse_rule_result = {
        r: ad_reverse_rule_result = ();
        return r;
    }

    make_success: (stmts: std::vector<ad_stmt>, rule_type_: std::string) -> ad_reverse_rule_result = {
        r: ad_reverse_rule_result = ();
        r.found = true;
        r.ir_stmts = stmts;
        r.ir_success = true;
        r.rule_type = rule_type_;
        return r;
    }

    make_parse_error: (rule_type_: std::string, error_msg: std::string) -> ad_reverse_rule_result = {
        r: ad_reverse_rule_result = ();
        r.found = true;           // Rule was found
        r.ir_success = false;     // But parsing failed
        r.rule_type = rule_type_;
        r.error_message = error_msg;
        return r;
    }
}

/**
 * @brief Registry of user-defined AD rules.
 *
 * Rules are discovered by scanning nested types in the annotated type.
 * The registry owns all rules and provides methods to apply them.
 * Rules never leave the registry - callers receive results, not rule references.
 */
ad_rule_registry: type = {
    public rules: std::vector<ad_rule_meta> = ();

    /// Default constructor
    operator=: (out this) = {}

    /**
     * @brief Register a new rule (takes ownership via move).
     * @param rule Rule metadata to register.
     */
    register_rule: (inout this, move rule: ad_rule_meta) = {
        rules.push_back(rule);
    }

    /**
     * @brief Check if a rule exists.
     */
    has_rule: (this, name_: std::string, n_args_: int, is_member_: bool) -> bool = {
        for rules do (r) {
            if r.name == name_ && r.n_args == n_args_ && r.is_member == is_member_ {
                return true;
            }
        }
        return false;
    }

    /**
     * @brief Get rule type name for debug messages.
     */
    get_rule_type: (this, name_: std::string, n_args_: int, is_member_: bool) -> std::string = {
        for rules do (r) {
            if r.name == name_ && r.n_args == n_args_ && r.is_member == is_member_ {
                return r.rule_type;
            }
        }
        return "";
    }

    /**
     * @brief Apply rule's reverse body with substitutions.
     *
     * Parses the rule's reverse body statements into IR with the given substitution context.
     * All work is done inside the registry - no rule references escape.
     * If the rule has no body or parsing fails, ir_success will be false.
     *
     * @param name_ Function name to match.
     * @param n_args_ Number of arguments.
     * @param is_member_ Whether to match member functions.
     * @param ctx Substitution context for parameter replacement.
     * @return Result with IR statements. Caller MUST check ir_success and fail if false.
     */
    apply_reverse_rule: (this, name_: std::string, n_args_: int, is_member_: bool,
                         ctx: ad_substitution_context) -> ad_reverse_rule_result = {
        for rules do (r) {
            if r.name == name_ && r.n_args == n_args_ && r.is_member == is_member_ {
                // Found the rule - it MUST have a parseable body
                if !r.has_reverse_body_stmts {
                    // Rule exists but has no body - this is a user error
                    return ad_reverse_rule_result::make_parse_error(r.rule_type,
                        "Rule '" + name_ + "' has no reverse() body statements");
                }

                ir_stmts: std::vector<ad_stmt> = ();
                if !parse_rule_body_stmts(r.reverse_body_stmts, ctx, ir_stmts) {
                    // Parsing failed - this is an error, not a fallback case
                    return ad_reverse_rule_result::make_parse_error(r.rule_type,
                        "Failed to parse reverse() body for rule '" + name_ + "'");
                }

                return ad_reverse_rule_result::make_success(ir_stmts, r.rule_type);
            }
        }
        return ad_reverse_rule_result::make_not_found();
    }

    /**
     * @brief Get the number of registered rules.
     * @return Number of rules.
     */
    size: (this) -> int = {
        return rules.ssize();
    }

    /**
     * @brief Check if an operator has a registered rule.
     *
     * Operators are stored with their symbol as the name ("+", "-", "*", "/").
     * This provides a unified interface for both operators and functions.
     *
     * @param op_name Operator symbol (e.g., "+", "-", "*", "/").
     * @return true if a rule exists for this operator.
     */
    has_operator_rule: (this, op_name: std::string) -> bool = {
        // Operators are binary (n_args=2) and not member functions
        return has_rule(op_name, 2, false);
    }

    /**
     * @brief Apply an operator's reverse rule.
     *
     * Operators are treated identically to functions in the rule system.
     * The operator symbol is used as the rule name.
     *
     * @param op_name Operator symbol (e.g., "+", "-", "*", "/").
     * @param ctx Substitution context mapping lhs_val, rhs_val, res_adj, etc.
     * @return Result with IR statements for the reverse pass.
     */
    apply_operator_rule: (this, op_name: std::string,
                          ctx: ad_substitution_context) -> ad_reverse_rule_result = {
        // Operators are binary (n_args=2) and not member functions
        return apply_reverse_rule(op_name, 2, false, ctx);
    }
}

/**
 * @brief Debug dump for ad_rule_meta.
 * @param rule Rule to dump.
 */
ad_rule_debug_dump: (rule: ad_rule_meta) = {
    std::cout << "  rule: name=" << rule.name
              << " n_args=" << rule.n_args
              << " is_member=" << rule.is_member
              << " type=" << rule.rule_type << "\n";
}

/**
 * @brief Debug dump for ad_rule_registry.
 * @param reg Registry to dump.
 */
ad_rule_registry_debug_dump: (reg: ad_rule_registry) = {
    std::cout << "=== AD Rule Registry (" << reg.size() << " rules) ===\n";
    for reg.rules do (r) {
        ad_rule_debug_dump(r);
    }
    std::cout << "=== End AD Rule Registry ===\n";
}

/**
 * @brief Check if a type conforms to the ad_rule pattern (duck-typing predicate).
 *
 * A valid ad_rule type must have:
 * - A `name` member object (string)
 * - An `n_args` member object (int)
 * - A `forward` member function
 * - A `reverse` member function
 *
 * NOTE: This validation is mirrored by @register_autodiff in reflect.h2,
 * which performs the same structural check but with hard-fail error messages.
 * If you change the required members here, update that metafunction too.
 *
 * This predicate also accepts types NOT annotated with @register_autodiff,
 * supporting duck-typing discovery of rule types (e.g., ad_rule_* siblings).
 *
 * @param member_type Type declaration to check.
 * @return True if this looks like an ad_rule.
 */
is_ad_rule_type: (member_type: meta::type_declaration) -> bool = {
    has_name: bool = false;
    has_n_args: bool = false;
    has_forward: bool = false;
    has_reverse: bool = false;

    // Check member objects for name and n_args
    for member_type.get_member_objects() do (obj) {
        if obj.name() == "name" {
            has_name = true;
        }
        if obj.name() == "n_args" {
            has_n_args = true;
        }
    }

    // Check member functions for forward and reverse
    for member_type.get_member_functions() do (func) {
        if func.name() == "forward" {
            has_forward = true;
        }
        if func.name() == "reverse" {
            has_reverse = true;
        }
    }

    return has_name && has_n_args && has_forward && has_reverse;
}

/**
 * @brief Extract ad_rule metadata from a type declaration.
 *
 * Assumes is_ad_rule_type() has already returned true.
 * Extracts the reverse() function body for later inlining.
 *
 * @param member_type Pointer to the rule type to extract from.
 * @return Extracted rule metadata.
 */
extract_ad_rule_meta: (member_type: *meta::type_declaration) -> ad_rule_meta = {
    rule: ad_rule_meta = ();
    rule.rule_type = member_type*.name() as std::string;

    // Extract name, n_args, is_member from member objects
    for member_type*.get_member_objects() do (obj) {
        if obj.name() == "name" {
            // Try to get the initializer value
            if obj.has_initializer() {
                rule.name = obj.initializer().to_string();
                // Strip quotes if present
                if rule.name.starts_with("\"") && rule.name.ends_with("\"") {
                    rule.name = rule.name.substr(1, rule.name.ssize() - 2);
                }
            }
        }
        if obj.name() == "n_args" {
            if obj.has_initializer() {
                init_str: std::string = obj.initializer().to_string() as std::string;
                val: int = 0;
                if string_util::string_to_int(init_str, val) {
                    rule.n_args = val;
                }
            }
        }
        if obj.name() == "is_member" {
            if obj.has_initializer() {
                init_str: std::string_view = obj.initializer().to_string();
                rule.is_member = (init_str == "true");
            }
        }
    }

    // Extract the reverse() function body for later inlining
    for member_type*.get_member_functions() do (func) {
        if func.name() == "reverse" && func.has_compound_body() {
            body: meta::compound_statement = func.get_compound_body();

            // NEW: Store the AST statements for IR-based parsing
            for body.get_statements() do (move stmt) {
                rule.reverse_body_stmts.push_back(stmt);
            }
            rule.has_reverse_body_stmts = true;
            std::cout << "AD: Extracted " << rule.reverse_body_stmts.ssize()
                      << " AST statements for '" << rule.name << "'\n";

            // DEPRECATED: Also build the string representation for backward compatibility
            body_stmts: std::string = "";
            for body.get_statements() do (stmt) {
                stmt_str: std::string = stmt.to_string() as std::string;

                // BUG FIX: Trim trailing whitespace before checking last character
                trimmed: std::string = stmt_str;
                while !trimmed.empty() && std::isspace(trimmed.back() as int) != 0 {
                    trimmed.pop_back();
                }

                // Add semicolon if not present (statement may or may not have it)
                if !trimmed.empty() && trimmed.back() != ';' && trimmed.back() != '}' {
                    body_stmts += trimmed + ";\n";
                } else if !trimmed.empty() {
                    body_stmts += trimmed + "\n";
                }
            }
            _ = body_stmts; // TODO: Remove after IR-based rule inlining is complete
        }
    }

    return rule;
}

/**
 * @brief Discover ad_rule types inside an annotated type.
 *
 * Scans all nested types and checks if they conform to the ad_rule pattern.
 * Matching rules are registered in the output registry.
 *
 * @param t Type declaration to scan.
 * @param out Registry to populate.
 */
discover_ad_rules: (t: meta::type_declaration, inout out: ad_rule_registry) = {
    std::cout << "AD: Discovering rules in type " << t.name() << "\n";

    // 1. Nested types inside the @autodiff type (highest priority)
    for t.get_member_types() do (inout member_type) {
        type_name: std::string_view = member_type.name();
        std::cout << "AD: Checking nested type: " << type_name << "\n";

        if is_ad_rule_type(member_type) {
            rule: ad_rule_meta = extract_ad_rule_meta(member_type&);
            std::cout << "AD: Found nested rule: " << rule.name << " (n_args=" << rule.n_args << ")\n";
            out.register_rule(rule);
        }
    }

    // 2. Sibling types in the parent namespace (same file only)
    //    NOTE: Rules from included .h2 files are now discovered via path 3 below.
    if t.parent_is_nonglobal_namespace() {
        ns := t.get_parent().as_nonglobal_namespace();
        std::cout << "AD: Checking siblings in namespace '" << ns.name() << "'\n";

        // DEBUG: List ALL members returned by get_members()
        members := ns.get_members();
        std::cout << "AD DEBUG: ns.get_members() returned " << members.size() << " members:\n";
        for members do (m) {
            std::cout << "AD DEBUG:   - '" << m.name() << "' is_type=" << m.is_type()
                      << " is_func=" << m.is_function() << " is_ns=" << m.is_namespace() << "\n";
        }

        for members do (m) {
            if m.is_type() && !m.is_same(t) {
                type_name: std::string = m.name() as std::string;
                if type_name.starts_with("ad_rule_") {
                    sibling_type: meta::type_declaration = m.as_type();
                    if is_ad_rule_type(sibling_type) {
                        rule: ad_rule_meta = extract_ad_rule_meta(sibling_type&);
                        std::cout << "AD: Found sibling rule: " << rule.name << " (n_args=" << rule.n_args << ")\n";
                        out.register_rule(rule);
                    }
                }
            }
        }
    }

    // 3. Types in meta::ad namespace from included .h2 headers
    //    Uses get_tu_declarations() to find TU-level "meta" namespace,
    //    then navigates to "ad" sub-namespace.
    for t.get_tu_declarations() do (tu_decl) {
        if tu_decl.is_namespace() && tu_decl.name() == "meta" {
            meta_ns := tu_decl.as_nonglobal_namespace();

            for meta_ns.get_members() do (meta_member) {
                if meta_member.is_namespace() && meta_member.name() == "ad" {
                    ad_ns := meta_member.as_nonglobal_namespace();

                    for ad_ns.get_members() do (rule_decl) {
                        if rule_decl.is_type() {
                            rule_type := rule_decl.as_type();
                            type_name: std::string = rule_type.name() as std::string;
                            std::cout << "AD: Checking meta::ad type: " << type_name << "\n";

                            if is_ad_rule_type(rule_type) {
                                // Skip if already registered (built-in rules live in
                                // meta::ad in reverse_ad.h2 and may already be found
                                // via path 2 if the type is in the same namespace)
                                rule: ad_rule_meta = extract_ad_rule_meta(rule_type&);
                                if !out.has_rule(rule.name, rule.n_args, rule.is_member) {
                                    std::cout << "AD: Found included rule: " << rule.name
                                              << " (n_args=" << rule.n_args << ")\n";
                                    out.register_rule(rule);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------
//
//  Subtask 3b: Rule body extraction and inlining
//
//-----------------------------------------------------------------------

/**
 * @brief Result of extracting a rule's reverse() body.
 */
ad_rule_body_result: type = {
    public ok       : bool = false;
    public body_str : std::string = "";

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (ok_: bool, body_: std::string) -> ad_rule_body_result = {
        r: ad_rule_body_result = ();
        r.ok = ok_;
        r.body_str = body_;
        return r;
    }
}

//-----------------------------------------------------------------------
//
//  AST-to-IR parsing for rule bodies
//
//-----------------------------------------------------------------------

/**
 * @brief Result of parsing an AST expression to IR.
 */
ad_parse_expr_result: type = {
    public ok   : bool = false;
    public expr : ad_expr = ();

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (ok_: bool, expr_: ad_expr) -> ad_parse_expr_result = {
        r: ad_parse_expr_result = ();
        r.ok = ok_;
        r.expr = expr_;
        return r;
    }

    make_fail: () -> ad_parse_expr_result = {
        r: ad_parse_expr_result = ();
        r.ok = false;
        return r;
    }
}

/**
 * @brief Result of parsing an AST statement to IR.
 */
ad_parse_stmt_result: type = {
    public ok   : bool = false;
    public stmt : ad_stmt = ();

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (ok_: bool, stmt_: ad_stmt) -> ad_parse_stmt_result = {
        r: ad_parse_stmt_result = ();
        r.ok = ok_;
        r.stmt = stmt_;
        return r;
    }

    make_fail: () -> ad_parse_stmt_result = {
        r: ad_parse_stmt_result = ();
        r.ok = false;
        return r;
    }
}

/**
 * @brief Parse an AST expression into IR with parameter substitution.
 *
 * This function converts a meta::expression AST node into an ad_expr IR node,
 * applying substitutions from the context during parsing. This is used to
 * parse rule bodies like "x_adj += std::cos(x_val) * res_adj" into IR.
 *
 * @param expr The AST expression to parse.
 * @param ctx Substitution context mapping parameter names to IR expressions.
 * @return Result with ok=true and parsed expression if successful.
 */

/**
 * @brief Map operator string to ad_op_kind.
 */
map_op_string: (op: std::string) -> ad_op_kind = {
    if op == "+" { return ad_op_kind::add; }
    if op == "-" { return ad_op_kind::sub; }
    if op == "*" { return ad_op_kind::mul; }
    if op == "/" { return ad_op_kind::div; }
    if op == "%" { return ad_op_kind::mod; }
    if op == "==" { return ad_op_kind::eq; }
    if op == "!=" { return ad_op_kind::ne; }
    if op == "<" { return ad_op_kind::lt; }
    if op == ">" { return ad_op_kind::gt; }
    if op == "<=" { return ad_op_kind::le; }
    if op == ">=" { return ad_op_kind::ge; }
    if op == "&&" { return ad_op_kind::land; }
    if op == "||" { return ad_op_kind::lor; }
    if op == "&" { return ad_op_kind::band; }
    if op == "|" { return ad_op_kind::bor; }
    if op == "^" { return ad_op_kind::bxor; }
    if op == "<<" { return ad_op_kind::shl; }
    if op == ">>" { return ad_op_kind::shr; }
    return ad_op_kind::add; // Default
}

// Assignment expression: = += -= etc.
parse_assignment_expr: (expr: meta::assignment_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() {
        return ad_parse_expr_result::make_fail();
    }
    // If only one term, no assignment - drill down
    if terms.ssize() == 1 {
        return parse_logical_or_expr(terms.front().get_term(), ctx);
    }
    // Actual assignment - for now just parse the RHS
    // (assignments in rule bodies are handled at statement level)
    return parse_logical_or_expr(terms.back().get_term(), ctx);
}

// Logical OR: ||
parse_logical_or_expr: (expr: meta::logical_or_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_logical_and_expr(terms.front().get_term(), ctx);
    }
    // LHS is first term (with empty operator)
    lhs_result: ad_parse_expr_result = parse_logical_and_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    // Process remaining terms (which have actual operators)
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_logical_and_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::lor, result, rhs_result.expr, "bool");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Logical AND: &&
parse_logical_and_expr: (expr: meta::logical_and_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_bit_or_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_bit_or_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_bit_or_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::land, result, rhs_result.expr, "bool");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Bit OR: |
parse_bit_or_expr: (expr: meta::bit_or_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_bit_xor_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_bit_xor_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_bit_xor_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::bor, result, rhs_result.expr, "int");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Bit XOR: ^
parse_bit_xor_expr: (expr: meta::bit_xor_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_bit_and_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_bit_and_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_bit_and_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::bxor, result, rhs_result.expr, "int");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Bit AND: &
parse_bit_and_expr: (expr: meta::bit_and_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_equality_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_equality_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_equality_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::band, result, rhs_result.expr, "int");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Equality: == !=
parse_equality_expr: (expr: meta::equality_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_relational_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_relational_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_relational_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        op_kind: ad_op_kind = map_op_string(terms[i].get_op());
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "bool");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Relational: < > <= >=
parse_relational_expr: (expr: meta::relational_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_compare_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_compare_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_compare_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        op_kind: ad_op_kind = map_op_string(terms[i].get_op());
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "bool");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Compare: <=>
parse_compare_expr: (expr: meta::compare_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_shift_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_shift_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_shift_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::spaceship, result, rhs_result.expr, "auto");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Shift: << >>
parse_shift_expr: (expr: meta::shift_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_additive_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_additive_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_additive_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        op_kind: ad_op_kind = map_op_string(terms[i].get_op());
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "int");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Additive: + -
parse_additive_expr: (expr: meta::additive_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_multiplicative_expr(terms.front().get_term(), ctx);
    }
    lhs_result: ad_parse_expr_result = parse_multiplicative_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    i: i64 = 1;
    while i < terms.ssize() {
        rhs_result: ad_parse_expr_result = parse_multiplicative_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        op_kind: ad_op_kind = map_op_string(terms[i].get_op());
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "double");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Multiplicative: * / %
parse_multiplicative_expr: (expr: meta::multiplicative_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    std::cout << "AD: multiplicative terms.ssize() = " << terms.ssize() << "\n";
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        // No actual multiplication - drill down to is_as_expression -> prefix -> postfix
        // First term has empty operator, so we get the is_as_expression and drill down
        is_as := terms.front().get_term();
        pf_expr := is_as.get_expression();  // prefix_expression
        pf := pf_expr.get_postfix_expression();
        return parse_postfix_expr(pf, ctx);
    }
    // Actual multiplication/division
    // Get the LHS via the first term (which has empty operator)
    lhs_is_as := terms.front().get_term();
    lhs_pf_expr := lhs_is_as.get_expression();
    lhs_pf := lhs_pf_expr.get_postfix_expression();
    lhs_result: ad_parse_expr_result = parse_postfix_expr(lhs_pf, ctx);
    if !lhs_result.ok { return lhs_result; }
    result: ad_expr = lhs_result.expr;
    // Process remaining terms (which have actual operators)
    i: i64 = 1;
    while i < terms.ssize() {
        term := terms[i];
        rhs_is_as := term.get_term();
        rhs_pf_expr := rhs_is_as.get_expression();
        rhs_pf := rhs_pf_expr.get_postfix_expression();
        rhs_result: ad_parse_expr_result = parse_postfix_expr(rhs_pf, ctx);
        if !rhs_result.ok { return rhs_result; }
        op_str := term.get_op();
        std::cout << "AD: multiplicative op = '" << op_str << "'\n";
        op_kind: ad_op_kind = map_op_string(op_str);
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "double");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Prefix expression: - ! etc.
parse_prefix_expr: (expr: meta::prefix_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    ops: std::vector<std::string> = expr.get_ops();
    pf: meta::postfix_expression = expr.get_postfix_expression();
    inner_result: ad_parse_expr_result = parse_postfix_expr(pf, ctx);
    if !inner_result.ok { return inner_result; }

    // Apply prefix operators from right to left
    result: ad_expr = inner_result.expr;
    i: i64 = ops.ssize() - 1;
    while i >= 0 {
        op_str: std::string = ops[i];
        if op_str == "-" {
            result = ad_expr::make_unary(ad_op_kind::neg, result, "double");
        } else if op_str == "!" {
            result = ad_expr::make_unary(ad_op_kind::lnot, result, "bool");
        } else if op_str == "~" {
            result = ad_expr::make_unary(ad_op_kind::bnot, result, "int");
        } else if op_str == "*" {
            result = ad_expr::make_unary(ad_op_kind::deref, result, "double");
        } else if op_str == "&" {
            result = ad_expr::make_unary(ad_op_kind::addr_of, result, "double*");
        }
        i--;
    }
    return ad_parse_expr_result::make(true, result);
}

// Postfix expression: identifiers, literals, function calls, member access
parse_postfix_expr: (expr: meta::postfix_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    std::cout << "AD: parse_postfix_expr: '" << expr.to_string() << "'\n";

    // Check if it's a simple identifier
    if expr.is_identifier() {
        id_name: std::string = expr.as_identifier();
        substituted: ad_expr = ();
        if ctx.find(id_name, substituted) {
            return ad_parse_expr_result::make(true, substituted);
        }
        return ad_parse_expr_result::make(true, ad_expr::make_identifier(id_name, "double"));
    }

    // Check if it's a literal
    if expr.is_literal() {
        return ad_parse_expr_result::make(true, ad_expr::make_literal(expr.as_literal(), "double"));
    }

    // For function calls and other postfix operations, use the string representation for now
    // TODO: Properly handle function calls via get_terms()
    expr_str: std::string = expr.to_string() as std::string;
    return ad_parse_expr_result::make(true, ad_expr::make_identifier(expr_str, "double"));
}

/**
 * @brief Parse an expression from meta::expression into IR.
 * Entry point - dispatches to assignment_expression parsing.
 */
parse_rule_expr: (expr: meta::expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    std::cout << "AD: parse_rule_expr: '" << expr.to_string() << "'\n";

    // Check for simple cases first
    if expr.is_identifier() {
        id_name: std::string = expr.to_string() as std::string;
        substituted: ad_expr = ();
        if ctx.find(id_name, substituted) {
            return ad_parse_expr_result::make(true, substituted);
        }
        return ad_parse_expr_result::make(true, ad_expr::make_identifier(id_name, "double"));
    }

    if expr.is_literal() {
        return ad_parse_expr_result::make(true, ad_expr::make_literal(expr.to_string(), "double"));
    }

    // Traverse the expression hierarchy starting with assignment_expression
    if expr.is_assignment_expression() {
        return parse_assignment_expr(expr.as_assignment_expression(), ctx);
    }

    std::cout << "AD: Failed to parse expression: '" << expr.to_string() << "'\n";
    return ad_parse_expr_result::make_fail();
}

/**
 * @brief Parse an AST statement into IR with parameter substitution.
 *
 * This function converts a meta::statement AST node into an ad_stmt IR node,
 * applying substitutions from the context during parsing.
 *
 * Handles:
 * - Expression statements (e.g., "x_adj += cos(x_val) * res_adj;")
 * - Compound statements (blocks)
 * - If statements
 *
 * @param stmt The AST statement to parse.
 * @param ctx Substitution context mapping parameter names to IR expressions.
 * @return Result with ok=true and parsed statement if successful.
 */
parse_rule_stmt: (stmt: meta::statement, ctx: ad_substitution_context) -> ad_parse_stmt_result = {
    stmt_str: std::string = string_util::trim_copy(stmt.to_string());

    std::cout << "AD: parse_rule_stmt: '" << stmt_str << "'\n";

    // Check for compound statement
    if stmt.is_compound_statement() {
        compound: meta::compound_statement = stmt.as_compound_statement();
        nested_stmts: std::vector<ad_stmt> = ();
        for compound.get_statements() do (s) {
            nested_result: ad_parse_stmt_result = parse_rule_stmt(s, ctx);
            if !nested_result.ok {
                std::cout << "AD: Failed to parse nested statement in compound\n";
                return ad_parse_stmt_result::make_fail();
            }
            nested_stmts.push_back(nested_result.stmt);
        }
        return ad_parse_stmt_result::make(true, ad_stmt::make_compound(nested_stmts));
    }

    // Check for selection (if) statement
    if stmt.is_selection_statement() {
        sel: meta::selection_statement = stmt.as_selection_statement();
        // Parse condition - need to convert logical_or_expression to expression
        // For now, use the string representation
        cond_str: std::string = sel.get_expression().to_string() as std::string;
        std::cout << "AD: If condition string: '" << cond_str << "'\n";

        // Create a simple condition expression (for now just use the string)
        cond_expr: ad_expr = ad_expr::make_identifier(cond_str, "bool");

        // Parse then branch
        then_compound: meta::compound_statement = sel.get_true_branch();
        then_stmts: std::vector<ad_stmt> = ();
        for then_compound.get_statements() do (s) {
            then_result: ad_parse_stmt_result = parse_rule_stmt(s, ctx);
            if !then_result.ok {
                std::cout << "AD: Failed to parse if then-branch\n";
                return ad_parse_stmt_result::make_fail();
            }
            then_stmts.push_back(then_result.stmt);
        }

        // Parse else branch if present
        else_stmts: std::vector<ad_stmt> = ();
        if sel.has_false_branch() {
            else_compound: meta::compound_statement = sel.get_false_branch();
            for else_compound.get_statements() do (s) {
                else_result: ad_parse_stmt_result = parse_rule_stmt(s, ctx);
                if else_result.ok {
                    else_stmts.push_back(else_result.stmt);
                }
            }
        }

        return ad_parse_stmt_result::make(true,
            ad_stmt::make_if(cond_expr, then_stmts, else_stmts));
    }

    // Check for expression statement - this is the common case for AD rules
    // Statements like "x_adj += cos(x_val) * res_adj;"
    if stmt.is_expression_statement() {
        expr_stmt := stmt.as_expression_statement();
        expr := expr_stmt.get_expression();

        std::cout << "AD: Expression statement: '" << expr.to_string() << "'\n";

        // Use structural analysis via meta type methods
        // Assignment expressions have terms: [LHS (empty op), RHS (with operator)]
        if expr.is_assignment_expression() {
            assign_expr := expr.as_assignment_expression();
            terms := assign_expr.get_terms();
            std::cout << "AD DEBUG: assignment_expression has " << terms.ssize() << " terms\n";

            if terms.ssize() >= 2 {
                // Extract LHS target structurally
                lhs_term := terms[0].get_term();
                target_str: std::string = string_util::trim_copy(lhs_term.to_string() as std::string);

                // Get the operator structurally
                op_str := terms[1].get_op();
                std::cout << "AD DEBUG: operator is '" << op_str << "'\n";

                // Substitute the target if needed
                new_target: std::string = target_str;
                target_expr: ad_expr = ();
                if ctx.find(target_str, target_expr) && target_expr.kind == ad_expr_kind::identifier {
                    new_target = target_expr.name;
                }

                // Get the RHS term structurally
                rhs_term := terms[1].get_term();
                std::cout << "AD DEBUG: RHS term is '" << rhs_term.to_string() << "'\n";

                // Handle compound assignments (+=, -=, *=, /=)
                if op_str == "+=" {
                    rhs_result: ad_parse_expr_result = parse_logical_or_expr(rhs_term, ctx);
                    if rhs_result.ok {
                        return ad_parse_stmt_result::make(true,
                            ad_stmt::make_assign_add(new_target, rhs_result.expr));
                    }
                    std::cout << "AD DEBUG: Failed to parse += RHS expression\n";
                }
                else if op_str == "-=" {
                    rhs_result: ad_parse_expr_result = parse_logical_or_expr(rhs_term, ctx);
                    if rhs_result.ok {
                        return ad_parse_stmt_result::make(true,
                            ad_stmt::make_compound_assign(new_target, ad_op_kind::assign_sub, rhs_result.expr));
                    }
                }
                else if op_str == "*=" {
                    rhs_result: ad_parse_expr_result = parse_logical_or_expr(rhs_term, ctx);
                    if rhs_result.ok {
                        return ad_parse_stmt_result::make(true,
                            ad_stmt::make_compound_assign(new_target, ad_op_kind::assign_mul, rhs_result.expr));
                    }
                }
                else if op_str == "/=" {
                    rhs_result: ad_parse_expr_result = parse_logical_or_expr(rhs_term, ctx);
                    if rhs_result.ok {
                        return ad_parse_stmt_result::make(true,
                            ad_stmt::make_compound_assign(new_target, ad_op_kind::assign_div, rhs_result.expr));
                    }
                }
                else if op_str == "=" {
                    // Simple assignment
                    rhs_result: ad_parse_expr_result = parse_logical_or_expr(rhs_term, ctx);
                    if rhs_result.ok {
                        return ad_parse_stmt_result::make(true,
                            ad_stmt::make_assign(new_target, rhs_result.expr));
                    }
                }
                else {
                    std::cout << "AD: Unknown assignment operator: '" << op_str << "'\n";
                }
            }

            // Assignment expression parsing failed
            std::cout << "AD: ERROR - Could not parse assignment expression structurally\n";
            return ad_parse_stmt_result::make_fail();
        }

        // General expression statement - just wrap the parsed expression
        expr_result: ad_parse_expr_result = parse_rule_expr(expr, ctx);
        if expr_result.ok {
            return ad_parse_stmt_result::make(true, ad_stmt::make_expr(expr_result.expr));
        }
    }

    std::cout << "AD: Failed to parse statement: '" << stmt_str << "'\n";
    return ad_parse_stmt_result::make_fail();
}

/**
 * @brief Parse all AST statements from a rule body into IR.
 *
 * This is the main entry point for converting a rule's reverse() body
 * from AST to IR with parameter substitution applied.
 *
 * @param stmts Vector of AST statements from the rule body.
 * @param ctx Substitution context mapping parameter names to IR expressions.
 * @param out Output vector for the parsed IR statements.
 * @return true if all statements were successfully parsed.
 */
parse_rule_body_stmts: (stmts: std::vector<meta::statement>, ctx: ad_substitution_context,
                        inout out: std::vector<ad_stmt>) -> bool = {
    std::cout << "AD DEBUG: parse_rule_body_stmts called with " << stmts.ssize() << " statements\n";
    for stmts do (stmt) {
        std::cout << "AD DEBUG: About to call parse_rule_stmt\n";
        result: ad_parse_stmt_result = parse_rule_stmt(stmt, ctx);
        std::cout << "AD DEBUG: parse_rule_stmt returned ok=" << result.ok << "\n";
        if !result.ok {
            return false;
        }
        out.push_back(result.stmt);
    }
    return true;
}

/**
 * @brief Standard parameter names used in ad_rule reverse() functions.
 *
 * These are the expected parameter names that will be substituted:
 * - res_val: result value from forward pass
 * - res_adj: incoming adjoint (to propagate)
 * - x_val, y_val, z_val, w_val: argument values
 * - x_adj, y_adj, z_adj, w_adj: argument adjoints (inout)
 */
ad_rule_param_names: type = {
    result_val: std::string = "res_val";
    result_adj: std::string = "res_adj";
    arg_vals: std::array<std::string, 4> = ("x_val", "y_val", "z_val", "w_val");
    arg_adjs: std::array<std::string, 4> = ("x_adj", "y_adj", "z_adj", "w_adj");
}

/**
 * @brief Check if a character is an identifier character (alphanumeric or underscore).
 */
is_identifier_char: (c: char) -> bool = {
    return std::isalnum(c as int) != 0 || c == '_';
}

/**
 * @brief Replace all whole-word occurrences of a pattern in a string.
 *
 * Only replaces when the pattern is not part of a larger identifier.
 * For example, replacing "x_val" won't affect "extra_x_val" or "x_value".
 *
 * @param str The input string.
 * @param pattern The pattern to find (must be a whole word/identifier).
 * @param replacement The replacement string.
 * @return String with all whole-word occurrences replaced.
 */
replace_word: (str: std::string, pattern: std::string, replacement: std::string) -> std::string = {
    if pattern.empty() {
        return str;
    }

    result: std::string = "";
    pos: size_t = 0;
    pattern_len: size_t = pattern.size();

    while pos < str.size() {
        found: size_t = str.find(pattern, pos);
        if found == std::string::npos {
            // No more matches, append rest of string
            result += str.substr(pos);
            break;
        }

        // Check word boundaries
        is_word_start: bool = (found == 0) || !is_identifier_char(str[found - 1]);
        is_word_end: bool = (found + pattern_len >= str.size()) || !is_identifier_char(str[found + pattern_len]);

        if is_word_start && is_word_end {
            // It's a whole word match - do the replacement
            result += str.substr(pos, found - pos);
            result += replacement;
            pos = found + pattern_len;
        } else {
            // Not a whole word - copy including the first char and continue
            result += str.substr(pos, found - pos + 1);
            pos = found + 1;
        }
    }

    return result;
}

/**
 * @brief Substitute rule parameter names with actual values in body string.
 *
 * Performs textual substitution to replace:
 * - res_val -> target value name (e.g., "_t0_val")
 * - res_adj -> target adjoint name (e.g., "_t0_adj")
 * - x_val -> first argument value name
 * - x_adj -> first argument adjoint name
 * etc.
 *
 * Uses word-boundary-aware replacement to avoid corrupting identifiers like
 * "extra_res_val" or "x_value".
 *
 * @param body_str Original body string from rule.
 * @param target_val Name of the target variable's value.
 * @param target_adj Name of the target variable's adjoint.
 * @param arg_vals Vector of argument value names.
 * @param arg_adjs Vector of argument adjoint names.
 * @return Body string with substitutions applied.
 */
substitute_rule_params: (body_str: std::string,
                         target_val: std::string, target_adj: std::string,
                         arg_vals: std::vector<std::string>,
                         arg_adjs: std::vector<std::string>) -> std::string = {
    result: std::string = body_str;

    // Substitute result value and adjoint using word-boundary-aware replacement
    result = replace_word(result, "res_val", target_val);
    result = replace_word(result, "res_adj", target_adj);

    // Substitute argument values and adjoints
    // BUG FIX: Check both arg_vals and arg_adjs sizes
    param_names: std::array<std::string, 4> = ("x", "y", "z", "w");
    i: i64 = 0;
    while i < param_names.ssize() && i < arg_vals.ssize() && i < arg_adjs.ssize() {
        val_param: std::string = param_names[i] + "_val";
        adj_param: std::string = param_names[i] + "_adj";

        // Always substitute value params
        result = replace_word(result, val_param, arg_vals[i]);

        // BUG FIX: Only substitute adjoint if it's not empty
        // Empty adjoints occur when argument is not an identifier (e.g., literal)
        if !arg_adjs[i].empty() {
            result = replace_word(result, adj_param, arg_adjs[i]);
        } else {
            // Check if the rule body references this adjoint - if so, it's an error
            if result.find(adj_param) != std::string::npos {
                std::cout << "AD: WARNING - rule body references '" << adj_param
                          << "' but argument is not a variable (cannot accumulate adjoint)\n";
                // Replace with an error marker to make the issue visible
                result = replace_word(result, adj_param, "/*ERROR:no_adj_for_" + param_names[i] + "*/0.0");
            }
        }
        i++;
    }

    std::cout << "AD: Substituted body: " << result << "\n";
    return result;
}

//-----------------------------------------------------------------------
//
//  Subtask 4: Operator token mapping for + - * /
//
//-----------------------------------------------------------------------

/**
 * @brief Result of mapping an operator or function name to ad_op_kind.
 */
ad_op_mapping_result: type = {
    public ok   : bool = false;
    public kind : ad_op_kind = ad_op_kind::add;

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (ok_: bool, kind_: ad_op_kind) -> ad_op_mapping_result = {
        r: ad_op_mapping_result = ();
        r.ok = ok_;
        r.kind = kind_;
        return r;
    }
}

/**
 * @brief Map an operator token string to ad_op_kind.
 *
 * Handles the basic arithmetic operators used in additive and multiplicative
 * expressions.
 *
 * @param op Operator token string ("+", "-", "*", "/").
 * @return Result with ok=true and kind set if recognized.
 */
map_operator_token: (op: std::string_view) -> ad_op_mapping_result = {
    if op == "+" {
        return ad_op_mapping_result::make(true, ad_op_kind::add);
    }
    if op == "-" {
        return ad_op_mapping_result::make(true, ad_op_kind::sub);
    }
    if op == "*" {
        return ad_op_mapping_result::make(true, ad_op_kind::mul);
    }
    if op == "/" {
        return ad_op_mapping_result::make(true, ad_op_kind::div);
    }
    return ad_op_mapping_result::make(false, ad_op_kind::add);
}

/**
 * @brief Map a function name to ad_op_kind.
 *
 * All function calls use ad_op_kind::call - actual differentiation
 * rules are looked up by function name in the ad_rule_registry.
 *
 * @param name Function name.
 * @return Result with ad_op_kind::call.
 */
map_function_to_op: (name: std::string_view) -> ad_op_mapping_result = {
    // All functions use ad_op_kind::call - differentiation is handled by
    // looking up ad_rule_* definitions in the rule registry by name
    return ad_op_mapping_result::make(true, ad_op_kind::call);
}

/**
 * @brief Debug: print operator mapping result.
 * @param op Operator string.
 * @param ok Whether the operator was recognized.
 * @param kind The mapped kind.
 */
debug_operator_mapping: (op: std::string_view, ok: bool, kind: ad_op_kind) = {
    std::cout << "AD: map_operator_token(\"" << op << "\") -> ";
    if ok {
        std::cout << "ok, " << ad_op_kind_to_string(kind) << "\n";
    } else {
        std::cout << "not recognized\n";
    }
}

//-----------------------------------------------------------------------
//
//  Subtask 5: Base expression builder
//
//-----------------------------------------------------------------------

/**
 * @brief IR builder context for constructing AD IR from reflection AST.
 *
 * The builder walks the reflection AST and constructs typed AD IR nodes.
 * It maintains context for naming temporaries and tracking active variables.
 */
ad_ir_builder: type = {
    public ctx        : *reverse_autodiff_context;
    public registry   : *ad_rule_registry;
    public temp_counter: int = 0;
    public temp_names : std::vector<std::string> = ();

    /// Default constructor
    operator=: (out this) = {
        ctx = nullptr;
        registry = nullptr;
    }

    /// Initialize with context and registry
    operator=: (out this, ctx_: *reverse_autodiff_context, registry_: *ad_rule_registry) = {
        ctx = ctx_;
        registry = registry_;
    }

    /**
     * @brief Report an error during IR building and fail immediately.
     * @param msg Error message.
     * @param loc Location string (optional).
     * @param context Additional context (optional).
     */
    report_error: (inout this, msg: std::string, loc: std::string = "", context: std::string = "") = {
        std::cerr << "AD IR Builder Error: " << msg;
        if !loc.empty() { std::cerr << " at " << loc; }
        if !context.empty() { std::cerr << " (" << context << ")"; }
        std::cerr << "\n";
        assert(false && "AD IR Builder encountered a fatal error");
    }

    /**
     * @brief Generate a unique temporary name.
     * @param base Base name for the temporary.
     * @return Unique temporary name.
     */
    gen_temp_name: (inout this, base: std::string) -> std::string = {
        name: std::string = "(base)$_t(temp_counter)$";
        temp_counter++;
        temp_names.push_back(name);
        return name;
    }

    /**
     * @brief Emit an expression as a Cpp2 string.
     *
     * Full expression-to-string conversion supporting all expression kinds.
     *
     * @param expr Expression to emit.
     * @return Cpp2 source string.
     */
    emit_expr: (this, expr: ad_expr) -> std::string = {
        if expr.kind == ad_expr_kind::literal {
            return expr.name;
        }
        else if expr.kind == ad_expr_kind::identifier {
            return expr.name;
        }
        else if expr.kind == ad_expr_kind::unary {
            if !expr.args.empty() {
                operand: std::string = emit_expr(expr.args[0]);
                // Handle different unary operators
                if expr.op == ad_op_kind::neg { return "(-" + operand + ")"; }
                if expr.op == ad_op_kind::pos { return "(+" + operand + ")"; }
                if expr.op == ad_op_kind::lnot { return "(!" + operand + ")"; }
                if expr.op == ad_op_kind::bnot { return "(~" + operand + ")"; }
                if expr.op == ad_op_kind::deref { return "(*" + operand + ")"; }
                if expr.op == ad_op_kind::addr_of { return "(&" + operand + ")"; }
                if expr.op == ad_op_kind::pre_inc { return "(++" + operand + ")"; }
                if expr.op == ad_op_kind::pre_dec { return "(--" + operand + ")"; }
                if expr.op == ad_op_kind::post_inc { return "(" + operand + "++)"; }
                if expr.op == ad_op_kind::post_dec { return "(" + operand + "--)"; }
            }
            return "(unary " + ad_op_kind_to_string(expr.op) + ")";
        }
        else if expr.kind == ad_expr_kind::binary {
            if expr.args.ssize() >= 2 {
                lhs: std::string = emit_expr(expr.args[0]);
                rhs: std::string = emit_expr(expr.args[1]);
                op_str: std::string = ad_op_kind_to_binary_str(expr.op);
                if op_str.empty() { op_str = " ?? "; }
                return "(" + lhs + op_str + rhs + ")";
            }
            return "(binary)";
        }
        else if expr.kind == ad_expr_kind::ternary {
            if expr.args.ssize() >= 3 {
                cond: std::string = emit_expr(expr.args[0]);
                then_expr: std::string = emit_expr(expr.args[1]);
                else_expr: std::string = emit_expr(expr.args[2]);
                return "(" + cond + " ? " + then_expr + " : " + else_expr + ")";
            }
            return "(ternary)";
        }
        else if expr.kind == ad_expr_kind::member {
            if !expr.args.empty() {
                obj: std::string = emit_expr(expr.args[0]);
                op_str: std::string = "->";
                if expr.op != ad_op_kind::arrow { op_str = "."; }
                return obj + op_str + expr.member_name;
            }
            return "(member)";
        }
        else if expr.kind == ad_expr_kind::subscript {
            if expr.args.ssize() >= 2 {
                arr: std::string = emit_expr(expr.args[0]);
                idx: std::string = emit_expr(expr.args[1]);
                return arr + "[" + idx + "]";
            }
            return "(subscript)";
        }
        else if expr.kind == ad_expr_kind::call {
            result: std::string = expr.name;
            // Add template args if present
            if !expr.type_args.empty() {
                result += "<";
                (copy first: bool = true)
                for expr.type_args do (targ) {
                    if !first { result += ", "; }
                    first = false;
                    result += ad_type_to_string(targ);
                }
                result += ">";
            }
            result += "(";
            (copy first: bool = true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += ")";
            return result;
        }
        else if expr.kind == ad_expr_kind::method_call {
            if !expr.args.empty() {
                obj: std::string = emit_expr(expr.args[0]);
                result: std::string = obj + "." + expr.name + "(";
                // Skip first arg (the object), emit remaining args
                if expr.args.ssize() > 1 {
                    result += emit_expr(expr.args[1]);
                    i: i64 = 2;
                    while i < expr.args.ssize() {
                        result += ", ";
                        result += emit_expr(expr.args[i]);
                        i++;
                    }
                }
                result += ")";
                return result;
            }
            return "(method_call)";
        }
        else if expr.kind == ad_expr_kind::cast {
            if !expr.args.empty() {
                target_type: std::string = "";
                if expr.cast_type != nullptr {
                    target_type = ad_type_to_string(expr.cast_type*);
                } else {
                    target_type = expr.type_name;
                }
                inner: std::string = emit_expr(expr.args[0]);
                // C++ style cast
                if expr.name != "" {
                    return expr.name + "<" + target_type + ">(" + inner + ")";
                }
                // C-style cast
                return "(" + target_type + ")" + inner;
            }
            return "(cast)";
        }
        else if expr.kind == ad_expr_kind::construct {
            result: std::string = expr.name + "(";
            (copy first: bool = true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += ")";
            return result;
        }
        else if expr.kind == ad_expr_kind::paren {
            if !expr.args.empty() {
                return "(" + emit_expr(expr.args[0]) + ")";
            }
            return "()";
        }
        else if expr.kind == ad_expr_kind::initializer_list {
            result: std::string = "{";
            (copy first: bool = true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += "}";
            return result;
        }
        return "(??)";
    }

    /**
     * @brief Derive a readable operation name from op and args.
     *
     * Creates names like "mul_x_y", "sin_x", "add_z_w" for debugging.
     *
     * @param op Operation kind.
     * @param args Argument expressions.
     * @return Derived name.
     */
    derive_op_name: (this, op: ad_op_kind, args: std::vector<ad_expr>) -> std::string = {
        result := ad_op_kind_to_string(op);
        for args do (arg) {
            if arg.kind == ad_expr_kind::identifier || arg.kind == ad_expr_kind::literal {
                result += "_" + arg.name;
            }
        }
        return result;
    }

    /**
     * @brief Build IR from a primary expression.
     *
     * Handles identifiers, literals, and parenthesized expressions.
     *
     * @param primary Primary expression from reflection AST.
     * @return IR expression node.
     */
    build_primary_expr: (inout this, primary: meta::primary_expression) -> ad_expr = {
        if primary.is_identifier() {
            name := primary.as_identifier();
            std::cout << "AD IR Builder: primary identifier '" << name << "'\n";
            return ad_expr::make_identifier(name as std::string, "double");
        }
        else if primary.is_literal() {
            value := primary.as_literal();
            std::cout << "AD IR Builder: primary literal '" << value << "'\n";
            return ad_expr::make_literal(value as std::string, "double");
        }
        else if primary.is_expression_list() {
            // Parenthesized expression - recursively parse
            std::cout << "AD IR Builder: primary expression_list (parenthesized)\n";
            expr_list := primary.as_expression_list();
            exprs := expr_list.get_expressions();
            if exprs.ssize() == 1 {
                // Single expression in parentheses - unwrap it
                return build_expression(exprs[0]);
            }
            // Multiple expressions - error
            report_error(
                "Unsupported: multiple expressions in parentheses",
                primary.to_string() as std::string,
                "Expected a single expression"
            );
            return ad_expr::make_literal("__ERROR__", "error");
        }
        else {
            // Unknown primary expression type - hard fail
            str := primary.to_string();
            report_error(
                "Unknown primary expression type",
                str as std::string,
                "Could not parse primary expression into AD IR"
            );
            return ad_expr::make_literal("__ERROR__", "error");
        }
    }

    /**
     * @brief Build IR from a postfix expression.
     *
     * Handles function calls, member access, and subscript operations.
     *
     * @param postfix Postfix expression from reflection AST.
     * @return IR expression node.
     */
    build_postfix_expr: (inout this, postfix: meta::postfix_expression) -> ad_expr = {
        terms := postfix.get_terms();

        // If no terms, just build the primary expression
        if terms.empty() {
            return build_primary_expr(postfix.get_primary_expression());
        }

        // Start with the primary expression
        result := build_primary_expr(postfix.get_primary_expression());

        // Process each postfix term
        for terms do (term) {
            op_str := term.get_op().to_string();
            std::cout << "AD IR Builder: postfix term op='" << op_str << "'\n";

            if term.is_expression_list() {
                // Function call: f(args)
                func_name := result.name;
                std::cout << "AD IR Builder: function call '" << func_name << "'\n";

                // Parse argument list
                call_args: std::vector<ad_expr> = ();
                expr_list := term.get_expression_list();
                for expr_list.get_expressions() do (arg_expr) {
                    arg_ir := build_expression(arg_expr);
                    call_args.push_back(arg_ir);
                    std::cout << "AD IR Builder:   arg: " << arg_ir.name << "\n";
                }

                fn_op := map_function_to_op(func_name);
                if fn_op.ok {
                    result = ad_expr::make_call(func_name, fn_op.kind, call_args, "double");
                } else {
                    result = ad_expr::make_call(func_name, ad_op_kind::call, call_args, "double");
                }
            }
            else if term.is_id_expression() {
                // Member access: obj.member
                field := term.get_id_expression().to_string();
                std::cout << "AD IR Builder: member access '." << field << "'\n";
                result = ad_expr::make_member(result, field as std::string, false, "double");
            }
        }

        return result;
    }

    /**
     * @brief Build IR from a prefix expression.
     *
     * Handles unary operators like -x and +x.
     *
     * @param prefix Prefix expression from reflection AST.
     * @return IR expression node.
     */
    build_prefix_expr: (inout this, prefix: meta::prefix_expression) -> ad_expr = {
        ops := prefix.get_ops();

        // If no ops, just build the postfix expression
        if ops.empty() {
            return build_postfix_expr(prefix.get_postfix_expression());
        }

        // Build the inner expression first
        inner := build_postfix_expr(prefix.get_postfix_expression());

        // Apply prefix operators from right to left (innermost first)
        result := inner;
        // Iterate in reverse order
        i := ops.ssize() - 1;
        while i >= 0 {
            op_str := ops[i].to_string();
            std::cout << "AD IR Builder: prefix op '" << op_str << "'\n";

            if op_str == "-" {
                result = ad_expr::make_unary(ad_op_kind::neg, result, result.type_name);
            }
            else if op_str == "+" {
                // Unary plus is a no-op
            }
            else {
                report_error(
                    "unsupported prefix operator: '" + (op_str as std::string) + "'",
                    prefix.to_string() as std::string,
                    "prefix expression"
                );
            }
            i--;
        }

        return result;
    }

    /**
     * @brief Build IR from an is-as expression.
     *
     * Handles type checks and casts, but for AD we typically just descend.
     *
     * @param isas Is-as expression from reflection AST.
     * @return IR expression node.
     */
    build_is_as_expr: (inout this, isas: meta::is_as_expression) -> ad_expr = {
        terms := isas.get_terms();

        // If no is/as terms, descend to prefix expression
        if terms.empty() {
            return build_prefix_expr(isas.get_expression());
        }

        // For now, just build the base expression (ignoring is/as)
        std::cout << "AD IR Builder: is-as expression (ignoring is/as terms)\n";
        return build_prefix_expr(isas.get_expression());
    }

    /**
     * @brief Build IR from a multiplicative expression.
     *
     * Handles x * y, x / y chains.
     *
     * @param binexpr Multiplicative expression from reflection AST.
     * @return IR expression node.
     */
    build_multiplicative_expr: (inout this, binexpr: meta::multiplicative_expression) -> ad_expr = {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        // If only one term, descend to is-as
        if terms.ssize() == 1 {
            return build_is_as_expr(terms.front().get_term());
        }

        // Build left-to-right chain of binary ops
        result := build_is_as_expr(terms.front().get_term());

        i := 1;
        while i < terms.ssize() {
            term := terms[i];
            op_str := term.get_op().to_string();
            rhs := build_is_as_expr(term.get_term());

            op_result := map_operator_token(op_str);
            debug_operator_mapping(op_str, op_result.ok, op_result.kind);

            if op_result.ok {
                result = ad_expr::make_binary(op_result.kind, result, rhs, "double");
            } else {
                report_error(
                    "unsupported multiplicative operator: '" + (op_str as std::string) + "'",
                    binexpr.to_string() as std::string,
                    "multiplicative expression"
                );
            }
            i++;
        }

        return result;
    }

    /**
     * @brief Build IR from an additive expression.
     *
     * Handles x + y, x - y chains.
     *
     * @param binexpr Additive expression from reflection AST.
     * @return IR expression node.
     */
    build_additive_expr: (inout this, binexpr: meta::additive_expression) -> ad_expr = {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        // If only one term, descend to multiplicative
        if terms.ssize() == 1 {
            return build_multiplicative_expr(terms.front().get_term());
        }

        // Build left-to-right chain of binary ops
        result := build_multiplicative_expr(terms.front().get_term());

        i := 1;
        while i < terms.ssize() {
            term := terms[i];
            op_str := term.get_op().to_string();
            rhs := build_multiplicative_expr(term.get_term());

            op_result := map_operator_token(op_str);
            debug_operator_mapping(op_str, op_result.ok, op_result.kind);

            if op_result.ok {
                result = ad_expr::make_binary(op_result.kind, result, rhs, "double");
            } else {
                report_error(
                    "unsupported additive operator: '" + (op_str as std::string) + "'",
                    binexpr.to_string() as std::string,
                    "additive expression"
                );
            }
            i++;
        }

        return result;
    }

    //-----------------------------------------------------------------------
    // Task 7: Call builder + rule application
    //-----------------------------------------------------------------------

    /**
     * @brief Parse call arguments from an expression list.
     * @param expr_list Expression list from function call.
     * @return Vector of IR expressions for each argument.
     */
    parse_call_args: (inout this, expr_list: meta::expression_list) -> std::vector<ad_expr> = {
        args: std::vector<ad_expr> = ();
        for expr_list.get_expressions() do (expr) {
            arg_ir := build_expression(expr);
            args.push_back(arg_ir);
        }
        return args;
    }

    /**
     * @brief Build IR from a general expression node.
     * @param expr Expression from reflection AST.
     * @return IR expression node.
     */
    build_expression: (inout this, expr: meta::expression) -> ad_expr = {
        // For now, use string representation and try to identify patterns
        str := expr.to_string();
        std::cout << "AD IR Builder: expression '" << str << "'\n";

        // Check for simple identifier
        if expr.is_identifier() {
            return ad_expr::make_identifier(str as std::string, "double");
        }
        // Check for literal
        if expr.is_literal() {
            return ad_expr::make_literal(str as std::string, "double");
        }

        // For complex expressions, parse from the assignment structure
        if expr.is_assignment_expression() {
            assign := expr.as_assignment_expression();
            return build_from_assignment(assign);
        }

        // Unknown expression type - hard fail
        report_error(
            "Unknown expression type",
            str as std::string,
            "Could not parse expression into AD IR. Expression is neither identifier, literal, nor assignment."
        );
        return ad_expr::make_literal("__ERROR__", "error");
    }

    /**
     * @brief Build IR from an assignment expression (top-level of most expressions).
     * @param assign Assignment expression from reflection AST.
     * @return IR expression node.
     */
    build_from_assignment: (inout this, assign: meta::assignment_expression) -> ad_expr = {
        terms := assign.get_terms();
        if terms.ssize() == 1 {
            // Single term - just descend
            return build_logical_or_expr(terms.front().get_term());
        }
        // Multiple terms means actual assignment - error for now
        report_error(
            "Unsupported: assignment expression with multiple terms",
            "",
            "AD IR builder does not support chained assignments"
        );
        return ad_expr::make_literal("__ERROR__", "error");
    }

    // Traverse down the binary expression chain to get to additive expression
    build_logical_or_expr: (inout this, expr: meta::logical_or_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_logical_and_expr(terms.front().get_term());
        }
        // TODO: handle || operators
        return build_logical_and_expr(terms.front().get_term());
    }

    build_logical_and_expr: (inout this, expr: meta::logical_and_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_bit_or_expr(terms.front().get_term());
        }
        // TODO: handle && operators
        return build_bit_or_expr(terms.front().get_term());
    }

    build_bit_or_expr: (inout this, expr: meta::bit_or_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_bit_xor_expr(terms.front().get_term());
        }
        // TODO: handle | operators
        return build_bit_xor_expr(terms.front().get_term());
    }

    build_bit_xor_expr: (inout this, expr: meta::bit_xor_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_bit_and_expr(terms.front().get_term());
        }
        // TODO: handle ^ operators
        return build_bit_and_expr(terms.front().get_term());
    }

    build_bit_and_expr: (inout this, expr: meta::bit_and_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_equality_expr(terms.front().get_term());
        }
        // TODO: handle & operators
        return build_equality_expr(terms.front().get_term());
    }

    build_equality_expr: (inout this, expr: meta::equality_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_relational_expr(terms.front().get_term());
        }
        // TODO: handle == != operators
        return build_relational_expr(terms.front().get_term());
    }

    build_relational_expr: (inout this, expr: meta::relational_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_compare_expr(terms.front().get_term());
        }
        // TODO: handle < > <= >= operators
        return build_compare_expr(terms.front().get_term());
    }

    build_compare_expr: (inout this, expr: meta::compare_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_shift_expr(terms.front().get_term());
        }
        // TODO: handle <=> operators
        return build_shift_expr(terms.front().get_term());
    }

    build_shift_expr: (inout this, expr: meta::shift_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_additive_expr(terms.front().get_term());
        }
        // TODO: handle << >> operators
        return build_additive_expr(terms.front().get_term());
    }

    /**
     * @brief Apply rule override or default implementation for a call.
     *
     * If the registry has a rule for this function, marks has_rule=true.
     * Otherwise, has_rule=false and the reverse pass will generate a call to
     * ad_rule_<func>::reverse() which the C++ compiler can resolve from
     * externally-defined rules (e.g., from cpp2ad_rules.h2 or user code).
     *
     * @param name Function name.
     * @param n_args Number of arguments.
     * @param is_member True for member calls.
     * @param args Argument IR nodes.
     * @return Rule application result with forward expression.
     */
    apply_rule_or_default: (inout this, name: std::string, n_args: int, is_member: bool, args: std::vector<ad_expr>)
        -> ad_rule_application_result =
    {
        result: ad_rule_application_result = ();

        // Check registry for rule with IR body
        if registry != nullptr && registry*.has_rule(name, n_args, is_member) {
            std::cout << "AD IR Builder: found rule '" << name << "' in registry\n";
            result.has_rule = true;
        } else {
            // No rule in registry - reverse pass will generate call to ad_rule_<func>::reverse()
            // The C++ compiler will resolve this from externally-defined ad_rule_* types
            std::cout << "AD IR Builder: no registry rule for '" << name << "', will use ad_rule_" << name << "::reverse()\n";
            result.has_rule = false;
        }

        // Forward expression is always the function call itself
        result.forward = ad_expr::make_call(name, ad_op_kind::call, args, "double");
        return result;
    }

    //-----------------------------------------------------------------------
    // Task 8: Activity analysis
    //-----------------------------------------------------------------------

    /**
     * @brief Check if an expression is active for AD.
     * @param expr IR expression to check.
     * @return True if the expression is active.
     */
    is_active_ir_expr: (this, expr: ad_expr) -> bool = {
        // Literals are not active
        if expr.kind == ad_expr_kind::literal {
            return false;
        }
        // Identifiers: check if it's a known active variable
        if expr.kind == ad_expr_kind::identifier {
            // For now, assume all identifiers are active (parameters)
            // A more sophisticated check would track active variables
            return true;
        }
        // Unary: active if operand is active
        if expr.kind == ad_expr_kind::unary {
            if !expr.args.empty() {
                return is_active_ir_expr(expr.args[0]);
            }
            return false;
        }
        // Binary: active if either operand is active
        if expr.kind == ad_expr_kind::binary {
            if expr.args.ssize() >= 2 {
                return is_active_ir_expr(expr.args[0]) || is_active_ir_expr(expr.args[1]);
            }
            return false;
        }
        // Call: active if any argument is active
        if expr.kind == ad_expr_kind::call {
            for expr.args do (arg) {
                if is_active_ir_expr(arg) { return true; }
            }
            return false;
        }
        return false;
    }

    //-----------------------------------------------------------------------
    // Task 9: Statement builder (decl + assignment)
    //-----------------------------------------------------------------------

    /**
     * @brief Build IR statements for a local object declaration.
     * @param decl Declaration to process.
     * @param body_stmts Output vector for forward statements.
     * @param reverse_stmts Output vector for reverse statements.
     */
    build_object_decl: (inout this, decl: meta::declaration,
                        inout body_stmts: std::vector<ad_stmt>,
                        inout reverse_stmts: std::vector<ad_stmt>) = {
        if !decl.is_object() {
            return;
        }
        obj := decl.as_object();
        name := obj.name() as std::string;
        type_str := obj.type() as std::string;

        std::cout << "AD IR Builder: object decl '" << name << "': " << type_str << "\n";

        // Check if it has an initializer
        if obj.has_initializer() {
            init_stmt := obj.get_initializer();
            init_ir: ad_expr = ();
            if init_stmt.is_expression_statement() {
                init_expr := init_stmt.as_expression_statement().get_expression();
                init_ir = build_expression(init_expr);
            } else {
                // Non-expression initializer - error
                report_error(
                    "Unsupported initializer type in AD",
                    init_stmt.to_string() as std::string,
                    "Expected an expression statement for variable initializer"
                );
                init_ir = ad_expr::make_literal("__ERROR__", "error");
            }

            // Create value declaration with _val suffix
            // Transform expression to use _val suffixes for identifiers
            val_name := ctx*.make_value_name(name);
            transformed_init := transform_expr_to_val(init_ir);
            val_decl := ad_stmt::make_decl(val_name, type_str, transformed_init);
            body_stmts.push_back(val_decl);

            // Create adjoint declaration: name_adj := 0.0
            adj_name := ctx*.make_adj_name(name);
            zero := ad_expr::make_literal("0.0", type_str);
            adj_decl := ad_stmt::make_decl(adj_name, type_str, zero);
            body_stmts.push_back(adj_decl);

            // Generate reverse statement if active
            if is_active_ir_expr(init_ir) {
                reverse_stmt := generate_reverse_for_expr(name, init_ir);
                reverse_stmts.push_back(reverse_stmt);
            }
        }
    }

    /**
     * @brief Build IR statements for an assignment.
     * @param target Target variable name.
     * @param value_expr RHS expression IR.
     * @param body_stmts Output vector for forward statements.
     * @param reverse_stmts Output vector for reverse statements.
     */
    build_assignment: (inout this, target: std::string, value_expr: ad_expr,
                       inout body_stmts: std::vector<ad_stmt>,
                       inout reverse_stmts: std::vector<ad_stmt>) = {
        // Forward pass: Store the result in target_val (with _val suffix)
        // This is needed because the reverse pass uses target_val for the chain rule
        //
        // Transform the value expression to use _val suffixes for identifiers
        transformed_expr := transform_expr_to_val(value_expr);

        // Create declaration: target_val := transformed_expr
        val_name := ctx*.make_value_name(target);
        decl_stmt := ad_stmt::make_decl(val_name, "double", transformed_expr);
        body_stmts.push_back(decl_stmt);

        // Also assign to the raw target (for the return value)
        val_ref := ad_expr::make_identifier(val_name, "double");
        assign_stmt := ad_stmt::make_assign(target, val_ref);
        body_stmts.push_back(assign_stmt);

        // Reverse: propagate adjoint if active
        if is_active_ir_expr(value_expr) {
            reverse_stmt := generate_reverse_for_expr(target, value_expr);
            reverse_stmts.push_back(reverse_stmt);
        }
    }

    /**
     * @brief Transform expression to use _val suffixes for identifiers.
     * @param expr Expression to transform.
     * @return Transformed expression with _val suffixes.
     */
    transform_expr_to_val: (inout this, expr: ad_expr) -> ad_expr = {
        if expr.kind == ad_expr_kind::identifier {
            // Transform identifier to use _val suffix
            return ad_expr::make_identifier(ctx*.make_value_name(expr.name), expr.type_name);
        }
        else if expr.kind == ad_expr_kind::literal {
            // Literals stay as-is
            return expr;
        }
        else if expr.kind == ad_expr_kind::unary {
            // Transform operand
            if !expr.args.empty() {
                result := expr;
                result.args[0] = transform_expr_to_val(expr.args[0]);
                return result;
            }
            return expr;
        }
        else if expr.kind == ad_expr_kind::binary {
            // Transform both operands
            if expr.args.ssize() >= 2 {
                result := expr;
                result.args[0] = transform_expr_to_val(expr.args[0]);
                result.args[1] = transform_expr_to_val(expr.args[1]);
                return result;
            }
            return expr;
        }
        else if expr.kind == ad_expr_kind::call {
            // Transform all arguments
            result := expr;
            i := 0;
            while i < result.args.ssize() {
                result.args[i] = transform_expr_to_val(result.args[i]);
                i++;
            }
            return result;
        }
        return expr;
    }

    /**
     * @brief Get rule suffix from operator symbol.
     *
     * Converts operator symbols to rule naming convention:
     * "+" -> "add", "-" -> "sub", "*" -> "mul", "/" -> "div", "%" -> "mod"
     *
     * @param op_name Operator symbol.
     * @return Rule suffix for error messages.
     */
    get_operator_rule_suffix: (this, op_name: std::string) -> std::string = {
        if op_name == "+" { return "add"; }
        if op_name == "-" { return "sub"; }
        if op_name == "*" { return "mul"; }
        if op_name == "/" { return "div"; }
        if op_name == "%" { return "mod"; }
        return "unknown";
    }

    /**
     * @brief Get LHS derivative contribution expression for an operator.
     *
     * Implements the derivative rules from ad_rule_* types in cpp2ad_rules.h2:
     * - add: x_adj += res_adj           -> contrib = res_adj
     * - sub: x_adj += res_adj           -> contrib = res_adj
     * - mul: x_adj += y_val * res_adj   -> contrib = y_val * res_adj
     * - div: x_adj += res_adj / y_val   -> contrib = res_adj / y_val
     *
     * @param op_name Operator symbol.
     * @param lhs_val LHS value expression.
     * @param rhs_val RHS value expression.
     * @param adj_ref Result adjoint expression.
     * @return Contribution expression for LHS adjoint accumulation.
     */
    get_lhs_derivative_contrib: (this, op_name: std::string, lhs_val: ad_expr, rhs_val: ad_expr, adj_ref: ad_expr) -> ad_expr = {
        if op_name == "+" || op_name == "-" {
            // d(x+y)/dx = 1, d(x-y)/dx = 1 -> contrib = res_adj
            return adj_ref;
        }
        if op_name == "*" {
            // d(x*y)/dx = y -> contrib = y_val * res_adj
            return ad_expr::make_binary(ad_op_kind::mul, rhs_val, adj_ref, "double");
        }
        if op_name == "/" {
            // d(x/y)/dx = 1/y -> contrib = res_adj / y_val
            return ad_expr::make_binary(ad_op_kind::div, adj_ref, rhs_val, "double");
        }
        // Default: just pass through adj_ref (treat like identity)
        return adj_ref;
    }

    /**
     * @brief Get RHS derivative contribution expression for an operator.
     *
     * Implements the derivative rules from ad_rule_* types in cpp2ad_rules.h2:
     * - add: y_adj += res_adj           -> contrib = res_adj
     * - sub: y_adj -= res_adj           -> contrib = -res_adj
     * - mul: y_adj += x_val * res_adj   -> contrib = x_val * res_adj
     * - div: y_adj -= x_val / (y_val * y_val) * res_adj
     *
     * @param op_name Operator symbol.
     * @param lhs_val LHS value expression.
     * @param rhs_val RHS value expression.
     * @param adj_ref Result adjoint expression.
     * @return Contribution expression for RHS adjoint accumulation.
     */
    get_rhs_derivative_contrib: (this, op_name: std::string, lhs_val: ad_expr, rhs_val: ad_expr, adj_ref: ad_expr) -> ad_expr = {
        if op_name == "+" {
            // d(x+y)/dy = 1 -> contrib = res_adj
            return adj_ref;
        }
        if op_name == "-" {
            // d(x-y)/dy = -1 -> contrib = -res_adj
            return ad_expr::make_unary(ad_op_kind::neg, adj_ref, "double");
        }
        if op_name == "*" {
            // d(x*y)/dy = x -> contrib = x_val * res_adj
            return ad_expr::make_binary(ad_op_kind::mul, lhs_val, adj_ref, "double");
        }
        if op_name == "/" {
            // d(x/y)/dy = -x/y^2 -> contrib = -(x_val / (y_val * y_val)) * res_adj
            rhs_sq := ad_expr::make_binary(ad_op_kind::mul, rhs_val, rhs_val, "double");
            quot := ad_expr::make_binary(ad_op_kind::div, lhs_val, rhs_sq, "double");
            neg_quot := ad_expr::make_unary(ad_op_kind::neg, quot, "double");
            return ad_expr::make_binary(ad_op_kind::mul, neg_quot, adj_ref, "double");
        }
        // Default: just pass through adj_ref
        return adj_ref;
    }

    /**
     * @brief Get LHS derivative scale factor for chain rule.
     *
     * When LHS is a function call, we need the scale factor to apply chain rule.
     * For x * f(y), d/df = x, so scale = x_val (but for LHS, we use the other operand).
     *
     * @param op_name Operator symbol.
     * @param lhs_val LHS value expression.
     * @param rhs_val RHS value expression.
     * @return Scale factor expression for chain rule application.
     */
    get_lhs_derivative_scale: (this, op_name: std::string, lhs_val: ad_expr, rhs_val: ad_expr) -> ad_expr = {
        if op_name == "+" || op_name == "-" {
            // d(x+y)/dx = 1 -> scale = 1 (use literal)
            return ad_expr::make_literal("1.0", "double");
        }
        if op_name == "*" {
            // d(x*y)/dx = y -> scale = y_val
            return rhs_val;
        }
        if op_name == "/" {
            // d(x/y)/dx = 1/y -> scale = 1/y_val
            one := ad_expr::make_literal("1.0", "double");
            return ad_expr::make_binary(ad_op_kind::div, one, rhs_val, "double");
        }
        return ad_expr::make_literal("1.0", "double");
    }

    /**
     * @brief Get RHS derivative scale factor for chain rule.
     *
     * When RHS is a function call, we need the scale factor to apply chain rule.
     * For x * f(y), d/dy = x * f'(y), so scale = x_val.
     *
     * @param op_name Operator symbol.
     * @param lhs_val LHS value expression.
     * @param rhs_val RHS value expression.
     * @return Scale factor expression for chain rule application.
     */
    get_rhs_derivative_scale: (this, op_name: std::string, lhs_val: ad_expr, rhs_val: ad_expr) -> ad_expr = {
        if op_name == "+" {
            // d(x+y)/dy = 1 -> scale = 1
            return ad_expr::make_literal("1.0", "double");
        }
        if op_name == "-" {
            // d(x-y)/dy = -1 -> scale = -1
            one := ad_expr::make_literal("1.0", "double");
            return ad_expr::make_unary(ad_op_kind::neg, one, "double");
        }
        if op_name == "*" {
            // d(x*y)/dy = x -> scale = x_val
            return lhs_val;
        }
        if op_name == "/" {
            // d(x/y)/dy = -x/y^2 -> scale = -x_val / (y_val * y_val)
            rhs_sq := ad_expr::make_binary(ad_op_kind::mul, rhs_val, rhs_val, "double");
            quot := ad_expr::make_binary(ad_op_kind::div, lhs_val, rhs_sq, "double");
            return ad_expr::make_unary(ad_op_kind::neg, quot, "double");
        }
        return ad_expr::make_literal("1.0", "double");
    }

    /**
     * @brief Generate reverse (adjoint) statement for an expression.
     * @param target Target variable name (whose adjoint receives contribution).
     * @param expr Expression IR.
     * @return Reverse statement.
     */
    generate_reverse_for_expr: (inout this, target: std::string, expr: ad_expr) -> ad_stmt = {
        target_adj := ctx*.make_adj_name(target);

        // For binary ops, look up the operator rule and apply partial derivatives
        if expr.kind == ad_expr_kind::binary {
            if expr.args.ssize() >= 2 {
                lhs := expr.args[0];
                rhs := expr.args[1];

                // Get the operator symbol for rule lookup
                op_name := ad_op_kind_to_rule_name(expr.op);

                // Priority 1: Check for user-defined operator rules
                // Users can override built-in operator differentiation by defining
                // ad_rule_add, ad_rule_mul, etc. in their @autodiff type
                if !op_name.empty() && registry != nullptr && registry*.has_operator_rule(op_name) {
                    // For simple cases (both operands are identifiers), use rule lookup directly
                    if lhs.kind == ad_expr_kind::identifier && rhs.kind == ad_expr_kind::identifier {
                        // Build substitution context for the rule body
                        sub_ctx: ad_substitution_context = ();

                        // Map rule parameters to actual expressions
                        sub_ctx.add("x_val", ad_expr::make_identifier(ctx*.make_value_name(lhs.name), "double"));
                        sub_ctx.add("y_val", ad_expr::make_identifier(ctx*.make_value_name(rhs.name), "double"));
                        sub_ctx.add("x_adj", ad_expr::make_identifier(ctx*.make_adj_name(lhs.name), "double"));
                        sub_ctx.add("y_adj", ad_expr::make_identifier(ctx*.make_adj_name(rhs.name), "double"));
                        sub_ctx.add("res_adj", ad_expr::make_identifier(target_adj, "double"));
                        sub_ctx.add("res_val", ad_expr::make_identifier(ctx*.make_value_name(target), "double"));

                        // Apply the operator rule
                        rule_result := registry*.apply_operator_rule(op_name, sub_ctx);
                        if rule_result.ir_success {
                            return ad_stmt::make_compound(rule_result.ir_stmts);
                        }
                        // Rule parsing failed - hard fail with compiler error
                        if !rule_result.error_message.empty() {
                            ctx*.mf.error("AD rule parsing failed: " + rule_result.error_message);
                        }
                    }
                }

                // Priority 2: Use built-in operator differentiation
                // These formulas match the ad_rule_* types defined in include/cpp2ad_rules.h2:
                // - ad_rule_add: x_adj += res_adj; y_adj += res_adj
                // - ad_rule_sub: x_adj += res_adj; y_adj -= res_adj
                // - ad_rule_mul: x_adj += y_val * res_adj; y_adj += x_val * res_adj
                // - ad_rule_div: x_adj += res_adj / y_val; y_adj -= x_val / (y_val * y_val) * res_adj
                if !op_name.empty() {
                    compound: std::vector<ad_stmt> = ();
                    adj_ref := ad_expr::make_identifier(target_adj, "double");

                    // Get lhs and rhs values for derivative computation
                    lhs_val: ad_expr = ();
                    rhs_val: ad_expr = ();
                    if lhs.kind == ad_expr_kind::identifier {
                        lhs_val = ad_expr::make_identifier(ctx*.make_value_name(lhs.name), "double");
                    } else {
                        lhs_val = lhs;
                    }
                    if rhs.kind == ad_expr_kind::identifier {
                        rhs_val = ad_expr::make_identifier(ctx*.make_value_name(rhs.name), "double");
                    } else {
                        rhs_val = rhs;
                    }

                    // Apply derivative formulas from ad_rule_* types:
                    // These partial derivative formulas are defined in ad_rule_add, ad_rule_sub, etc.
                    // in include/cpp2ad_rules.h2 - we use them here via chain rule

                    // Handle LHS contribution (d/d_lhs)
                    if lhs.kind == ad_expr_kind::identifier {
                        lhs_adj := ctx*.make_adj_name(lhs.name);
                        // Get contribution expression based on operator rule
                        contrib := get_lhs_derivative_contrib(op_name, lhs_val, rhs_val, adj_ref);
                        compound.push_back(ad_stmt::make_assign_add(lhs_adj, contrib));
                    }
                    else if lhs.kind == ad_expr_kind::call {
                        // LHS is a call - need chain rule through it
                        // Scale factor comes from the derivative rule
                        scale := get_lhs_derivative_scale(op_name, lhs_val, rhs_val);
                        call_reverse := generate_reverse_for_call_with_scale(lhs, scale, adj_ref);
                        compound.push_back(call_reverse);
                    }

                    // Handle RHS contribution (d/d_rhs)
                    if rhs.kind == ad_expr_kind::identifier {
                        rhs_adj := ctx*.make_adj_name(rhs.name);
                        // Get contribution expression based on operator rule
                        contrib := get_rhs_derivative_contrib(op_name, lhs_val, rhs_val, adj_ref);
                        compound.push_back(ad_stmt::make_assign_add(rhs_adj, contrib));
                    }
                    else if rhs.kind == ad_expr_kind::call {
                        // RHS is a call - need chain rule through it
                        scale := get_rhs_derivative_scale(op_name, lhs_val, rhs_val);
                        call_reverse := generate_reverse_for_call_with_scale(rhs, scale, adj_ref);
                        compound.push_back(call_reverse);
                    }

                    return ad_stmt::make_compound(compound);
                }
            }
        }
        else if expr.kind == ad_expr_kind::unary && expr.op == ad_op_kind::neg {
            // d(-a)/da = -1
            if !expr.args.empty() && expr.args[0].kind == ad_expr_kind::identifier {
                arg_adj := ctx*.make_adj_name(expr.args[0].name);
                adj_ref := ad_expr::make_identifier(target_adj, "double");
                neg_adj := ad_expr::make_unary(ad_op_kind::neg, adj_ref, "double");
                return ad_stmt::make_assign_add(arg_adj, neg_adj);
            }
        }
        else if expr.kind == ad_expr_kind::call {
            // For function calls, need to apply chain rule with function derivative
            return generate_reverse_for_call(target, expr);
        }
        else if expr.kind == ad_expr_kind::identifier {
            // Simple assignment: target = x => x_adj += target_adj
            arg_adj := ctx*.make_adj_name(expr.name);
            adj_ref := ad_expr::make_identifier(target_adj, "double");
            return ad_stmt::make_assign_add(arg_adj, adj_ref);
        }

        // Default: no-op (placeholder)
        empty: std::vector<ad_stmt> = ();
        return ad_stmt::make_compound(empty);
    }

    /**
     * @brief Generate reverse statement for a function call with scaling factor.
     *
     * Used when a call is part of a larger expression like x * f(y).
     * The derivative is: d(x * f(y))/dy = x * f'(y)
     *
     * @param call_expr Call expression IR.
     * @param scale_expr Expression to multiply the derivative by (e.g., lhs value).
     * @param adj_ref The adjoint of the outer expression.
     * @return Reverse statement.
     */
    generate_reverse_for_call_with_scale: (inout this, call_expr: ad_expr, scale_expr: ad_expr, adj_ref: ad_expr) -> ad_stmt = {
        compound: std::vector<ad_stmt> = ();
        func_name := call_expr.name;
        n_args : int = cpp2::unchecked_narrow<int>(call_expr.args.ssize());

        // The scaled adjoint contribution: scale_expr * adj_ref
        scaled_adj := ad_expr::make_binary(ad_op_kind::mul, scale_expr, adj_ref, "double");

        // Priority 1: Check registry for user-defined rules FIRST
        // User rules from the registry take priority
        if registry != nullptr && !call_expr.args.empty() {
            // Build substitution context for IR-based parsing
            sub_ctx: ad_substitution_context = ();

            // For res_val: build function call expression with argument values
            call_args: std::vector<ad_expr> = ();
            for call_expr.args do (arg) {
                if arg.kind == ad_expr_kind::identifier {
                    call_args.push_back(ad_expr::make_identifier(ctx*.make_value_name(arg.name), "double"));
                } else {
                    call_args.push_back(arg);
                }
            }
            res_val_call := ad_expr::make_call(func_name, ad_op_kind::call, call_args, "double");
            sub_ctx.add("res_val", res_val_call);

            // For res_adj: use the scaled adjoint (scale_expr * adj_ref)
            sub_ctx.add("res_adj", scaled_adj);

            // Add argument value and adjoint substitutions
            param_names: std::array<std::string, 4> = ("x", "y", "z", "w");
            i := 0;
            for call_expr.args do (arg) {
                if i < param_names.ssize() {
                    val_param := param_names[i] + "_val";
                    adj_param := param_names[i] + "_adj";

                    if arg.kind == ad_expr_kind::identifier {
                        sub_ctx.add(val_param, ad_expr::make_identifier(ctx*.make_value_name(arg.name), "double"));
                        sub_ctx.add(adj_param, ad_expr::make_identifier(ctx*.make_adj_name(arg.name), "double"));
                    } else {
                        // For non-identifier args (literals), use expression directly
                        sub_ctx.add(val_param, arg);
                        // Can't accumulate to non-identifier - use dummy
                        sub_ctx.add(adj_param, ad_expr::make_identifier("__unused_adj__", "double"));
                    }
                    i++;
                }
            }

            // Apply the rule - registry handles IR parsing internally
            rule_result := registry*.apply_reverse_rule(func_name, n_args, false, sub_ctx);

            if rule_result.found {
                if rule_result.ir_success {
                    // Success - return the parsed IR
                    return ad_stmt::make_compound(rule_result.ir_stmts);
                }

                // Rule found but parsing failed - report the specific error
                report_error(
                    "Failed to parse rule for function '" + func_name + "'",
                    "",
                    rule_result.error_message
                );
            }  // end if rule_result.found
        }  // end if registry != nullptr

        // HARD FAIL: No rule found for this function
        // All differentiable functions must have an ad_rule_* definition
        report_error(
            "No differentiation rule found for function '" + func_name + "'",
            "",
            "To differentiate this function, define an ad_rule_" + func_name + " type with a reverse() function. "
            + "See include/cpp2ad_rules.h2 for examples."
        );
        ctx*.mf.error("@autodiff: No rule found for function '" + func_name + "'. "
                      + "Define ad_rule_" + func_name + " with a reverse() function.");
        return ad_stmt::make_compound(());  // Return empty compound (will never be reached due to error)
    }

    /**
     * @brief Generate reverse statement for a function call.
     * @param target Target variable name.
     * @param call_expr Call expression IR.
     * @return Reverse statement.
     */
    generate_reverse_for_call: (inout this, target: std::string, call_expr: ad_expr) -> ad_stmt = {
        compound: std::vector<ad_stmt> = ();
        target_adj := ctx*.make_adj_name(target);
        adj_ref := ad_expr::make_identifier(target_adj, "double");

        func_name := call_expr.name;
        n_args : int = cpp2::unchecked_narrow<int>(call_expr.args.ssize());

        // Priority 1: Check registry for user-defined rules FIRST
        // User rules from the registry take priority
        if registry != nullptr {
            target_val := ctx*.make_value_name(target);

            // Build substitution context for IR-based parsing
            sub_ctx: ad_substitution_context = ();

            // Add result value and adjoint substitutions
            sub_ctx.add("res_val", ad_expr::make_identifier(target_val, "double"));
            sub_ctx.add("res_adj", ad_expr::make_identifier(target_adj, "double"));

            // Add argument value and adjoint substitutions
            param_names: std::array<std::string, 4> = ("x", "y", "z", "w");
            i := 0;
            for call_expr.args do (arg) {
                if i < param_names.ssize() {
                    val_param := param_names[i] + "_val";
                    adj_param := param_names[i] + "_adj";

                    if arg.kind == ad_expr_kind::identifier {
                        sub_ctx.add(val_param, ad_expr::make_identifier(ctx*.make_value_name(arg.name), "double"));
                        sub_ctx.add(adj_param, ad_expr::make_identifier(ctx*.make_adj_name(arg.name), "double"));
                    } else {
                        // For non-identifier args (literals), use expression directly
                        sub_ctx.add(val_param, arg);
                        // Can't accumulate to non-identifier - use dummy
                        sub_ctx.add(adj_param, ad_expr::make_identifier("__unused_adj__", "double"));
                    }
                    i++;
                }
            }

            // Apply the rule - registry handles IR parsing internally
            rule_result := registry*.apply_reverse_rule(func_name, n_args, false, sub_ctx);

            if rule_result.found {
                if rule_result.ir_success {
                    // Success - return the parsed IR
                    return ad_stmt::make_compound(rule_result.ir_stmts);
                }

                // Rule found but parsing failed - report the specific error
                report_error(
                    "Failed to parse rule for function '" + func_name + "'",
                    "",
                    rule_result.error_message
                );
            }
        }

        // No rule found for this function
        report_error(
            "No differentiation rule found for function '" + func_name + "'",
            "",
            "To differentiate this function, define an ad_rule_" + func_name + " type with a reverse() function. "
            + "See include/cpp2ad_rules.h2 for examples."
        );
        ctx*.mf.error("@autodiff: No rule found for function '" + func_name + "'. "
                      + "Define ad_rule_" + func_name + " with a reverse() function.");
        return ad_stmt::make_compound(());  // Return empty compound (will never be reached due to error)
    }

    //-----------------------------------------------------------------------
    // Task 10: Return statement lowering
    //-----------------------------------------------------------------------

    /**
     * @brief Build IR for a return statement and seed adjoint.
     * @param return_expr Expression being returned.
     * @param return_name Name of the return variable.
     * @param body_stmts Output vector for forward statements.
     * @param reverse_stmts Output vector for reverse statements.
     */
    build_return: (inout this, return_expr: ad_expr, return_name: std::string,
                   inout body_stmts: std::vector<ad_stmt>,
                   inout reverse_stmts: std::vector<ad_stmt>) = {
        // Forward: r_val = return_expr
        val_name := ctx*.make_value_name(return_name);
        assign_stmt := ad_stmt::make_assign(val_name, return_expr);
        body_stmts.push_back(assign_stmt);

        // Reverse: seed r_adj (done at beginning of reverse pass, handled by emitter)
        // Then propagate adjoint back through the return expression
        if is_active_ir_expr(return_expr) {
            reverse_stmt := generate_reverse_for_expr(return_name, return_expr);
            reverse_stmts.push_back(reverse_stmt);
        }
    }

    //-----------------------------------------------------------------------
    // Full function building
    //-----------------------------------------------------------------------

    /**
     * @brief Build complete IR for a function.
     * @param mf Function declaration.
     * @return Complete function IR.
     */
    build_function_ir: (inout this, mf: meta::function_declaration) -> ad_function_ir = {
        ir: ad_function_ir = ();
        ir.name = mf.name() as std::string;
        std::cout << "AD IR Builder: building function IR for '" << ir.name << "'\n";

        // Add parameters
        for mf.get_parameters() do (param) {
            decl := param.get_declaration();
            p := ad_param::make(
                decl.name() as std::string,
                decl.type() as std::string,
                param.get_passing_style(),
                true  // Assume active for now
            );
            ir.params.push_back(p);
            std::cout << "AD IR Builder:   param: " << p.name << ": " << p.type_name << "\n";
        }

        // Add returns
        for mf.get_returns() do (ret) {
            decl := ret.get_declaration();
            r := ad_param::make(
                decl.name() as std::string,
                decl.type() as std::string,
                ret.get_passing_style(),
                true
            );
            ir.returns.push_back(r);
            std::cout << "AD IR Builder:   return: " << r.name << ": " << r.type_name << "\n";
        }

        // Process function body (statements)
        if mf.has_compound_body() {
            body := mf.get_compound_body();
            statements := body.get_statements();
            std::cout << "AD IR Builder:   processing " << statements.ssize() << " statements\n";

            // Collect reverse statements in reverse order
            reverse_stmts: std::vector<ad_stmt> = ();

            for statements do (stmt) {
                process_statement(stmt, ir.forward, reverse_stmts);
            }

            // Reverse the reverse statements (they were collected in forward order)
            i := reverse_stmts.ssize() - 1;
            while i >= 0 {
                ir.reverse.push_back(reverse_stmts[i]);
                i--;
            }
        }

        return ir;
    }

    /**
     * @brief Process a single statement and add to forward/reverse lists.
     * @param stmt Statement to process.
     * @param forward_stmts Output vector for forward statements.
     * @param reverse_stmts Output vector for reverse statements (collected in forward order).
     */
    process_statement: (inout this, stmt: meta::statement,
                        inout forward_stmts: std::vector<ad_stmt>,
                        inout reverse_stmts: std::vector<ad_stmt>) = {
        str := stmt.to_string();
        std::cout << "AD IR Builder:     stmt: " << str << "\n";

        if stmt.is_declaration() {
            // Local variable declaration
            decl := stmt.as_declaration();
            build_object_decl(decl, forward_stmts, reverse_stmts);
        }
        else if stmt.is_expression_statement() {
            // Expression statement (typically an assignment)
            expr_stmt := stmt.as_expression_statement();
            expr := expr_stmt.get_expression();

            if expr.is_simple_assignment() {
                // Assignment: lhs = rhs
                lhs_rhs := expr.get_lhs_rhs_if_simple_assignment();
                lhs_str := lhs_rhs.lhs.to_string();
                std::cout << "AD IR Builder:       assignment to '" << lhs_str << "'\n";

                // Build the RHS expression
                rhs_ir := build_logical_or_expr(lhs_rhs.rhs);

                // Build assignment IR
                build_assignment(lhs_str as std::string, rhs_ir, forward_stmts, reverse_stmts);
            }
            else {
                std::cout << "AD IR Builder:       non-assignment expression (skipped)\n";
            }
        }
        else if stmt.is_return_statement() {
            // Return statement
            ret_stmt := stmt.as_return_statement();
            if ret_stmt.has_expression() {
                ret_expr := ret_stmt.get_expression();
                ret_ir := build_expression(ret_expr);

                // Use the first return variable name if available
                ret_name := "r";
                // Note: return statement handling would be more sophisticated
                std::cout << "AD IR Builder:       return statement\n";
            }
        }
        else {
            std::cout << "AD IR Builder:       unknown statement type (skipped)\n";
        }
    }
}

/**
 * @brief Result of applying a rule or default for a function call.
 */
ad_rule_application_result: type = {
    public has_rule : bool = false;
    public forward  : ad_expr = ();

    operator=: (out this) = {}
    operator=: (out this, that) = {}
}

//-----------------------------------------------------------------------
// Task 11 & 12: IR Emitter for forward and reverse passes
//-----------------------------------------------------------------------

/**
 * @brief Map ad_op_kind to its binary operator string representation.
 * @param op Operation kind.
 * @return Operator string with spaces (e.g., " + "), or empty if not a binary op.
 */
ad_op_kind_to_binary_str: (op: ad_op_kind) -> std::string = {
    // Arithmetic
    if op == ad_op_kind::add { return " + "; }
    if op == ad_op_kind::sub { return " - "; }
    if op == ad_op_kind::mul { return " * "; }
    if op == ad_op_kind::div { return " / "; }
    if op == ad_op_kind::mod { return " % "; }
    // Comparison
    if op == ad_op_kind::eq { return " == "; }
    if op == ad_op_kind::ne { return " != "; }
    if op == ad_op_kind::lt { return " < "; }
    if op == ad_op_kind::gt { return " > "; }
    if op == ad_op_kind::le { return " <= "; }
    if op == ad_op_kind::ge { return " >= "; }
    if op == ad_op_kind::spaceship { return " <=> "; }
    // Logical
    if op == ad_op_kind::land { return " && "; }
    if op == ad_op_kind::lor { return " || "; }
    // Bitwise
    if op == ad_op_kind::band { return " & "; }
    if op == ad_op_kind::bor { return " | "; }
    if op == ad_op_kind::bxor { return " ^ "; }
    if op == ad_op_kind::shl { return " << "; }
    if op == ad_op_kind::shr { return " >> "; }
    // Assignment
    if op == ad_op_kind::assign { return " = "; }
    if op == ad_op_kind::assign_add { return " += "; }
    if op == ad_op_kind::assign_sub { return " -= "; }
    if op == ad_op_kind::assign_mul { return " *= "; }
    if op == ad_op_kind::assign_div { return " /= "; }
    if op == ad_op_kind::assign_mod { return " %= "; }
    if op == ad_op_kind::assign_band { return " &= "; }
    if op == ad_op_kind::assign_bor { return " |= "; }
    if op == ad_op_kind::assign_bxor { return " ^= "; }
    if op == ad_op_kind::assign_shl { return " <<= "; }
    if op == ad_op_kind::assign_shr { return " >>= "; }
    return "";
}

/**
 * @brief Map ad_op_kind to rule lookup name (operator symbol without spaces).
 *
 * This is used to look up operator rules in the ad_rule_registry.
 * Operators are stored with their symbol as the name ("+", "-", "*", "/").
 *
 * @param op Operation kind.
 * @return Operator symbol for rule lookup, or empty if not a differentiable binary op.
 */
ad_op_kind_to_rule_name: (op: ad_op_kind) -> std::string = {
    if op == ad_op_kind::add { return "+"; }
    if op == ad_op_kind::sub { return "-"; }
    if op == ad_op_kind::mul { return "*"; }
    if op == ad_op_kind::div { return "/"; }
    if op == ad_op_kind::mod { return "%"; }
    return "";  // Other operators don't have AD rules
}

/**
 * @brief Emitter for converting AD IR to Cpp2 source code.
 */
ad_ir_emitter: type = {
    public ctx : *reverse_autodiff_context;

    operator=: (out this) = {
        ctx = nullptr;
    }

    operator=: (out this, ctx_: *reverse_autodiff_context) = {
        ctx = ctx_;
    }

    /**
     * @brief Emit Cpp2 code for an IR expression.
     * @param expr Expression IR.
     * @return Cpp2 source string.
     */
    emit_expr: (this, expr: ad_expr) -> std::string = {
        if expr.kind == ad_expr_kind::literal {
            return expr.name;
        }
        else if expr.kind == ad_expr_kind::identifier {
            return expr.name;
        }
        else if expr.kind == ad_expr_kind::unary {
            if !expr.args.empty() {
                operand: std::string = emit_expr(expr.args[0]);
                // Handle different unary operators
                if expr.op == ad_op_kind::neg { return "(-" + operand + ")"; }
                if expr.op == ad_op_kind::pos { return "(+" + operand + ")"; }
                if expr.op == ad_op_kind::lnot { return "(!" + operand + ")"; }
                if expr.op == ad_op_kind::bnot { return "(~" + operand + ")"; }
                if expr.op == ad_op_kind::deref { return "(*" + operand + ")"; }
                if expr.op == ad_op_kind::addr_of { return "(&" + operand + ")"; }
                if expr.op == ad_op_kind::pre_inc { return "(++" + operand + ")"; }
                if expr.op == ad_op_kind::pre_dec { return "(--" + operand + ")"; }
                if expr.op == ad_op_kind::post_inc { return "(" + operand + "++)"; }
                if expr.op == ad_op_kind::post_dec { return "(" + operand + "--)"; }
            }
            return "(unary " + ad_op_kind_to_string(expr.op) + ")";
        }
        else if expr.kind == ad_expr_kind::binary {
            if expr.args.ssize() >= 2 {
                lhs: std::string = emit_expr(expr.args[0]);
                rhs: std::string = emit_expr(expr.args[1]);
                op_str: std::string = ad_op_kind_to_binary_str(expr.op);
                if op_str.empty() { op_str = " ?? "; }
                return "(" + lhs + op_str + rhs + ")";
            }
            return "(binary)";
        }
        else if expr.kind == ad_expr_kind::ternary {
            if expr.args.ssize() >= 3 {
                cond: std::string = emit_expr(expr.args[0]);
                then_expr: std::string = emit_expr(expr.args[1]);
                else_expr: std::string = emit_expr(expr.args[2]);
                return "(" + cond + " ? " + then_expr + " : " + else_expr + ")";
            }
            return "(ternary)";
        }
        else if expr.kind == ad_expr_kind::member {
            if !expr.args.empty() {
                obj: std::string = emit_expr(expr.args[0]);
                op_str: std::string = "->";
                if expr.op != ad_op_kind::arrow { op_str = "."; }
                return obj + op_str + expr.member_name;
            }
            return "(member)";
        }
        else if expr.kind == ad_expr_kind::subscript {
            if expr.args.ssize() >= 2 {
                arr: std::string = emit_expr(expr.args[0]);
                idx: std::string = emit_expr(expr.args[1]);
                return arr + "[" + idx + "]";
            }
            return "(subscript)";
        }
        else if expr.kind == ad_expr_kind::call {
            result: std::string = expr.name;
            // Add template args if present
            if !expr.type_args.empty() {
                result += "<";
                (copy first: bool = true)
                for expr.type_args do (targ) {
                    if !first { result += ", "; }
                    first = false;
                    result += ad_type_to_string(targ);
                }
                result += ">";
            }
            result += "(";
            (copy first: bool = true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += ")";
            return result;
        }
        else if expr.kind == ad_expr_kind::method_call {
            if !expr.args.empty() {
                obj: std::string = emit_expr(expr.args[0]);
                result: std::string = obj + "." + expr.name + "(";
                // Skip first arg (the object), emit remaining args
                if expr.args.ssize() > 1 {
                    result += emit_expr(expr.args[1]);
                    i: i64 = 2;
                    while i < expr.args.ssize() {
                        result += ", ";
                        result += emit_expr(expr.args[i]);
                        i++;
                    }
                }
                result += ")";
                return result;
            }
            return "(method_call)";
        }
        else if expr.kind == ad_expr_kind::cast {
            if !expr.args.empty() {
                target_type: std::string = "";
                if expr.cast_type != nullptr {
                    target_type = ad_type_to_string(expr.cast_type*);
                } else {
                    target_type = expr.type_name;
                }
                inner := emit_expr(expr.args[0]);
                if expr.name != "" {
                    return expr.name + "<" + target_type + ">(" + inner + ")";
                }
                return "(" + target_type + ")" + inner;
            }
            return "(cast)";
        }
        else if expr.kind == ad_expr_kind::construct {
            result: std::string = expr.name + "(";
            (copy first: bool = true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += ")";
            return result;
        }
        else if expr.kind == ad_expr_kind::paren {
            if !expr.args.empty() {
                return "(" + emit_expr(expr.args[0]) + ")";
            }
            return "()";
        }
        else if expr.kind == ad_expr_kind::initializer_list {
            result: std::string = "{";
            (copy first: bool = true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += "}";
            return result;
        }
        return "(unknown)";
    }

    /**
     * @brief Emit Cpp2 code for a single IR statement.
     * @param stmt Statement IR.
     * @param indent Indentation level.
     * @return Cpp2 source string.
     */
    emit_stmt: (this, stmt: ad_stmt, indent: int = 0) -> std::string = {
        ind: std::string = std::string(indent * 4, ' ');

        if stmt.kind == ad_stmt_kind::decl {
            // Declaration: name : type = expr;
            return ind + stmt.target + " : " + stmt.type_name + " = " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::assign {
            // Assignment: name = expr;
            return ind + stmt.target + " = " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::compound_assign {
            // Compound assignment: name op= expr;
            op_str: std::string = ad_op_kind_to_binary_str(stmt.op);
            if op_str.empty() { op_str = " ??= "; }
            return ind + stmt.target + op_str + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::assign_add {
            // Add-assignment: name += expr;
            return ind + stmt.target + " += " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::expr || stmt.kind == ad_stmt_kind::expr_stmt {
            // Expression statement
            return ind + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::return_ {
            // Return statement
            return ind + "return " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::break_stmt {
            return ind + "break;\n";
        }
        else if stmt.kind == ad_stmt_kind::continue_stmt {
            return ind + "continue;\n";
        }
        else if stmt.kind == ad_stmt_kind::compound {
            // Compound statement
            result: std::string = "";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent);
            }
            return result;
        }
        else if stmt.kind == ad_stmt_kind::if_stmt {
            // If statement
            result: std::string = ind + "if " + emit_expr(stmt.expr) + " {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            if !stmt.else_stmts.empty() {
                result += ind + "} else {\n";
                for stmt.else_stmts do (s) {
                    result += emit_stmt(s, indent + 1);
                }
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::for_stmt {
            // For loop - emit as Cpp2 style
            result: std::string = ind + "for ";
            // Init statement
            if stmt.init_stmt != nullptr {
                init_code: std::string = emit_stmt(stmt.init_stmt*, 0);
                // Remove trailing newline and semicolon for init
                if init_code.ends_with(";\n") {
                    init_code = init_code.substr(0, init_code.size() - 2);
                }
                result += init_code;
            }
            result += "; " + emit_expr(stmt.expr) + " next ";
            // Increment - emit without semicolon
            incr_code: std::string = emit_expr(stmt.incr_expr);
            result += incr_code + " {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::foreach_stmt {
            // Range-based for loop
            result: std::string = ind + "for " + stmt.target;
            if stmt.type_name != "" && stmt.type_name != "auto" {
                result += " : " + stmt.type_name;
            }
            result += " in " + emit_expr(stmt.range_expr) + " {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::while_stmt {
            // While loop
            result: std::string = ind + "while " + emit_expr(stmt.expr) + " {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::do_while_stmt {
            // Do-while loop
            result: std::string = ind + "do {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "} while " + emit_expr(stmt.expr) + ";\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::try_catch {
            // Try-catch block
            result: std::string = ind + "try {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "} catch (" + stmt.catch_type;
            if stmt.catch_var != "" {
                result += " " + stmt.catch_var;
            }
            result += ") {\n";
            for stmt.catch_stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::throw_stmt {
            return ind + "throw " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::raw_code {
            // Raw code - emit directly (already substituted)
            // The code is stored in stmt.target and may contain multiple lines
            // DEPRECATED: Will be removed after IR-based rule substitution is complete
            return ind + stmt.target + "\n";
        }
        return ind + "// unknown statement\n";
    }

    /**
     * @brief Emit the forward pass Cpp2 code.
     * @param ir Function IR.
     * @return Cpp2 source for forward pass.
     */
    emit_forward: (this, ir: ad_function_ir) -> std::string = {
        result: std::string = "// Forward pass\n";
        for ir.forward do (stmt) {
            result += emit_stmt(stmt, 1);
        }
        return result;
    }

    /**
     * @brief Emit the reverse pass Cpp2 code in reverse order.
     * @param ir Function IR.
     * @return Cpp2 source for reverse pass.
     */
    emit_reverse: (this, ir: ad_function_ir) -> std::string = {
        result: std::string = "// Reverse pass\n";

        // Seed the output adjoint(s)
        for ir.returns do (ret) {
            adj_name: std::string = ctx*.make_adj_name(ret.name);
            // Don't emit seed here - it's passed in as parameter
        }

        // Emit statements (already in correct reverse order from build_function_ir)
        for ir.reverse do (stmt) {
            result += emit_stmt(stmt, 1);
        }

        // Reset adjoints to zero after use
        for ir.returns do (ret) {
            adj_name: std::string = ctx*.make_adj_name(ret.name);
            result += std::string("    ") + adj_name + " = 0.0;\n";
        }

        return result;
    }

    /**
     * @brief Emit the complete reverse-mode function.
     * @param ir Function IR.
     * @return Cpp2 source for the _b function.
     */
    emit_function: (this, ir: ad_function_ir) -> std::string = {
        // Build signature
        result: std::string = ir.name + "_d: (\n";

        // Input parameters with adjoints
        for ir.params do (p) {
            pass_str: std::string = "in";
            if p.pass == passing_style::in { pass_str = "in"; }
            else if p.pass == passing_style::inout { pass_str = "inout"; }
            else if p.pass == passing_style::out { pass_str = "out"; }
            else if p.pass == passing_style::copy { pass_str = "copy"; }
            else if p.pass == passing_style::move { pass_str = "move"; }
            else if p.pass == passing_style::forward { pass_str = "forward"; }

            result += std::string("    ") + pass_str + " " + p.name + ": " + p.type_name + ",\n";
            // Add adjoint parameter
            adj_name: std::string = ctx*.make_adj_name(p.name);
            result += std::string("    inout ") + adj_name + ": " + p.type_name + ",\n";
        }

        // Return adjoint parameter
        for ir.returns do (r) {
            adj_name: std::string = ctx*.make_adj_name(r.name);
            result += std::string("    inout ") + adj_name + ": " + r.type_name + ",\n";
        }

        // Return type
        result += ") -> (";
        (copy first: bool = true)
        for ir.returns do (r) {
            if !first { result += ", "; }
            first = false;
            result += std::string("out ") + r.name + ": " + r.type_name + " = 0.0";
        }
        result += ") = {\n";

        // Create _val variables for input parameters
        result += "// Setup value variables\n";
        for ir.params do (p) {
            val_name: std::string = ctx*.make_value_name(p.name);
            result += std::string("    ") + val_name + " := " + p.name + ";\n";
        }

        // Emit forward pass
        result += emit_forward(ir);

        // Emit reverse pass
        result += emit_reverse(ir);

        // Return
        result += "    return;\n";
        result += "}\n";

        return result;
    }
}

/**
 * @brief Debug dump for ad_ir_builder state.
 * @param builder Builder to dump.
 */
ad_ir_builder_debug_dump: (builder: ad_ir_builder) = {
    std::cout << "=== AD IR Builder State ===\n";
    std::cout << "  temp_counter: " << builder.temp_counter << "\n";
    std::cout << "  temp_names: [";
    (copy first: bool = true)
    for builder.temp_names do (name) {
        if !first { std::cout << ", "; }
        first = false;
        std::cout << name;
    }
    std::cout << "]\n";
    std::cout << "=== End AD IR Builder State ===\n";
}

/**
 * @brief Internal reverse-mode AD processing - transforms a type using IR pipeline.
 *
 * 
 *                      REVERSE-MODE IR PROCESSING PIPELINE
 * 
 *
 * This function implements the core reverse-mode AD transformation:
 *
 *   
 *                            PROCESSING FLOW                                 
 *   
 *
 *   Input: @autodiff<"reverse"> annotated type
 *          
 *          
 *   
 *     STAGE 1: RULE DISCOVERY                                                 
 *      
 *     - Scan type for nested ad_rule_* types                                  
 *     - Extract: name, n_args, is_member, reverse() body                      
 *     - Store AST nodes of reverse() body for IR parsing                      
 *     - Build ad_rule_registry with all discovered rules                      
 *   
 *          
 *          
 *   
 *     STAGE 2: FOR EACH MEMBER FUNCTION                                       
 *      
 *                                                                             
 *       
 *       2a. CREATE CONTEXTS                                                 
 *       - reverse_autodiff_context: naming conventions, suffixes            
 *       - ad_ir_builder: IR construction with registry access               
 *       
 *                                                                            
 *                                                                            
 *       
 *       2b. BUILD FUNCTION IR (ad_ir_builder::build_function_ir)            
 *       - Walk function's reflection AST                                    
 *       - Build ad_expr nodes for each expression                           
 *       - Build ad_stmt nodes for each statement                            
 *       - Generate forward pass: x_val = x, compute intermediates           
 *       - Generate reverse pass: apply chain rule, accumulate adjoints      
 *       - Result: ad_func_ir with body_stmts and reverse_stmts              
 *       
 *                                                                            
 *                                                                            
 *       
 *       2c. EMIT CODE (ad_ir_emitter)                                       
 *       - emit_forward(): Convert body_stmts to Cpp1 string                 
 *       - emit_reverse(): Convert reverse_stmts to Cpp1 string              
 *       - emit_function(): Combine into complete backward function          
 *       
 *                                                                            
 *                                                                            
 *       
 *       2d. INJECT CODE                                                     
 *       - t.add_member(func_code): Add backward function to type            
 *       
 *   
 *          
 *          
 *   Output: Type with generated f_backward functions for each f
 *
 *   
 *                            KEY COMPONENTS                                  
 *   
 *
 *   ad_rule_registry
 *    rules: vector<ad_rule_meta>     All discovered rules
 *    has_rule(name, n_args, is_member) -> bool
 *    get_rule_type(name, ...) -> string
 *    apply_reverse_rule(name, ..., ctx) -> ad_reverse_rule_result
 *                                              ir_stmts: vector<ad_stmt>
 *
 *   ad_ir_builder
 *    ctx: *reverse_autodiff_context  Naming conventions
 *    registry: *ad_rule_registry     Rule lookup
 *    build_function_ir(mf) -> ad_func_ir
 *    build_expression(expr) -> ad_expr
 *    generate_reverse_for_expr(target, expr) -> ad_stmt
 *    report_error(msg, loc, context)  Hard failure on errors
 *
 *   ad_ir_emitter
 *    ctx: *reverse_autodiff_context  Naming conventions
 *    emit_expr(expr) -> string       Expression to code
 *    emit_stmt(stmt) -> string       Statement to code
 *    emit_forward(func_ir) -> string Forward pass code
 *    emit_reverse(func_ir) -> string Reverse pass code
 *
 *   
 *                         REVERSE PASS GENERATION                            
 *   
 *
 *   For each statement in the forward pass, generate corresponding adjoint code:
 *
 *   Forward Statement              Reverse Statement(s)
 *                 
 *   t = x + y                      x_adj += t_adj; y_adj += t_adj
 *   t = x - y                      x_adj += t_adj; y_adj -= t_adj
 *   t = x * y                      x_adj += y_val * t_adj; y_adj += x_val * t_adj
 *   t = x / y                      x_adj += t_adj / y_val; y_adj -= x_val * t_adj / (y_val * y_val)
 *   t = sin(x)                     x_adj += cos(x_val) * t_adj
 *   t = f(x, y)                    [lookup ad_rule_f::reverse and apply]
 *
 *   Statements are collected during forward pass, then reversed for backward pass.
 *
 * @param t Type declaration to transform (modified in place).
 * @param ctx Autodiff context with configuration (suffixes, order, mode).
 *
 * @see autodiff                 Main entry point (parses arguments)
 * @see ad_rule_registry         Rule storage and application
 * @see ad_ir_builder           IR construction from reflection AST
 * @see ad_ir_emitter           Code generation from IR
 */
autodiff_reverse_ir: (inout t: meta::type_declaration, debug: bool) = {
    if debug {
        std::cout << "\n";
        std::cout << "\n";
        std::cout << "  AD REVERSE IR STAGE: " << t.name() << "\n";
        std::cout << "\n";

        // Print the original AST
        std::cout << "\n Original AST \n";
        print(t);
        std::cout << "\n";
    }

    //-------------------------------------------------------------------
    // Discover ad_rules in the type
    //-------------------------------------------------------------------
    rule_registry: ad_rule_registry = ();
    discover_ad_rules(t, rule_registry);
    if debug {
        std::cout << "\n Rule Discovery \n";
        ad_rule_registry_debug_dump(rule_registry);
        std::cout << "\n";
    }

    //-------------------------------------------------------------------
    // Build IR for each function
    //-------------------------------------------------------------------
    for t.get_member_functions() do (mf) {
        // Skip rule types (they have special structure)
        if mf.name().starts_with("ad_rule") {
            continue;
        }

        rc: reverse_autodiff_context = (mf);
        if debug {
            std::cout << "\n Building IR for " << mf.name() << " \n";
            std::cout << "Function: " << mf.get_signature() << "\n";
            std::cout << "Suffixes: value=" << rc.value_suffix << " adj=" << rc.adj_suffix << "\n";
        }

        // Create builder with context and registry
        builder: ad_ir_builder = (rc&, rule_registry&);

        // Build the complete function IR using the builder
        if debug {
            std::cout << "\n--- Building Function IR ---\n";
        }
        func_ir := builder.build_function_ir(mf);
        _ = builder;  // Explicitly discard modified builder

        // Emit complete function
        emitter: ad_ir_emitter = (rc&);
        func_code := emitter.emit_function(func_ir);

        if debug {
            std::cout << "\nGenerated function:\n";
            std::cout << func_code;
        }

        // Add the backward function to the type
        if !func_code.empty() {
            t.add_member(func_code);
            if debug {
                std::cout << "  -> Added backward function to type\n";
                std::cout << "\n";
            }
        }
    }

    if debug {
        std::cout << "\n\n";
        std::cout << "  AD REVERSE IR STAGE COMPLETE\n";
        std::cout << "\n\n";
    }
}

autodiff_impl: (inout t: meta::type_declaration) =
{

    suffix_token      : std::string_view == "suffix=";
    rws_suffix_token  : std::string_view == "rws_suffix=";
    order_token       : std::string_view == "order=";
    reverse_token     : std::string_view == "reverse";
    debug_token       : std::string_view == "debug";

    args := t.get_arguments();

    suffix    : std::string = "_d";
    rws_suffix: std::string = "_b";
    order     : int         = 1;
    reverse   : bool        = false;
    debug     : bool        = false;
    for args do (arg_str) {
        if arg_str.starts_with("\"") && arg_str.ends_with("\"") {
            arg := arg_str.substr(1, arg_str.ssize() - 2);

            if arg.starts_with(suffix_token) {
                suffix = arg.substr(suffix_token.size());
                continue;
            }
            else if arg.starts_with(rws_suffix_token) {
                suffix = arg.substr(rws_suffix_token.size());
                continue;
            }
            else if arg.starts_with(order_token) {
                if !string_util::string_to_int(arg.substr(order_token.size()), order) {
                    t.error("AD: Could not parse derivative order: (arg.substr(order_token.size()))$");
                    return;
                }
                continue;
            }
            else if arg == reverse_token {
                reverse = true;
                continue;
            }
            else if arg == debug_token {
                debug = true;
                continue;
            }
        }

        t.error("AD: Unknown argument: (arg_str)$");
        return;
    }

    if reverse {
        std::cout << "AD: Warning - reverse mode differentiation is very experimental\n";

        // Higher-order reverse mode not yet supported
        if order != 1 {
            t.error("@autodiff: Higher-order reverse mode (order > 1 with reverse) is not yet supported");
            return;
        }

        // Call reverse mode IR builder (completely independent path)
        autodiff_reverse_ir(t, debug);
        t.add_runtime_support_include("cpp2ad_stack.h");
        return;  // Skip old forward mode code entirely
    }

    // Forward mode path continues below
    ad_ctx: autodiff_context = (order, false);
    ad_ctx.fwd_suffix = suffix;
    ad_ctx.rws_suffix = rws_suffix;

    // Skip old string-based code generation for types starting with "test_"
    // This allows IR-only debugging during development
    type_name := t.name() as std::string;
    if type_name.starts_with("test_") {
        std::cout << "AD: Skipping old code generation for test type '" << type_name << "'\n";
        return;
    }

    if t.parent_is_nonglobal_namespace() {
        p := t.get_parent().as_nonglobal_namespace();
        ad_ctx.create_namespace_stack(p);
        ad: autodiff_declaration_handler = (ad_ctx&, p);
        ad.pre_traverse(t);

    }
    else if t.parent_is_type() {
        p := t.get_parent().as_type();
        ad_ctx.create_namespace_stack(p);
        ad: autodiff_declaration_handler = (ad_ctx&, p);
        ad.pre_traverse(t);
    }
    else {
        // TODO: Remove when global namespace is available.
        // Traverse without parent context
        ad_ctx.push_stack(t);
        ad: autodiff_declaration_handler = (ad_ctx&, t);

        for t.get_members()
        do  (m)
        if  m.is_function()
        {
            ad.pre_traverse(m);
        }
        ad_ctx.pop_stack();
    }

    if 1 != order {
        t.add_runtime_support_include( "cpp2taylor.h" );
    }

    ad_ctx.finish();
    _ = ad_ctx;
}

}  // namespace meta

}  // namespace cpp2
