
//  Copyright 2022-2026 Herb Sutter
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//  Part of the Cppfront Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://github.com/hsutter/cppfront/blob/main/LICENSE for license information.


//===========================================================================
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !(ret as bool) {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);

    is_same:      (this, o: reflection_base)     -> bool = n == o.n;  // Test pointers
    is_same: <TO> (this, _: reflection_base<TO>) -> bool = false;     // Different types => false
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }

        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
//
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Expression list
//
expression_list: @copy_constructible type =
{
    this: reflection_base<expression_list_node> = ();

    operator=: (
        out this,
        n_: *expression_list_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_list_node> = (n_, s);
    }

    is_empty          : (this) -> bool = n*.is_empty          ();
    is_fold_expression: (this) -> bool = n*.is_fold_expression();

    get_expressions: (this)
        -> std::vector<expression>
    = {
        ret: std::vector<expression> = ();
        for n*.get_expressions() do (expr) {
            _ = ret.emplace_back(expression(expr.expr.get(), this));
        }
        return ret;
    }

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Prefix expressions
//
prefix_expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<prefix_expression_node> = ();

    operator=: (
        out this,
        n_: *prefix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<prefix_expression_node> = (n_, s);
    }

    get_ops: (this) -> std::vector<std::string> = {
        ret: std::vector<std::string> = ();
        for n*.ops do (op) {
            _ = ret.emplace_back(op*.to_string());
        }
        return ret;
    }

    get_postfix_expression: (this) -> postfix_expression = (this.n*.expr.get(), this);

    is_fold_expression            : (this) -> bool = n*.is_fold_expression            ();
    is_identifier                 : (this) -> bool = n*.is_identifier                 ();
    is_id_expression              : (this) -> bool = n*.is_id_expression              ();
    is_unqualified_id             : (this) -> bool = n*.is_unqualified_id             ();
    is_expression_list            : (this) -> bool = n*.is_expression_list            ();
    is_literal                    : (this) -> bool = n*.is_literal                    ();
    is_result_a_temporary_variable: (this) -> bool = n*.is_result_a_temporary_variable();

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();
    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Postfix expressions
//
postfix_expression: @copy_constructible type =
{
    this: reflection_base<postfix_expression_node> = ();

    operator=: (
        out this,
        n_: *postfix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<postfix_expression_node> = (n_, s);
    }

    get_primary_expression: (this) -> primary_expression = (this.n*.expr.get(), this);

    term_t: @copy_constructible type = {
        private term_: * const postfix_expression_node::term;
        private cs_  : * const compiler_services;

        operator=: (out this, forward term, forward cs) = { term_ = term; cs_ = cs; }

        get_op            : (this) -> std::string_view  = term_*.op*.as_string_view();

        //  If op is        More is contained in the        Notes
        //
        //  .               id_expression                   member selection
        //  [ (             expression_list                 subscript or function call
        //  ...             expression                      fold expression

        is_id_expression   : (this) -> bool            = term_*.id_expr  .get() != nullptr;
        is_expression_list : (this) -> bool            = term_*.expr_list.get() != nullptr;
        is_expression      : (this) -> bool            = term_*.last_expr.get() != nullptr;

        get_id_expression  : (this) -> id_expression   = (term_*.id_expr  .get(), cs_*);
        get_expression_list: (this) -> expression_list = (term_*.expr_list.get(), cs_*);
        get_expression     : (this) -> expression      = (term_*.last_expr.get(), cs_*);
    }

    get_terms: (this) -> _ = {
        ret: std::vector<term_t> = ();
        for this.n*.ops do (t) { _ = ret.emplace_back( t&, this& ); }
        return ret;
    }

    is_fold_expression: (this) -> bool = n*.is_fold_expression();
    is_identifier     : (this) -> bool = n*.is_identifier     ();
    is_id_expression  : (this) -> bool = n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = n*.is_expression_list();
    is_literal        : (this) -> bool = n*.is_literal        ();

    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();
    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();

    get_first_token_ignoring_this: (this) -> std::string_view = {
        ptok := n*.get_first_token_ignoring_this();
        if ptok { return ptok*; }
        return "";
    }

    starts_with_function_call_with_num_parameters: (this, num: int) -> bool = n*.starts_with_function_call_with_n_parameters(num);
    is_result_a_temporary_variable               : (this) -> bool           = n*.is_result_a_temporary_variable             ();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Template arguments
//
template_arg: @copy_constructible type =
{
    this: reflection_base<template_argument> = ();

    operator=: (
        out this,
        n_: *template_argument,
        s : compiler_services
    )
    = {
        reflection_base<template_argument> = (n_, s);
    }

    is_expression: (this) -> bool = n*.is_expression();
    is_type_id   : (this) -> bool = n*.is_type_id   ();

    as_expression: (this) -> expression = (this.n*.get_expression(), this);
    as_type_id   : (this) -> type_id    = (this.n*.get_type_id(),    this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Unqualified IDs
//
unqualified_id: @copy_constructible type =
{
    this: reflection_base<unqualified_id_node> = ();

    operator=: (
        out this,
        n_: *unqualified_id_node,
        s : compiler_services
    )
    = {
        reflection_base<unqualified_id_node> = (n_, s);
    }

    is_identifier : (this) -> bool        = n*.is_identifier();

    get_identifier: (this) -> std::string = n*.get_identifier()*.to_string();

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    as_token : (this) -> std::string = n*.get_token()*.to_string();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Qualified IDs
//
qualified_id: @copy_constructible type =
{
    this: reflection_base<qualified_id_node> = ();

    operator=: (
        out this,
        n_: *qualified_id_node,
        s : compiler_services
    )
    = {
        reflection_base<qualified_id_node> = (n_, s);
    }

    term_t: @copy_constructible type = {
        op:          std::string;
        unqualified: unqualified_id;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; unqualified = (ptr, cs); }

        get_op:          (this) -> std::string    = op;
        get_unqualified: (this) -> unqualified_id = unqualified;
    }

    get_terms: (this) -> _ = {
        ret: std::vector<term_t> = ();
        for this.n*.ids do (t) { _ = ret.emplace_back( t.scope_op*, t.id.get(), this ); }
        return ret;
    }

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    as_token : (this) -> std::string = n*.get_token()*.to_string();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Type IDs
//
type_id: @copy_constructible type =
{
    this: reflection_base<type_id_node> = ();

    operator=: (
        out this,
        n_: *type_id_node,
        s : compiler_services
    )
    = {
        reflection_base<type_id_node> = (n_, s);
    }

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    is_postfix_expression: (this) -> bool = this.n*.is_postfix_expression();
    is_qualified_id      : (this) -> bool = this.n*.is_qualified_id      ();
    is_unqualified_id    : (this) -> bool = this.n*.is_unqualified_id    ();
    is_function_typeid   : (this) -> bool = this.n*.is_function_typeid   ();
    is_keyword           : (this) -> bool = this.n*.is_keyword           ();
    is_wildcard          : (this) -> bool = this.n*.is_wildcard          ();
    is_pointer_qualified : (this) -> bool = this.n*.is_pointer_qualified ();
    is_concept           : (this) -> bool = this.n*.is_concept           ();

    as_postfix_expression: (this) -> postfix_expression = (n*.get_postfix_expression(), this);
    as_qualified_id      : (this) -> qualified_id       = (n*.get_qualified_id(),       this);
    as_unqualified_id    : (this) -> unqualified_id     = (n*.get_unqualified_id(),     this);
    // TODO
    //as_function_typeid   : (this) -> function_typeid    = (n*.get_function_typeid(),    this);
    as_keyword           : (this) -> std::string        = n*.get_keyword()*.to_string();
    as_token             : (this) -> std::string        = n*.get_token()*.to_string();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Primary expressions
//
primary_expression: @copy_constructible type =
{
    this: reflection_base<primary_expression_node> = ();

    operator=: (
        out this,
        n_: *primary_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<primary_expression_node> = (n_, s);
    }

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    is_fold_expression: (this) -> bool = n*.is_fold_expression();
    is_identifier     : (this) -> bool = n*.is_identifier     ();
    is_id_expression  : (this) -> bool = n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = n*.is_expression_list();
    is_literal        : (this) -> bool = n*.is_literal        ();
    is_declaration    : (this) -> bool = n*.is_declaration    ();

    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();
    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();
    as_declaration    : (this) -> declaration     = (this.n*.get_declaration(), this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  ID expression
//
id_expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<id_expression_node> = ();

    operator=: (
        out this,
        n_: *id_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<id_expression_node> = (n_, s);
    }

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    is_fold_expression: (this) -> bool = n*.is_fold_expression      ();
    is_empty          : (this) -> bool = n*.is_empty                ();
    is_identifier     : (this) -> bool = n*.is_identifier           ();
    is_qualified      : (this) -> bool = n*.is_qualified            ();
    is_unqualified    : (this) -> bool = n*.is_unqualified          ();

    as_identifier     : (this) -> std::string    = n*.get_identifier()*.to_string();
    as_qualified      : (this) -> qualified_id   = (n*.get_qualified_id(),   this);
    as_unqualified    : (this) -> unqualified_id = (n*.get_unqualified_id(), this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  General expression
//
expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<expression_node> = ();

    operator=: (
        out this,
        n_: *expression_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_node> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = n*.is_fold_expression      ();
    is_standalone_expression: (this) -> bool = n*.is_standalone_expression();
    subexpression_count     : (this) -> int  = n*.subexpression_count     ();
    is_identifier           : (this) -> bool = n*.is_identifier           ();
    is_id_expression        : (this) -> bool = n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = n*.is_expression_list      ();
    is_empty_expression_list: (this) -> bool = n*.is_empty_expression_list();
    is_literal              : (this) -> bool = n*.is_literal              ();
    is_assignment_expression: (this) -> bool = n*.is_assignment_expression();

    is_simple_assignment    : (this) -> bool = {
        ret := n*.get_lhs_rhs_if_simple_assignment();
        return ret.lhs && ret.rhs;
    }

    get_lhs_rhs_if_simple_assignment: (this)
        -> (
            lhs: postfix_expression,
            rhs: logical_or_expression
        )
    = {
        ret := n*.get_lhs_rhs_if_simple_assignment();
        lhs = (ret.lhs, this);
        rhs = (ret.rhs, this);
    }

    as_assignment_expression: (this) -> assignment_expression = (n*.get_assignment_expression(), this);
    as_expression_list      : (this) -> expression_list       = (n*.get_expression_list(), this);
    as_literal              : (this) -> std::string           = n*.get_literal()*.to_string();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  is_as_expression
//
is_as_expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<is_as_expression_node> = ();

    operator=: (
        out this,
        n_: *is_as_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<is_as_expression_node> = (n_, s);
    }

    term_t: @copy_constructible type = {
        op:   std::string;
        expr: expression;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; expr = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_expr: (this) -> expression  = expr;
    }

    get_expression: (this) -> prefix_expression = (n*.expr.get(), this);

    get_terms: (this) -> _ = {
        ret: std::vector<term_t> = ();
        for this.n*.ops do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
        return ret;
    }

    is_fold_expression: (this) -> bool = this.n*.is_fold_expression();
    is_identifier     : (this) -> bool = this.n*.is_identifier     ();
    is_id_expression  : (this) -> bool = this.n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = this.n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = this.n*.is_expression_list();
    is_literal        : (this) -> bool = this.n*.is_literal        ();

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();

    get_identifier    : (this) -> std::string_view = {
        ptok := this.n*.get_identifier();
        if ptok { return ptok*; }
        return "";
    }

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//
//  Statements
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  General statement
//
statement: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<statement_node> = ();

    operator=: (
        out this,
        n_: *statement_node,
        s : compiler_services
    )
    = {
        reflection_base<statement_node> = (n_, s);
    }

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    is_expression_statement : (this) -> bool = n*.is_expression();
    is_compound_statement   : (this) -> bool = n*.is_compound();
    is_selection_statement  : (this) -> bool = n*.is_selection();
    is_declaration          : (this) -> bool = n*.is_declaration();
    is_return_statement     : (this) -> bool = n*.is_return();
    is_iteration_statement  : (this) -> bool = n*.is_iteration();
    is_using_statement      : (this) -> bool = n*.is_using();
    is_contract             : (this) -> bool = n*.is_contract();
    is_inspect_expression   : (this) -> bool = n*.is_inspect();
    is_jump_statement       : (this) -> bool = n*.is_jump();

    as_expression_statement : (this) -> expression_statement  = (n*.get_if<expression_statement_node>(), this);
    as_compound_statement   : (this) -> compound_statement    = (n*.get_if<compound_statement_node>(), this);
    as_selection_statement  : (this) -> selection_statement   = selection_statement  (n*.get_if<selection_statement_node>(), this);
    as_declaration          : (this) -> declaration           = declaration(n*.get_if<declaration_node>(), this);
    as_return_statement     : (this) -> return_statement      = return_statement     (n*.get_if<return_statement_node>(), this);
    as_iteration_statement  : (this) -> iteration_statement   = iteration_statement  (n*.get_if<iteration_statement_node>(), this);
    //as_using_statement      : (this) -> using_statement       = using_statement      (n*.get_if<using_statement_node>(), this);
    //as_contract             : (this) -> contract              = contract             (n*.get_if<contract_node>(), this);
    //as_inspect_expression   : (this) -> inspect_expression    = inspect_expression   (n*.get_if<inspect_expression_node>(), this);
    //as_jump_statement       : (this) -> jump_statement        = jump_statement       (n*.get_if<jump_statement_node>(), this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Expression statements
//
expression_statement: @copy_constructible type =
{
    this: reflection_base<expression_statement_node> = ();

    operator=: (
        out this,
        n_: *expression_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_statement_node> = (n_, s);
    }

    get_expression: (this) -> expression  = (n*.expr.get(), this);

    to_string     : (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Compound statements
//
compound_statement: @copy_constructible type =
{
    this: reflection_base<compound_statement_node> = ();

    operator=: (
        out this,
        n_: *compound_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<compound_statement_node> = (n_, s);
    }

    get_statements: (this)
        -> std::vector<statement>
    = {
        ret: std::vector<statement> = ();
        for n*.get_statements() do (stmt) {
            _ = ret.emplace_back( stmt, this );
        }
        return ret;
    }

    add_statement: (inout this, source: std::string_view, before_position: int = 0)
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        require( n*.add_statement(move stmt, before_position),
                 std::string("unexpected error while attempting to add statement:\n") + source );
    }
}


//-----------------------------------------------------------------------
//  Selection statements
//
selection_statement: @copy_constructible type =
{
    this: reflection_base<selection_statement_node> = ();

    operator=: (
        out this,
        n_: *selection_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<selection_statement_node> = (n_, s);
    }

    has_false_branch_in_source_code: (this) -> bool = n*.has_false_branch_in_source_code();
    has_false_branch               : (this) -> bool = n*.has_false_branch();

    get_identifier  : (this) -> std::string_view      = n*.get_identifier()*.as_string_view();
    get_expression  : (this) -> logical_or_expression = (n*.get_expression  (), this);
    get_true_branch : (this) -> compound_statement    = (n*.get_true_branch (), this);
    get_false_branch: (this) -> compound_statement    = (n*.get_false_branch(), this);
}


//-----------------------------------------------------------------------
//  Return statements
//
return_statement: @copy_constructible type =
{
    this: reflection_base<return_statement_node> = ();

    operator=: (
        out this,
        n_: *return_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<return_statement_node> = (n_, s);
    }

    has_expression: (this) -> bool       = n*.has_expression();

    get_expression: (this) -> expression = (n*.get_expression(), this);
}


//-----------------------------------------------------------------------
//  Iteration statements - for, do, while
//
iteration_statement: @copy_constructible type =
{
    this: reflection_base<iteration_statement_node> = ();

    operator=: (
        out this,
        n_: *iteration_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<iteration_statement_node> = (n_, s);
    }

    is_do   : (this) -> bool = n*.is_do   ();
    is_while: (this) -> bool = n*.is_while();
    is_for  : (this) -> bool = n*.is_for  ();
    has_next: (this) -> bool = n*.has_next();

    get_label             : (this) -> std::string           = n*.get_label().to_string();
    get_next_expression   : (this) -> assignment_expression = (n*.get_next_expression(),    this);
    get_do_while_condition: (this) -> logical_or_expression = (n*.get_do_while_condition(), this);
    get_do_while_body     : (this) -> compound_statement    = (n*.get_do_while_body(),      this);
    get_for_range         : (this) -> expression            = (n*.get_for_range(),          this);
    get_for_parameter     : (this) -> parameter_declaration = (n*.get_for_parameter(),      this);
    get_for_body          : (this) -> statement             = (n*.get_for_body(),           this);
}


//-----------------------------------------------------------------------
//
//  Metafunctions - these are hardwired for now until we get to the
//  step of writing a Cpp2 interpreter to run inside the compiler
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Some common metafunction helpers (metafunctions are just functions,
//  so they can be factored as usual)
//
add_virtual_destructor: (inout t: meta::type_declaration) =
{
    t.add_member( "operator=: (virtual move this) = { }");
}


//-----------------------------------------------------------------------
//
//      "... an abstract base class defines an interface ..."
//
//          -- Stroustrup (The Design and Evolution of C++, 12.3.1)
//
//-----------------------------------------------------------------------
//
//  interface
//
//  an abstract base class having only pure virtual named functions,
//  a public default constructor, a public virtual destructor, and
//  protected copy/move operations
//
interface: (inout t: meta::type_declaration) =
{
    has_dtor := false;

    for t.get_members() do (inout m)
    {
        m.require( !m.is_object(),
                   "interfaces may not contain data objects");
        if m.is_function() {
            mf := m.as_function();
            mf.require( !mf.is_copy_or_move(),
                        "interfaces may not copy or move; consider a virtual clone() instead");
            mf.require( !mf.has_initializer(),
                        "interface functions must not have a function body; remove the '=' initializer");
            mf.require( mf.make_public(),
                        "interface functions must be public");
            mf.default_to_virtual();
            has_dtor |= mf.is_destructor();
        }
    }

    //  Add public default constructor + protected copy/move operations
    t.add_member( "operator=: (out this) = { }");
    t.add_member( "protected operator=: (out this, that) = { }");

    //  Add public virtual destructor
    if !has_dtor {
        t.add_virtual_destructor();
    }
}


//-----------------------------------------------------------------------
//
//     "C.35: A base class destructor should be either public and
//      virtual, or protected and non-virtual."
//
//          -- Stroustrup, Sutter, et al. (C++ Core Guidelines)
//
//-----------------------------------------------------------------------
//
//  polymorphic_base
//
//  A polymorphic base type whose destructor is either public and virtual
//  or else protected and nonvirtual.
//
//  Unlike an interface, it can have nonpublic and nonvirtual functions.
//
polymorphic_base: (inout t: meta::type_declaration) =
{
    has_dtor := false;

    for t.get_member_functions() do (inout mf)
    {
        if mf.is_default_access() {
            mf.default_to_public();
        }
        mf.require( !mf.is_copy_or_move(),
                    "polymorphic base types may not copy or move; consider a virtual clone() instead");
        if mf.is_destructor() {
            has_dtor = true;
            mf.require( ((mf.is_public() || mf.is_default_access()) && mf.is_virtual())
                        || (mf.is_protected() && !mf.is_virtual()),
                        "a polymorphic base type destructor must be public and virtual, or protected and nonvirtual");
        }
    }

    if !has_dtor {
        t.add_virtual_destructor();
    }
}


//-----------------------------------------------------------------------
//
//     "... A totally ordered type ... requires operator<=> that
//      returns std::strong_ordering. If the function is not
//      user-written, a lexicographical memberwise implementation
//      is generated by default..."
//
//          -- P0707R4, section 3
//
//      Note: This feature derived from Cpp2 was already adopted
//            into Standard C++ via paper P0515, so most of the
//            heavy lifting is done by the Cpp1 C++20/23 compiler,
//            including the memberwise default semantics
//            (In contrast, cppfront has to do the work itself for
//            default memberwise semantics for operator= assignment
//            as those aren't yet part of Standard C++)
//
//-----------------------------------------------------------------------
//

ordered_impl: (
    inout t:  meta::type_declaration,
    ordering: std::string_view  // must be "strong_ordering" etc.
) =
{
    has_spaceship := false;

    for t.get_member_functions() do (inout mf)
    {
        if mf.has_name("operator<=>") {
            has_spaceship = true;
            return_name := mf.get_unnamed_return_type();
            if return_name.find(ordering) == return_name.npos
            {
                mf.error( "operator<=> must return std::" + ordering as std::string );
            }
        }
    }

    if !has_spaceship {
        t.add_member( "operator<=>: (this, that) -> std::" + (ordering as std::string) + ";" );
    }
}

//-----------------------------------------------------------------------
//  ordered - a totally ordered type
//
//  Note: the ordering that should be encouraged as default gets the nice name
//
ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "strong_ordering" );
}

//-----------------------------------------------------------------------
//  weakly_ordered - a weakly ordered type
//
weakly_ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "weak_ordering" );
}

//-----------------------------------------------------------------------
//  partially_ordered - a partially ordered type
//
partially_ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "partial_ordering" );
}


//-----------------------------------------------------------------------
//
//     "A value is ... a regular type. It must have all public
//      default construction, copy/move construction/assignment,
//      and destruction, all of which are generated by default
//      if not user-written; and it must not have any protected
//      or virtual functions (including the destructor)."
//
//          -- P0707R4, section 3
//
//-----------------------------------------------------------------------
//
//  copyable
//
//  A type with (copy and move) x (construction and assignment)
//
copyable: (inout t: meta::type_declaration) =
{
    //  If the user explicitly wrote any of the copy/move functions,
    //  they must also have written the most general one - we can't
    //  assume we can safely generate it for them since they've opted
    //  into customized semantics
    smfs := t.query_declared_value_set_functions();
    if  !smfs.out_this_in_that
        && (
            smfs.out_this_move_that
            || smfs.inout_this_in_that
            || smfs.inout_this_move_that
        )
    {
        t.error(
            "this type is partially copyable/movable - when you provide "
            "any of the more-specific operator= signatures, you must also provide "
            "the one with the general signature (out this, that); alternatively, "
            "consider removing all the operator= functions and let them all be "
            "generated for you with default memberwise semantics"
        );
    }
    else if !smfs.out_this_in_that {
        t.add_member( "operator=: (out this, that) = { }");
    }
}


//  copy_constructible
//
//  A type with (copy and move) construction
//
copy_constructible: (inout t: meta::type_declaration) =
{
    //  If the user explicitly wrote any of the copy/move constructors,
    //  they must also have written the most general one - we can't
    //  assume we can safely generate it for them since they've opted
    //  into customized semantics
    smfs := t.query_declared_value_set_functions();
    if  !smfs.out_this_in_that
        && smfs.out_this_move_that
    {
        t.error(
            "this type is partially copy/move constructible - when you provide "
            "the (out this, move that) operator= signature, you must also provide "
            "the one with the general signature (out this, that)"
        );
    }
    else if
        !smfs.out_this_in_that
        && !smfs.out_this_move_that
    {
        t.add_member( "operator=: (out this,      that) = { }");
        t.add_member( "operator=: (out this, move that) = { }");
    }
}


//-----------------------------------------------------------------------
//
//  hashable
//
//  A memberwise hashable type
//
hashable: (inout t: meta::type_declaration) =
{
    t.require( !t.get_member_objects().empty(),
               "a hashable type must have at least one data member");

    hash: std::string = "    hash: (this) -> size_t = {\n"
                        "        ret: size_t = 0;";

    for  t.get_member_objects()
    do   (o)
    {
        o_hash: std::string;
        if o.name() == "this" {
            o_hash = "(o.type())$::hash()";
        }
        else {
            o_hash = "std::hash<(o.type())$>()((o.name())$)";
        }

        hash += "\n        cpp2::hash_combine( ret, (o_hash)$ );";
    }

    t.add_member(hash + "\n        return ret;\n    }");
}


//-----------------------------------------------------------------------
//
//  basic_value
//
//  A regular type: copyable, plus has public default construction
//  and no protected or virtual functions
//
basic_value: (inout t: meta::type_declaration) =
{
    t.copyable();

    has_default_ctor := false;
    for t.get_member_functions() do (inout mf) {
        has_default_ctor |= mf.is_default_constructor();
        mf.require( !mf.is_protected() && !mf.is_virtual(),
                    "a value type may not have a protected or virtual function");
        mf.require( !mf.is_destructor() || mf.is_public() || mf.is_default_access(),
                    "a value type may not have a non-public destructor");
    }

    if !has_default_ctor {
        t.add_member( "operator=: (out this) = { }");
    }
}

//-----------------------------------------------------------------------
//
//     "A 'value' is a totally ordered basic_value..."
//
//          -- P0707R4, section 3
//
//  value - a value type that is totally ordered
//
//  Note: the ordering that should be encouraged as default gets the nice name
//
value: (inout t: meta::type_declaration) =
{
    t.ordered();
    t.basic_value();
}

weakly_ordered_value: (inout t: meta::type_declaration) =
{
    t.weakly_ordered();
    t.basic_value();
}

partially_ordered_value: (inout t: meta::type_declaration) =
{
    t.partially_ordered();
    t.basic_value();
}


//-----------------------------------------------------------------------
//
//     C.20: If you can avoid defining default operations, do
//
//     ##### Reason
//
//     It's the simplest and gives the cleanest semantics.
//
//     ...
//
//     This is known as "the rule of zero".
//
//          -- C++ Core Guidelines
//             C.20: If you can avoid defining any default operations, do
//             <https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero>
//
//-----------------------------------------------------------------------
//
//  cpp1_rule_of_zero
//
//  a type without declared copy/move/destructor functions
//
cpp1_rule_of_zero: (inout t: meta::type_declaration) =
{
    for t.get_member_functions() do (inout mf)
    {
        t.require( !mf.is_constructor_with_that()
                   && !mf.is_assignment_with_that()
                   && !mf.is_destructor(),
                   "the rule of zero requires no copy/move/destructor functions");
    }
    t.disable_member_function_generation();
}

//-----------------------------------------------------------------------
//
//     "By definition, a `struct` is a `class` in which members
//      are by default `public`; that is,
//
//      	struct s { ...
//
//      is simply shorthand for
//
//          class s { public: ...
//
//      ... Which style you use depends on circumstances and taste.
//      I usually prefer to use `struct` for classes that have all
//      data `public`."
//
//          -- Stroustrup (The C++ Programming Language, 3rd ed., p. 234)
//
//-----------------------------------------------------------------------
//
//  struct
//
//  a type with only public bases, objects, and functions,
//  no virtual functions, and no user-defined constructors
//  (i.e., no invariants) or assignment or destructors.
//
//  For GCC 10 compatibility, optionally allow passing struct<noforward>
//  that generates a memberwise constructor with a generic deduced
//  parameters instead of concrete forwarding parameters (mainly used
//  for cppfront internal use, so cppfront builds under GCC 10)
//
struct: (inout t: meta::type_declaration) =
{
    ctor_params: std::string = ();
    ctor_inits : std::string = ();

    found_member_without_initializer: = false;

    for t.get_members() do (inout m)
    {
        m.require( m.make_public(),
                   "all struct members must be public");
        if m.is_function() {
            mf := m.as_function();
            t.require( !mf.is_virtual(),
                       "a struct may not have a virtual function");
            t.require( !mf.has_name("operator="),
                       "a struct may not have a user-defined operator=");
        }
        else if m.is_object() {
            mo: = m.as_object();
            if mo.name() != "this" {
                if t.get_argument(0) == "noforward" {
                    ctor_params += "(mo.name())$_, ";
                }
                else {
                    ctor_params += "forward (mo.name())$_ : (mo.type())$, ";
                }
                ctor_inits  += "(mo.name())$ = (mo.name())$_; ";
            }
            else {
                ctor_inits += "(mo.type())$ = ((mo.initializer())$); ";
            }
            found_member_without_initializer |= !mo.has_initializer();
        }
    }
    t.cpp1_rule_of_zero();

    //  If we found any data members
    if !ctor_params.empty()
    {
        //  Then to enable construction from corresponding values
        //  requires a constructor... an exception to the rule of zero
        t.add_member("    operator=: (implicit out this, (ctor_params)$) = { (ctor_inits)$ }");

        //  And if all members had initializers, we need a default constructor
        if !found_member_without_initializer {
            t.add_member("    operator=: (implicit out this) = { }");
        }
    }
}


//-----------------------------------------------------------------------
//
//     "C enumerations constitute a curiously half-baked concept. ...
//      the cleanest way out was to deem each enumeration a separate type."
//
//          -- Stroustrup (The Design and Evolution of C++, 11.7)
//
//     "An enumeration is a distinct type ... with named constants"
//
//          -- ISO C++ Standard
//
//-----------------------------------------------------------------------
//
//  basic_enum
//
//  a type together with named constants that are its possible values
//
value_member_info: @struct<noforward> type = {
    name  : std::string;
    type  : std::string;
    value : std::string;
}

basic_enum: (
    inout t : meta::type_declaration,
    nextval ,
    bitwise : bool
    )
= {
    enumerators     : std::vector<value_member_info> = ();
    min_value       : i64                            = ();
    max_value       : i64                            = ();
    underlying_type : std::string;

    t..reserve_names( "operator=", "operator<=>" );
    if bitwise {
        t..reserve_names( "has", "set", "clear", "to_string", "get_raw_value", "none" );
    }

    //  1. Gather: The names of all the user-written members, and find/compute the type

    underlying_type = t.get_argument(0);    // use the first template argument, if there was one

    found_non_numeric := false;

    (copy value: std::string = "-1")
    for  t.get_members()
    do   (m)
    if   m.is_member_object()
    {
        m.require( m.is_public() || m.is_default_access(),
                    "an enumerator cannot be protected or private");

        mo := m.as_object();
        if !mo.has_wildcard_type() {
            mo.error(
                "an explicit underlying type should be specified as a compile-time argument "
                "to the metafunction - try 'enum<u16>' or 'flag_enum<u64>'"
            );
        }

        init := mo.initializer();

        is_default_or_numeric := is_empty_or_a_decimal_number(init);
        found_non_numeric |= !init.empty() && !is_default_or_numeric;
        m.require( !is_default_or_numeric || !found_non_numeric || mo.has_name("none"),
            "(mo.name())$: enumerators with non-numeric values must come after all default and numeric values");

        nextval( value, init );

        v := std::strtoll(value[0]&, nullptr, 10);  // for non-numeric values we'll just get 0 which is okay for now
        if v < min_value {
            min_value = v;
        }
        if v > max_value {
            max_value = v;
        }

        //  Adding local variable 'e' to work around a Clang warning
        e: value_member_info = ( mo.name() as std::string, "", value );
        enumerators.push_back( e );

        mo.mark_for_removal_from_enclosing_type();
        _ = mo;
    }

    if (enumerators.empty()) {
        t.error( "an enumeration must contain at least one enumerator value");
        return;
    }

    //  Compute the default underlying type, if it wasn't explicitly specified
    if underlying_type == ""
    {
        t.require( !found_non_numeric,
            "if you write an enumerator with a non-numeric-literal value, "
            "you must specify the enumeration's underlying type"
        );

        if !bitwise {
            if min_value >= std::numeric_limits<i8>::min() && max_value <= std::numeric_limits<i8>::max() {
                underlying_type = "i8";
            }
            else if min_value >= std::numeric_limits<i16>::min() && max_value <= std::numeric_limits<i16>::max() {
                underlying_type = "i16";
            }
            else if min_value >= std::numeric_limits<i32>::min() && max_value <= std::numeric_limits<i32>::max() {
                underlying_type = "i32";
            }
            else if min_value >= std::numeric_limits<i64>::min() && max_value <= std::numeric_limits<i64>::max() {
                underlying_type = "i64";
            }
            else {
                t.error(
                    "values are outside the range representable by the "
                    "largest supported underlying signed type (i64)"
                );
            }
        }
        else {
            umax := max_value * 2 as u64;
            if umax <= std::numeric_limits<u8>::max() {
                underlying_type = "u8";
            }
            else if umax <= std::numeric_limits<u16>::max() {
                underlying_type = "u16";
            }
            else if umax <= std::numeric_limits<u32>::max() {
                underlying_type = "u32";
            }
            else {
                underlying_type = "u64";
            }
        }
    }


    //  2. Replace: Erase the contents and replace with modified contents
    //
    //  Note that most values and functions are declared as '==' compile-time values, i.e. Cpp1 'constexpr'

    t.remove_marked_members();

    //  Generate the 'none' value if appropriate, and use that or
    //  else the first enumerator as the default-constructed value
    default_value := enumerators[0].name;
    if bitwise{
        default_value = "none";
        e: value_member_info = ( "none", "", "0");
        enumerators.push_back( e );
    }

    //  Generate all the private implementation
    t.add_member( "    _value            : (underlying_type)$;");
    t.add_member( "    private operator= : (implicit out this, _val: i64) == "
                                            "_value = cpp2::unchecked_narrow<(underlying_type)$>(_val);");

    //  Generate the bitwise operations
    if bitwise {
        t.add_member( "    operator|=: ( inout this, that )                 == _value |= that._value;");
        t.add_member( "    operator&=: ( inout this, that )                 == _value &= that._value;");
        t.add_member( "    operator^=: ( inout this, that )                 == _value ^= that._value;");
        t.add_member( "    operator| : (       this, that ) -> (t.name())$  == _value |  that._value;");
        t.add_member( "    operator& : (       this, that ) -> (t.name())$  == _value &  that._value;");
        t.add_member( "    operator^ : (       this, that ) -> (t.name())$  == _value ^  that._value;");
        t.add_member( "    has       : (       this, that ) -> bool         == _value &  that._value;");
        t.add_member( "    set       : ( inout this, that )                 == { _value |= that._value;  }");
        t.add_member( "    clear     : ( inout this, that )                 == { _value &= that._value~; }");
    }

    //  Add the enumerators
    for enumerators do (e) {
        t.add_member( "    (e.name)$ : (t.name())$ == (e.value)$;");
    }

    //  Generate the common functions
    t.add_member( "    get_raw_value     : (this) -> (underlying_type)$ == _value;");
    t.add_member( "    operator=         : (out this) == { _value = (default_value)$._value; }");
    t.add_member( "    operator=         : (out this, that) == { }");
    t.add_member( "    operator<=>       : (this, that) -> std::strong_ordering;");

    //  Provide 'to_string' and 'to_code' functions to print enumerator
    //  name(s) as human-readable strings or as code expressions
    (copy to_string_impl: std::string = "    to_string_impl: (this, prefix: std::string_view")
    {
        if bitwise {
            to_string_impl += ", separator: std::string_view ) -> std::string = { \n"
                              "    ret : std::string = \"(\";\n"
                              "    sep : std::string = ();\n"
                              "    if this == none { return \"(none)\"; }\n";
        }
        else {
            to_string_impl += ") -> std::string = { \n";
        }

        to_string_impl += "    pref := cpp2::to_string(prefix);\n";

        for  enumerators
        do   (e) {
            if e.name != "_" {  // ignore unnamed values
                if bitwise {
                    if e.name != "none" {
                        to_string_impl += "    if (this & (t.name())$::(e.name)$) == (t.name())$::(e.name)$ { "
                                                  "ret += sep + pref + \"(e.name)$\"; sep = separator; "
                                              "}\n";
                    }
                }
                else {
                    to_string_impl += "    if this == (t.name())$::(e.name)$ { return pref + \"(e.name)$\"; }\n";
                }
            }
        }

        if bitwise {
            to_string_impl += "    return ret+\")\";\n}\n";
        }
        else {
            to_string_impl += "    return \"invalid (t.name())$ value\";\n}\n";
        }

        t.add_member( to_string_impl );
    }

    if bitwise {
        t.add_member( "    to_string: (this) -> std::string = to_string_impl( \"\", \", \" );" );
        t.add_member( "    to_code  : (this) -> std::string = to_string_impl( \"(t.name())$::\", \" | \" );" );
    }
    else {
        t.add_member( "    to_string: (this) -> std::string = to_string_impl( \"\" );" );
        t.add_member( "    to_code  : (this) -> std::string = to_string_impl( \"(t.name())$::\" );" );
    }

    //  Provide a 'from_string' function to parse strings into enumerators
    (copy from_string: std::string = "    from_string: (s: std::string_view) -> (t.name())$ = { \n")
    {
        prefix    : std::string_view = "";
        combine_op: std::string_view = "return";

        //  For flags, accept a list that we break apart and then |= together
        if bitwise
        {
            prefix      = "flag_";
            combine_op  = "ret |=";

            from_string += "        ret := none;\n"
                           "        outer: do {\n"
                           "        for cpp2::string_util::split_string_list(s) do (x) {\n";
        }
        //  Otherwise, accept just a single string
        else {
            from_string += "        x := s;\n";
        }

        (copy else_: std::string_view = "")
        for  enumerators
        do   (e) {
            from_string += "            (else_)$if \"(e.name)$\" == x { (combine_op)$ (t.name())$::(e.name)$; }\n";
            else_ = "else ";
        }

        if bitwise {
            from_string += "            else { break outer; }\n"
                           "        }\n"
                           "        return ret;\n"
                           "        } while false;\n";
        }

        from_string += "        cpp2::type_safety.report_violation( (\"can't convert string '\" + cpp2::to_string(s) + \"' to (prefix)$enum of type (t.name())$\").c_str() );\n"
                       "        return (t.name())$::(default_value)$;\n"
                       "    }\n\n";

        t.add_member( from_string );
    }

    t.add_member( "    from_code: (s: std::string_view) -> (t.name())$ = { str: std::string = s; return from_string( cpp2::string_util::replace_all(str, \"(t.name())$::\", \"\" ) ); }" );
}


//-----------------------------------------------------------------------
//
//    "An enum[...] is a totally ordered value type that stores a
//     value of its enumerators's type, and otherwise has only public
//     member variables of its enumerator's type, all of which are
//     naturally scoped because they are members of a type."
//
//          -- P0707R4, section 3
//
enum: (inout t: meta::type_declaration) =
{
    //  Let basic_enum do its thing, with an incrementing value generator
    t.basic_enum(
        :(inout value: std::string, specified_value: std::string) = {
            if !specified_value.empty() {
                value = specified_value;
            } else {
                v := std::strtoll(value[0]&, nullptr, 10);
                value = (v + 1) as std::string;
            }
        },
        false   // disable bitwise operations
    );
}


//-----------------------------------------------------------------------
//
//     "flag_enum expresses an enumeration that stores values
//      corresponding to bitwise-or'd enumerators. The enumerators must
//      be powers of two, and are automatically generated [...] A none
//      value is provided [...] Operators | and & are provided to
//      combine and extract values."
//
//          -- P0707R4, section 3
//
flag_enum: (inout t: meta::type_declaration) =
{
    //  Let basic_enum do its thing, with a power-of-two value generator
    t.basic_enum(
        :(inout value: std::string, specified_value: std::string) = {
            if !specified_value.empty() {
                value = specified_value;
            } else {
                v := std::strtoll(value[0]&, nullptr, 10);
                if v < 1 {
                    value = "1";
                }
                else {
                    value = (v * 2) as std::string;
                }
            }
        },
        true    // enable bitwise operations
    );
}


//-----------------------------------------------------------------------
//
//     "As with void*, programmers should know that unions [...] are
//      inherently dangerous, should be avoided wherever possible,
//      and should be handled with special care when actually needed."
//
//          -- Stroustrup (The Design and Evolution of C++, 14.3.4.1)
//
//     "C++17 needs a type-safe union... The implications of the
//      consensus `variant` design are well understood and have been
//      explored over several LEWG discussions, over a thousand emails,
//      a joint LEWG/EWG session, and not to mention 12 years of
//      experience with Boost and other libraries."
//
//          -- Axel Naumann, in P0088 (wg21.link/p0088),
//             the adopted proposal for C++17 std::variant
//
//-----------------------------------------------------------------------
//
//  union
//
//  a type that contains exactly one of a fixed set of values at a time
//

union: (inout t : meta::type_declaration)
= {
    alternatives : std::vector<value_member_info> = ();

    //  1. Gather: All the user-written members, and find/compute the max size

    (copy value := 0)
    for   t.get_members()
    next  value++
    do    (m)
    if    m.is_member_object()
    {
        m.require( m.is_public() || m.is_default_access(),
                   "a union alternative cannot be protected or private"
                );

        m.require( !m.name().starts_with("is_")
                   && !m.name().starts_with("set_"),
                   "a union alternative's name cannot start with 'is_' or 'set_' - that could cause "
                   "user confusion with the 'is_alternative' and 'set_alternative' generated functions"
                );

        mo := m.as_object();
        mo.require( mo.initializer().empty(),
                    "a union alternative cannot have an initializer"
                );

        //  Adding local variable 'e' to work around a Clang warning
        e: value_member_info = ( mo.name() as std::string, mo.type(), value as std::string );
        alternatives.push_back( e );

        mo.mark_for_removal_from_enclosing_type();
        _ = mo;
    }

    discriminator_type: std::string = ();
    if alternatives.ssize() < std::numeric_limits<i8>::max() {
        discriminator_type = "i8";
    }
    else if alternatives.ssize() < std::numeric_limits<i16>::max() {
        discriminator_type = "i16";
    }
    else if alternatives.ssize() < std::numeric_limits<i32>::max() {
        discriminator_type = "i32";
    }
    else {
        discriminator_type = "i64";
    }


    //  2. Replace: Erase the contents and replace with modified contents

    t.remove_marked_members();

    //  Provide storage
    (copy storage: std::string = "    _storage: cpp2::aligned_storage<cpp2::max( ")
    {
        for  alternatives
        do   (e) {
            storage += "sizeof((e.type)$), ";
        }

        storage += "), cpp2::max( ";

        for  alternatives
        do   (e) {
            storage += "alignof((e.type)$), ";
        }

        storage += " )> = ();\n";
        t.add_member( storage );
    }

    //  Provide discriminator
    t.add_member( "    _discriminator: (discriminator_type)$ = -1;\n");

    //  Add the alternatives: is_alternative, get_alternative, and set_alternative
    for alternatives
    do  (a)
    {
        t.add_member( "    is_(a.name)$: (this) -> bool = _discriminator == (a.value)$;\n");

        t.add_member( "    (a.name)$: (this) -> forward (a.type)$ pre(is_(a.name)$()) = "
                            "reinterpret_cast<* const (a.type)$>(_storage&)*;\n"
                    );

        t.add_member( "    (a.name)$: (inout this) -> forward (a.type)$ pre(is_(a.name)$()) = "
                            "reinterpret_cast<*(a.type)$>(_storage&)*;\n"
                    );

        t.add_member( "    set_(a.name)$: (inout this, _value: (a.type)$) = { "
                            "if !is_(a.name)$() { _destroy(); std::construct_at( reinterpret_cast<*(a.type)$>(_storage&), _value); } "
                            "else { reinterpret_cast<*(a.type)$>(_storage&)* = _value; } "
                            "_discriminator = (a.value)$; "
                            "}\n"
                    );

        t.add_member( "    set_(a.name)$: (inout this, forward _args...: _) = { "
                            "if !is_(a.name)$() { _destroy(); std::construct_at( reinterpret_cast<*(a.type)$>(_storage&), _args...); } "
                            " else { reinterpret_cast<*(a.type)$>(_storage&)* = :(a.type)$ = (_args...); } "
                            "_discriminator = (a.value)$; "
                            "}\n"
                    );
    }

    //  Add destroy
    (copy destroy: std::string = "    private _destroy: (inout this) = {\n")
    {
        for  alternatives
        do   (a) {
            destroy += "        if _discriminator == (a.value)$ { std::destroy_at( reinterpret_cast<*(a.type)$>(_storage&) ); }\n";
        }

        destroy += "        _discriminator = -1;\n"
                   "    }\n";
        t.add_member( destroy );
    }

    //  Add the destructor
    t.add_member( "    operator=: (move this) = { _destroy(); _ = this; }" );

    //  Add default constructor
    t.add_member( "    operator=: (out this) = { }" );

    //  Add copy/move construction and assignment
    (copy value_set: std::string = "")
    {
        for  alternatives
        do   (a) {
            value_set += "        if that.is_(a.name)$() { set_(a.name)$( that.(a.name)$() ); }\n";
        }
        value_set += "    }\n";

        t.add_member( "    operator=: (out this, that) = {\n"
                      "        _storage = ();\n"
                      "        _discriminator = -1;\n"
                      + value_set
                    );
        t.add_member( "    operator=: (inout this, that) = {\n"
                      "        _storage = _;\n"
                      "        _discriminator = _;\n"
                      + value_set
                    );
    }
}


//-----------------------------------------------------------------------
//
//  encapsulated
//
//  A type with no public data members
//
encapsulated: (inout t: meta::type_declaration) =
{
    for t.get_member_objects()
    do  (m)
    {
        m.require(
            !m.is_public(),
            "an @encapsulated type must not have public data members"
        );
    }
}


//-----------------------------------------------------------------------
//
//  noncopyable
//
//  A type with no copy/move construction/assignment
//
noncopyable: (inout t: meta::type_declaration) =
{
    smfs := t.query_declared_value_set_functions();
    t.require(
        !smfs.out_this_in_that
        && !smfs.out_this_move_that
        && !smfs.inout_this_in_that
        && !smfs.inout_this_move_that,
        "a @noncopyable type must not have operator= with this and that parameters"
    );
}


//-----------------------------------------------------------------------
//
//  singleton
//
//  An encapsulated noncopyable type with a single instance accessed via
//  an ::instance() function
//
//  A private default constructor is provided.
//
singleton: (inout t: meta::type_declaration) =
{
    t.noncopyable();
    t.encapsulated();

    for t.get_member_functions()
    do  (m)
    {
        m.require(
            !m.is_constructor(),
            "a @singleton type must not have a user-written constructor - "
            "a private default constructor will be generated automatically"
        );
    }

    t.add_member( "    private operator=: (out this) = { }\n" );
    t.add_member( "    instance: () -> forward (t.name())$ = {\n"
                  "        static _instance: (t.name())$ = ();"
                  "        return _instance;\n"
                  "    }\n" );
}


//-----------------------------------------------------------------------
//
//  print - output a pretty-printed visualization of t
//
print: (t: meta::type_declaration) =
{
    std::cout << t.print() << "\n";
}


//-----------------------------------------------------------------------
//
//  noisy - make each function print its name and signature,
//          so the programmer can see what's called
//
noisy: (t: meta::type_declaration) =
{
    for t.get_members()
    do  (m)
    if  m.is_function()
        && !m.has_name("operator=")
    {
        mf := m.as_function();
        if mf.has_compound_body() {
            body := mf.get_compound_body();
            body.add_statement( "    std::cout << \"(mf.get_signature())$\\n\";" );
            _ = body;
        }
    }
}


//-----------------------------------------------------------------------
//
//  python - expose the type using pybind11
//
//  *** Basic proof of concept only, limited and not well tested
//      Hardcoded for pybind11 and g++10 and my local cppfront include path
//
python_param_names_and_types: (mf: meta::function_declaration)
    ->
    (
    names: std::string = (),
    types: std::string = ()
    )
= {
    for mf.get_parameters()
    do  (param)
    if  param.get_declaration().name() != "this"
    {
        names += ", ";
        if !types.empty() {
            types += ", ";
        }
        names += std::string("pybind11::arg(\"") + param.get_declaration().name() + "\")";
        types += param.get_declaration().type();
    }
    // TODO: Remove when fixed (https://github.com/hsutter/cppfront/issues/1426). Force newline for return.
    _ = names;
}

python: (inout t: meta::type_declaration) =
{
    bind: std::string = ();
    bind += "PYBIND11_MODULE((t.name())$lib, m) {\n";
    bind += "    pybind11::class_<(t.name())$>(m, \"(t.name())$\")\n";

    for t.get_members()
    do  (m)
    if  m.is_function()
    {
        mf := m.as_function();
        params := mf.python_param_names_and_types();

        if mf.is_constructor() {
            bind += "        .def(pybind11::init<(params.types)$>())\n";
        }
        else if !mf.has_name("operator=") {
            bind += "        .def(\"(mf.name())$\", &(t.name())$::(mf.name())$ (params.names)$)\n";
        }
    }

    bind += "    ;\n";
    bind += "}\n";

    file := t.filename();
    if file.ends_with(".cpp2") {
        file = file.substr(0, file.size()-5);    // drop the ".cpp2"
    }
    build: std::string = "g++-10 -O3 -shared -std=c++20 -fPIC $(python3 -m pybind11 --includes) (file)$.cpp -o (file)$lib$(python3-config --extension-suffix)";

    t.add_runtime_support_include( "pybind11/pybind11.h", true );
    t.add_runtime_support_include( "pybind11/stl.h", true );
    t.add_extra_cpp1_code        ( bind );
    t.add_extra_build_step       ( build );
}


//-----------------------------------------------------------------------
//
//  javascript - expose the type using emscripten
//
//  *** Basic proof of concept only, limited and not well tested
//
javascript: (inout t: meta::type_declaration) =
{
    bind: std::string = ();
    bind += "using namespace emscripten;\n";
    bind += "EMSCRIPTEN_BINDINGS((t.name())$_module) {\n";
    bind += "    class_<(t.name())$>(\"(t.name())$\")\n";

    for t.get_members()
    do  (m)
    if  m.is_function()
    {
        mf := m.as_function();
        params := mf.python_param_names_and_types(); // good enough! only care about .types

        if mf.is_constructor() {
            bind += "        .constructor<(params.types)$>()\n";
        }
        else if !mf.has_name("operator=") {
            bind += "        .function(\"(mf.name())$\", &(t.name())$::(mf.name())$)\n";
        }
    }

    bind += "    ;\n";
    bind += "}\n";

    file := t.filename();
    if file.ends_with(".cpp2") {
        file = file.substr(0, file.size()-5);    // drop the ".cpp2"
    }
    build: std::string = "em++ -std=c++20 -O3 (file)$.cpp --bind -s MODULARIZE=1 -s ENVIRONMENT='web,node' -s ALLOW_MEMORY_GROWTH=1 -s FILESYSTEM=0 -s LEGACY_VM_SUPPORT=1 -o (file)$.js";
    t.add_runtime_support_include( "emscripten/bind.h", true );
    t.add_extra_cpp1_code        ( bind );
    t.add_extra_build_step       ( build );
    t.disable_ref_qualifier_generation();
}


//-----------------------------------------------------------------------
//
//  For reflection test cases
//
sample_print: (s: std::string_view, indent: i32) =
{
    std::cout
        << pre(indent)
        << s
        << "\n";
}

simple_traverser: type = {

    pre_traverse: (virtual inout this, decl: meta::declaration) = {
        traverse(decl);
    }

    traverse: (virtual inout this, decl: meta::declaration) =
    {
        if decl.is_function() {
            pre_traverse(decl.as_function());
        }

        if decl.is_object() {
            pre_traverse(decl.as_object());
        }

        if decl.is_type() {
            pre_traverse(decl.as_type());
        }

        // ...
        // ... extend as desired to namespace, alias, etc.
        // ...
    }


    pre_traverse: (virtual inout this, f: meta::function_declaration) = {
        traverse(f);
    }

    traverse: (virtual inout this, f: meta::function_declaration) =
    {
        parameters := f.get_parameters();
        for parameters do (param) {
            pre_traverse(param);
        }

        returns := f.get_returns();
        for returns do (param) {
            pre_traverse(param);
        }

        if !f.has_compound_body() {
            pre_traverse(f.get_body());
        }
        else {
            pre_traverse(f.get_compound_body());
        }
    }


    pre_traverse: (virtual inout this, o: meta::object_declaration) = {
        traverse(o);
    }

    traverse: (virtual inout this, o: meta::object_declaration) =
    {
        if o.has_initializer() {
            pre_traverse(o.get_initializer());
        }
    }


    pre_traverse: (virtual inout this, t: meta::type_declaration) = {
        traverse(t);
    }

    traverse: (virtual inout this, t: meta::type_declaration) =
    {
        for t.get_members() do (m) {
            pre_traverse(m);
        }
    }


    pre_traverse: (virtual inout this, t: meta::parameter_declaration) = {
        traverse(t);
    }

    traverse: (virtual inout this, t: meta::parameter_declaration) =
    {
        pre_traverse(t.get_declaration());
    }

    pre_traverse: (virtual inout this, stmt: meta::statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::statement) =
    {
        if stmt.is_expression_statement() {
            pre_traverse(stmt.as_expression_statement().get_expression());
        }

        if stmt.is_compound_statement() {
            pre_traverse(stmt.as_compound_statement());
        }

        if stmt.is_selection_statement()
        {
            pre_traverse(stmt.as_selection_statement());
        }

        if stmt.is_declaration() {
            pre_traverse(stmt.as_declaration());
        }

        if stmt.is_return_statement() {
            pre_traverse(stmt.as_return_statement());
        }

        if stmt.is_iteration_statement() {
            pre_traverse(stmt.as_iteration_statement());
        }

        // TODO:
        //  using
        //  contract
        //  inspect
        //  jump
    }


    pre_traverse: (virtual inout this, stmt: meta::compound_statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::compound_statement) =
    {
        stmts := stmt.get_statements();

        for stmts do (cur) {
            pre_traverse(cur);
        }
    }


    pre_traverse: (virtual inout this, stmt: meta::return_statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::return_statement) =
    {
        if stmt.has_expression() {
            pre_traverse(stmt.get_expression());
        }
    }


    pre_traverse: (virtual inout this, stmt: meta::iteration_statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::iteration_statement) =
    {
        if stmt.is_do() || stmt.is_while() {
            pre_traverse(stmt.get_do_while_condition());
            pre_traverse(stmt.get_do_while_body());
        }
        else {
            assert(stmt.is_for());
            pre_traverse(stmt.get_for_range());
            pre_traverse(stmt.get_for_parameter());
            pre_traverse(stmt.get_for_body());
        }

        if stmt.has_next() {
            pre_traverse(stmt.get_next_expression());
        }
    }


    pre_traverse: (virtual inout this, stmt: meta::selection_statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::selection_statement) =
    {
        pre_traverse(stmt.get_expression());
        pre_traverse(stmt.get_true_branch());

        if stmt.has_false_branch() {
            pre_traverse(stmt.get_false_branch());
        }
    }


    pre_traverse: (virtual inout this, expr: meta::expression) =
    {
        // Nothing to select here.
        traverse(expr);
    }

    traverse: (virtual inout this, expr: meta::expression) =
    {
        //  An expression has other shortcuts to query deeper properties,
        //  but let's just traverse all the nested grammer elements to
        //  show how that traversal works

        // The expressions use the pre_traverse function to decide which expression
        // they are. The correct one calls traverse only once.

        //  The expression's basic payload is just an assignment expression
        pre_traverse(expr.as_assignment_expression());
    }


    pre_traverse: (virtual inout this, binexpr: meta::assignment_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual assignment,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::assignment_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::logical_or_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual logical-or,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::logical_or_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }


    pre_traverse: (virtual inout this, binexpr: meta::logical_and_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual logical-and,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::logical_and_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::bit_or_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual bit-or,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::bit_or_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::bit_xor_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual bit-xor,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::bit_xor_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }


    pre_traverse: (virtual inout this, binexpr: meta::bit_and_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual bit-and,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::bit_and_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }


    pre_traverse: (virtual inout this, binexpr: meta::equality_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual equality,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::equality_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::relational_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual relational,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::relational_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::compare_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual compare,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::compare_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::shift_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual shift,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::shift_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::additive_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual additive,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::additive_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }


    pre_traverse: (virtual inout this, binexpr: meta::multiplicative_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual multiplicative,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::multiplicative_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, isas: meta::is_as_expression) =
    {
        terms := isas.get_terms();

        //  If this has no additional terms, it's not an actual is-as,
        //  it's holding a lower grammar production so go traverse that
        if terms.empty() {
            pre_traverse(isas.get_expression());
        }

        //  Else we're at an actual is-as expression with a rhs
        else {
            traverse(isas);
        }
    }

    traverse: (virtual inout this, isas: meta::is_as_expression) =
    {
        terms := isas.get_terms();

        pre_traverse(isas.get_expression());

        for terms do (term) {
            traverse(term.get_expr());
        }
    }

    traverse: (virtual inout this, exprs: meta::expression_list) =
    {
        for exprs.get_expressions() do (expr) {
            traverse(expr);
        }
    }

    pre_traverse: (virtual inout this, prefix: meta::prefix_expression) =
    {
        ops := prefix.get_ops();

        //  If this has no additional ops, it's not a naked prefix expr,
        //  it's holding a lower grammar production so go traverse that
        if ops.empty() {
            pre_traverse(prefix.get_postfix_expression(),);
        }

        //  Else we're at an actual prefix expression with ops
        else {
            traverse(prefix);
        }
    }

    traverse: (virtual inout this, prefix: meta::prefix_expression) =
    {
        pre_traverse(prefix.get_postfix_expression());
    }

    pre_traverse: (virtual inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        //  If this has no additional terms, it's not a naked postfix expr,
        //  it's holding a lower grammar production so go traverse that
        if terms.empty() {
            traverse(postfix.get_primary_expression());
        }

        //  Else we're at an actual postfix expression with ops
        else {
            traverse(postfix);
        }
    }

    traverse: (virtual inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        traverse(postfix.get_primary_expression());

        for terms do (term) {
            if term.is_id_expression() {
                traverse(term.get_id_expression());
            }
            else if term.is_expression_list() {
                traverse(term.get_expression_list());
            }
            else if term.is_expression() {
                traverse(term.get_expression());
            }
        }
    }

    traverse: (virtual inout this, uid: meta::unqualified_id) =
    {
        _ = uid;
    }


    traverse: (virtual inout this, qid: meta::qualified_id) =
    {
        for qid.get_terms()
        do  (term)
        {
            traverse(term.get_unqualified());
        }
    }


    traverse: (virtual inout this, tid: meta::type_id) =
    {
        if tid.is_postfix_expression() {
            traverse(tid.as_postfix_expression());
        }
        else if tid.is_qualified_id() {
            traverse(tid.as_qualified_id());
        }
        else if tid.is_unqualified_id() {
            traverse(tid.as_unqualified_id());
        }
        else {
            // Regular type_id
        }
    }


    traverse: (virtual inout this, primary: meta::primary_expression) =
    {
        if primary.is_identifier() {
            // Regular identifier
        }
        else if primary.is_expression_list() {
            traverse(primary.as_expression_list());
        }
        else if primary.is_literal() {
            // Regular literal
        }
        else if primary.is_declaration() {
            // TODO: traverse(primary.as_declaration());
        }
        else {
            // Regular primary
        }
    }


    traverse: (virtual inout this, idexpr: meta::id_expression) =
    {
        if idexpr.is_identifier() {
            // Regular id
        }
        else if idexpr.is_qualified() {
            traverse(idexpr.as_qualified());
        }
        else if idexpr.is_unqualified() {
            traverse(idexpr.as_unqualified());
        }
        else {
            // Regular id expr
        }
    }
}


//-----------------------------------------------------------------------
//
//  sample_traverser serves two purposes:
//
//      - infrastructure for writing reflection API test cases
//
//      - a sample for how code can use the reflection API, notably
//        for reflecting on function bodies (statements, expressions)
//

sample_traverser: (decl: meta::declaration, indent: i32) =
{
    sample_print("Declaration: (decl.name())$", indent);

    if decl.is_function() {
        sample_traverser(decl.as_function(), indent+1);
    }

    if decl.is_object() {
        sample_traverser(decl.as_object(), indent+1);
    }

    if decl.is_type() {
        sample_traverser(decl.as_type(), indent+1);
    }

    // ...
    // ... extend as desired to namespace, alias, etc.
    // ...
}


sample_traverser: (f: meta::function_declaration, indent: i32 = 0) =
{
    sample_print("Function: (f.name())$", indent+1);

    parameters := f.get_parameters();
    if !parameters.empty() {
        sample_print("Parameters:", indent+2);
        for parameters do (param) {
            sample_traverser(param, indent+3);
        }
    }

    returns := f.get_returns();
    if !returns.empty() {
        sample_print("Returns:", indent+2);
        for returns do (param) {
            sample_traverser(param, indent+3);
        }
    }

    sample_print("Body:", indent+2);
    if !f.has_compound_body() {
        sample_traverser(f.get_body(), indent+3);
    }
    else {
        sample_traverser(f.get_compound_body(), indent+3);
    }
}


sample_traverser: (o: meta::object_declaration, indent: i32) =
{
    sample_print("Object: name (o.name())$, type (o.type())$", indent);
    if o.has_initializer() {
        sample_print("Initializer:", indent+1);
        sample_traverser(o.get_initializer(), indent+2);
    }
}


sample_traverser: (t: meta::type_declaration, indent: i32 = 0) =
{
    sample_print("Type: (t.name())$", indent);

    if t.parent_is_nonglobal_namespace()
    {
        ns := t.get_parent().as_nonglobal_namespace();
        sample_print("is a member of namespace (ns.name())$ which contains the following names:", indent+1);
        for ns.get_members() do (m) {
            sample_print(m.name(), indent+2);
        }
        ns.add_member( "add_1: (x) = x+1;");
        _ = ns;
    }

    for t.get_members() do (m) {
        sample_traverser(m, indent+1);
    }
}


sample_traverser: (t: meta::parameter_declaration, indent: i32 = 0) =
{
    sample_print("parameter:", indent);

    pass := t.get_passing_style();
    if pass == passing_style::in          { sample_print("passing style: in", indent+1 ); }
    if pass == passing_style::in_ref      { sample_print("passing style: in_ref", indent+1 ); }
    if pass == passing_style::copy        { sample_print("passing style: copy", indent+1 ); }
    if pass == passing_style::inout       { sample_print("passing style: inout", indent+1 ); }
    if pass == passing_style::out         { sample_print("passing style: out", indent+1 ); }
    if pass == passing_style::move        { sample_print("passing style: move", indent+1 ); }
    if pass == passing_style::forward     { sample_print("passing style: forward", indent+1 ); }
    if pass == passing_style::forward_ref { sample_print("passing style: forward_ref", indent+1 ); }

    sample_print("declaration:", indent+1);
    sample_traverser(t.get_declaration(), indent+2);
}


sample_traverser: (stmt: meta::statement, indent: i32) =
{
    params := stmt.get_parameters();
    if !params.empty() {
        sample_print("statement parameters: ", indent);
        for params do (param) {
            sample_traverser( param, indent+1 );
        }
    }

    if stmt.is_expression_statement() {
        sample_traverser(stmt.as_expression_statement().get_expression(), indent);
    }

    if stmt.is_compound_statement() {
        sample_traverser(stmt.as_compound_statement(), indent);
    }

    if stmt.is_selection_statement()
    {
        sel := stmt.as_selection_statement();
        sample_print("(sel.get_identifier())$ statement", indent);

        sample_print("condition:", indent+1);
        sample_traverser(sel.get_expression(), indent+2);

        sample_print("true branch:", indent+1);
        sample_traverser(sel.get_true_branch(), indent+2);

        if sel.has_false_branch() {
            sample_print("false branch:", indent+1);
            sample_traverser(sel.get_false_branch(), indent+2);
        }
    }

    if stmt.is_declaration() {
        sample_traverser(stmt.as_declaration(), indent+1);
    }

    if stmt.is_return_statement() {
        sample_traverser(stmt.as_return_statement(), indent+1);
    }

    if stmt.is_iteration_statement() {
        sample_traverser(stmt.as_iteration_statement(), indent+1);
    }

    // TODO:
    //  using
    //  contract
    //  inspect
    //  jump
}


sample_traverser: (stmt: meta::compound_statement, indent: i32) =
{
    stmts := stmt.get_statements();

    if stmts.empty() {
        sample_print("compound statement (empty)", indent);
        return;
    }

    // Else
    sample_print("compound statement", indent);
    for stmts do (stmt2) {
        sample_traverser(stmt2, indent+1);
    }
}


sample_traverser: (stmt: meta::return_statement, indent: i32) =
{
    sample_print("return statement", indent);
    if stmt.has_expression() {
        sample_print("expression", indent+1);
        sample_traverser(stmt.get_expression(), indent+2);
    }
}


sample_traverser: (stmt: meta::iteration_statement, indent: i32) =
{
    if stmt.is_do() || stmt.is_while() {
        if stmt.is_do() {
            sample_print("do loop:", indent);
        }
        else {
            sample_print("while loop:", indent);
        }
        sample_print("condition:", indent+1);
        sample_traverser(stmt.get_do_while_condition(), indent+2);
        sample_print("body:", indent+1);
        sample_traverser(stmt.get_do_while_body(), indent+2);
    }
    else {
        assert(stmt.is_for());
        sample_print("for loop:", indent);
        sample_print("range:", indent+1);
        sample_traverser(stmt.get_for_range(), indent+2);
        sample_print("parameter:", indent+1);
        sample_traverser(stmt.get_for_parameter(), indent+2);
        sample_print("body:", indent+1);
        sample_traverser(stmt.get_for_body(), indent+2);
    }

    if stmt.has_next() {
        sample_print("next expression:", indent+1);
        sample_traverser(stmt.get_next_expression(), indent+2);
    }
}


sample_traverser: (expr: meta::expression, indent: i32) =
{
    //  An expression has other shortcuts to query deeper properties,
    //  but let's just traverse all the nested grammar elements to
    //  show how that traversal works

    //  The expression's basic payload is just an assignment expression
    //  today - this can change when we add try-expressions
    if expr.is_assignment_expression() {
        sample_traverser(expr.as_assignment_expression(), indent);
    }
}


sample_traverser: (binexpr: meta::assignment_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual assignment,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("assignment", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::logical_or_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual logical-or,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("logical-or", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::logical_and_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual logical-and,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("logical-and", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::bit_or_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual bit-or,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("bit-or", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::bit_xor_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual bit-xor,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("bit-xor", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::bit_and_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual bit-and,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("bit-and", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::equality_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual equality,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("equality", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::relational_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual relational,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("relational", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::compare_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual compare,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("compare", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::shift_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual shift,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("shift", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::additive_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual additive,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("additive", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::multiplicative_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual multiplicative,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("multiplicative", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (isas: meta::is_as_expression, indent: i32) =
{
    terms := isas.get_terms();

    //  If this has no additional terms, it's not an actual is-as,
    //  it's holding a lower grammar production so go traverse that
    if terms.empty() {
        sample_traverser(isas.get_expression(), indent);
    }

    //  Else we're at an actual is-as expression with a rhs
    else {
        sample_print("is-as expression", indent);

        sample_print("expression", indent+1);
        sample_traverser(isas.get_expression(), indent+2);

        for terms do (term) {
            sample_print("op: (term.get_op())$", indent+1);
            sample_print("term:", indent+1);
            sample_traverser(term.get_expr(), indent+2);
        }
    }
}


sample_traverser: (exprs: meta::expression_list, indent: i32) =
{
    if exprs.is_empty() {
        sample_print("()", indent);
    }
    else {
        sample_print("(", indent);
        for exprs.get_expressions() do (expr) {
            sample_traverser(expr, indent+1);
        }
        sample_print(")", indent);
    }
}


sample_traverser: (prefix: meta::prefix_expression, indent: i32) =
{
    ops := prefix.get_ops();

    //  If this has no additional ops, it's not a naked prefix expr,
    //  it's holding a lower grammar production so go traverse that
    if ops.empty() {
        sample_traverser(prefix.get_postfix_expression(), indent);
    }

    //  Else we're at an actual prefix expression with ops
    else {
        sample_print("prefix expression", indent);

        for ops do (op) {
            sample_print("op: (op)$", indent+1);
        }

        sample_print("expression", indent+1);
        sample_traverser(prefix.get_postfix_expression(), indent+2);
    }
}


sample_traverser: (postfix: meta::postfix_expression, indent: i32) =
{
    terms := postfix.get_terms();

    //  If this has no additional terms, it's not a naked postfix expr,
    //  it's holding a lower grammar production so go traverse that
    if terms.empty() {
        sample_traverser(postfix.get_primary_expression(), indent);
    }

    //  Else we're at an actual postfix expression with ops
    else {
        sample_print("postfix expression", indent);

        sample_print("expression", indent+1);
        sample_traverser(postfix.get_primary_expression(), indent+2);

        for terms do (term) {
            sample_print("op: (term.get_op())$", indent+1);
            if term.is_id_expression() {
                sample_traverser(term.get_id_expression(), indent+1);
            }
            else if term.is_expression_list() {
                sample_traverser(term.get_expression_list(), indent+1);
            }
            else if term.is_expression() {
                sample_traverser(term.get_expression(), indent+1);
            }
        }
    }
}


sample_traverser: (uid: meta::unqualified_id, indent: i32) =
{
    if uid.is_identifier() {
        sample_print(uid.get_identifier(), indent);
    }
    else {
        sample_print(uid.to_string(), indent+1);
    }
}


sample_traverser: (qid: meta::qualified_id, indent: i32) =
{
    (copy first := true)
    for qid.get_terms()
    do  (term)
    {
        if !first {
            sample_print("op: (term.get_op())$", indent+1);
        }
        first = false;
        sample_print("unqualified:", indent+1);
        sample_traverser(term.get_unqualified(), indent+2);
    }
}


sample_traverser: (tid: meta::type_id, indent: i32) =
{
    if tid.is_postfix_expression() {
        sample_traverser(tid.as_postfix_expression(), indent);
    }
    else if tid.is_qualified_id() {
        sample_traverser(tid.as_qualified_id(), indent);
    }
    else if tid.is_unqualified_id() {
        sample_traverser(tid.as_unqualified_id(), indent);
    }
    else {
        sample_print(tid.to_string(), indent);
    }
}


sample_traverser: (primary: meta::primary_expression, indent: i32) =
{
    if primary.is_identifier() {
        sample_print(primary.as_identifier(), indent+1);
    }
    else if primary.is_expression_list() {
        sample_traverser(primary.as_expression_list(), indent+1);
    }
    else if primary.is_literal() {
        sample_print(primary.as_literal(), indent+1);
    }
    else if primary.is_declaration() {
        sample_traverser(primary.as_declaration(), indent+1);
    }
    else {
        sample_print(primary.to_string(), indent+1);
    }
}


sample_traverser: (idexpr: meta::id_expression, indent: i32) =
{
    if idexpr.is_identifier() {
        sample_print(idexpr.as_identifier(), indent+1);
    }
    else if idexpr.is_qualified() {
        sample_traverser(idexpr.as_qualified(), indent+1);
    }
    else if idexpr.is_unqualified() {
        sample_traverser(idexpr.as_unqualified(), indent+1);
    }
    else {
        sample_print(idexpr.to_string(), indent+1);
    }
}


//-----------------------------------------------------------------------
//
//  autodiff
//

/**
 * @brief Automatic differentiation support for Cpp2 metaprogramming.
 *
 * This section implements the `@autodiff` metafunction. It traverses a type
 * declaration, discovers active variables, and emits differentiated members.
 * This is a proof-of-concept implementation; reverse mode is only partially
 * implemented and not yet well tested (see docs).
 *
 * Options are parsed from text template arguments:
 * - "reverse" enables reverse-mode adjoints (default suffix `_b`).
 * - "order=<n>" enables higher-order derivatives via `cpp2::taylor`.
 * - "suffix=<s>" overrides the forward suffix (default `_d`).
 * - "rws_suffix=<s>" overrides the reverse suffix.
 *
 * Pipeline overview:
 * - `autodiff(...)` parses the options, builds an `autodiff_context`, sets suffixes,
 *   and pushes the namespace/type stack so lookups can resolve declarations.
 * - `autodiff_declaration_handler` walks declarations and emits new members:
 *   `f_d` for forward mode and `f_b` for reverse mode. Signatures are expanded
 *   with `_d` and `_b` parameters and with return storage for the primal value.
 * - `autodiff_stmt_handler` walks statements and emits the primal block plus
 *   a reverse block. It uses `cpp2::ad_stack` to save/restore overwritten locals.
 * - `autodiff_expression_handler` converts each expression into three strings:
 *   `primal_expr`, `fwd_expr`, and `rws_expr` (backprop template). It uses
 *   placeholders like `_r_`, `_rd_`, `_rb_` and creates temporaries for
 *   active subexpressions via `gen_temporary()`.
 * - `autodiff_diff_code` buffers the output; reverse backprop snippets are
 *   prepended so they execute in reverse order after the primal pass.
 * - Function calls are handled by `handle_function_call()`: it either expands a
 *   `special_func` template (sin/cos/exp/sqrt/push_back) or emits calls to
 *   `f_d`/`f_b`. When a call is emitted, `add_for_differentiation()` queues the
 *   callee so `pop_stack()` can generate its derivative later.
 *
 * Reverse-mode AST traversal and manipulation:
 * - `apply_metafunctions` builds a `meta::type_declaration` and calls `autodiff`.
 *   In reverse mode, `autodiff_context.reverse` is set and `rws_suffix` is applied.
 * - `autodiff_declaration_handler` is a `simple_traverser`; its `pre_traverse`
 *   drives a depth-first walk of the reflection AST. Each node visit calls the
 *   handler's `traverse` override, then recurses into children via `pre_traverse`.
 * - When a `meta::function_declaration` is visited, the handler constructs a new
 *   reverse-mode signature (adds `_b` parameters and return adjoint storage) and
 *   then uses `autodiff_stmt_handler::pre_traverse` on the function body.
 * - The statement handler uses `autodiff_activity_check` (also a `simple_traverser`)
 *   to decide which variables are active, and `autodiff_expression_handler` to
 *   translate each RHS expression into primal code and a backprop template.
 * - The handler emits new code into `autodiff_diff_code` buffers, and mutates the
 *   reflection AST by calling `decl.add_member(...)` on the enclosing type to add
 *   the generated `f_b` function (and includes `cpp2ad_stack.h` for save/restore).
 * - Reverse-mode accumulation is created by prepending backprop snippets so they
 *   execute in exact reverse order of the primal statements, mirroring a tape.
 *   Overwrites inside a compound statement are guarded with `ad_stack::push/pop`.
 *
 * Reverse-mode pipeline diagram:
 * @code
 * @autodiff<"reverse"> tag
 *   |
 *   v
 * apply_metafunctions
 *   |
 *   v
 * autodiff(type_declaration)
 *   |
 *   v
 * autodiff_declaration_handler::pre_traverse
 *   |
 *   +--> function_declaration:
 *   |      - build f_b signature (add _b params, return adjoint)
 *   |      - autodiff_stmt_handler::pre_traverse(body)
 *   |             |
 *   |             +--> statement/expr nodes:
 *   |                   - autodiff_activity_check (is active?)
 *   |                   - autodiff_expression_handler (primal + backprop)
 *   |                   - append to diff buffers
 *   |      - emit f_b into type via decl.add_member(...)
 *   |
 *   +--> type/object members (if any)
 *   |
 *   v
 * autodiff_context.finish()  // process queued callee diffs
 * @endcode
 *
 * Reverse-mode example:
 * @code
 * f: (x: double, y: double) -> double = {
 *     z := x * y;
 *     return z + sin(x);
 * }
 * @endcode
 *
 * Tag the enclosing type with `@autodiff<"reverse">`. The reflection pipeline
 * parses `f` into `meta::function_declaration` and its statements/expressions
 * (via `simple_traverser::pre_traverse`) and emits a reverse function:
 * @code
 * f_b: (in x: double, inout x_b: double,
 *       in y: double, inout y_b: double,
 *       inout r_b: double) -> (r: double) = { ... }
 * @endcode
 *
 * Callers seed the return adjoint and zero the input adjoints:
 * @code
 * x_b := 0.0; y_b := 0.0; r_b := 1.0;
 * r := ad::f_b(x, x_b, y, y_b, r_b);
 * // x_b == df/dx, y_b == df/dy
 * @endcode
 *
 * How the reverse body is generated:
 * - For `z := x * y`, `autodiff_activity_check` marks `x` and `y` active
 *   (type `double`), so `z` becomes active. The multiplicative handler sets
 *   `primal_expr` to `x * y` and `rws_expr` to:
 *     `x_b += y * _rb_;`
 *     `y_b += x * _rb_;`
 *   `gen_declaration("z")` emits:
 *     `z_b : double = 0.0;`
 *     `z   : double = x * y;`
 *   and backprop that substitutes `_rb_` with `z_b` and appends `z_b = 0.0`
 *   (the prepend order means `z_b` is cleared after it is used).
 * - For `return z + sin(x)`, `sin` is handled by `special_funcs`, so its
 *   reverse template becomes `x_b += cos(x) * _rb_;`. The additive handler
 *   also adds `z_b += _rb_;`. `gen_assignment("r")` connects the incoming
 *   `r_b` to both `z_b` and `x_b`, then clears `r_b`.
 * - `autodiff_diff_code::add_reverse_backprop` prepends statements so the
 *   backprop block executes in reverse order of the primal block, yielding
 *   the correct adjoint accumulation for `x_b` and `y_b`.
 *
 * Note: There is no explicit graph object. The "graph" is implicit in the
 * AST traversal, generated temporaries, and the backprop templates that link
 * each temporary's adjoint to its inputs.
 */
/// Special-case function templates used for AD code generation.
autodiff_special_func: type = {
    /// Function name to match.
    public name      : std::string;
    /// Arity for the special-case entry.
    public n_args    : int;
    /// True when matching a member function call.
    public is_member : bool;

    /// Primal code template.
    public code_primal             : std::string;
    /// Forward-mode code template.
    public code_fwd                : std::string;
    /// Reverse-mode backprop code template.
    public code_rws                : std::string;
    /// Higher-order primal template.
    public code_primal_higher_order: std::string;
    /// Higher-order forward template.
    public code_fwd_higher_order   : std::string;
    /// Higher-order reverse template.
    public code_rws_higher_order   : std::string;

    /**
     * @brief Construct a special-case entry and derive higher-order defaults.
     * @param name_ Function name to match.
     * @param n_args_ Number of arguments expected.
     * @param is_member_ True when matching a member function call.
     * @param code_primal_ Primal template code.
     * @param code_fwd_ Forward-mode template code.
     * @param code_rws_ Reverse-mode backprop template code.
     * @param code_primal_higher_order_ Primal template for higher order.
     * @param code_fwd_higher_order_ Forward template for higher order.
     * @param code_rws_higher_order_ Reverse template for higher order.
     * @return No return value.
     */
    operator=: (out this, name_: std::string, n_args_: int, is_member_: bool, code_primal_: std::string = "", code_fwd_: std::string = "",
                          code_rws_: std::string = "", code_primal_higher_order_: std::string = "", code_fwd_higher_order_: std::string = "",
                          code_rws_higher_order_: std::string = "") = {
        name      = name_;
        n_args    = n_args_;
        is_member = is_member_;

        code_primal              = code_primal_;
        code_fwd                 = code_fwd_;
        code_rws                 = code_rws_;
        code_primal_higher_order = code_primal_higher_order_;
        code_fwd_higher_order    = code_fwd_higher_order_;
        code_rws_higher_order    = code_rws_higher_order_;

        if code_primal_higher_order.empty() {
            code_primal_higher_order = code_primal;
        }
        if code_fwd_higher_order.empty() {
            code_fwd_higher_order = code_fwd;
        }
        if code_rws_higher_order.empty() {
            code_rws_higher_order = code_rws;
        }
    }

    /**
     * @brief Copy another special function entry.
     * @param that Entry to copy from.
     * @return No return value.
     */
    operator=: (out this, that) = {} // Default copy.

    /**
     * @brief Test if this entry matches another by name, arity, and member flag.
     * @param o Candidate entry to compare.
     * @return True when name, argument count, and member flag match.
     */
    is_match: (this, o: autodiff_special_func) -> bool = {
        return name == o.name && n_args == o.n_args && is_member == o.is_member;
    }
}

/// Records a declared variable and its AD activity.
autodiff_declared_variable: @copy_constructible type = {
    /// Variable name.
    public name     : std::string = "";
    /// Declared type name (string form).
    public decl     : std::string = ""; // TODO: Maybe use variant here.
    /// True if this variable participates in AD.
    public is_active: bool        = false;
    /// True if this is a member variable of `this`.
    public is_member: bool        = false;

    /**
     * @brief Default initialize the variable record.
     * @return No return value.
     */
    operator=:(out this) = {}

    /**
     * @brief Construct a declared variable record.
     * @param name_ Variable name.
     * @param decl_ Declared type string.
     * @param is_active_ True if the variable participates in AD.
     * @param is_member_ True if the variable is a member of `this`.
     * @return No return value.
     */
    operator=:(out this, name_: std::string, decl_: std::string, is_active_: bool, is_member_: bool) = {
        name      = name_;
        decl      = decl_;
        is_active = is_active_;
        is_member = is_member_;
    }

    /**
     * @brief Copy another variable record.
     * @param that Record to copy from.
     * @return No return value.
     */
    operator=:(out this, that) = {}
}

/// Stack entry for a type or namespace during AD traversal.
autodiff_declaration_stack_item: @copy_constructible type = {
    /// Fully qualified name of the declaration.
    public full_name:   std::string;  // namespace + type name
    /// The declaration itself.
    public decl: meta::type_or_namespace_declaration;

    /// Declarations requested for differentiation.
    public diff_request: std::vector<meta::declaration> = ();
    /// Declarations already differentiated.
    public diff_done:    std::vector<meta::declaration> = ();

    /// Nested variable scopes for the current declaration.
    public declared_variables_stack: std::vector<std::vector<autodiff_declared_variable>> = (1);

    /**
     * @brief Construct a stack item for a declaration context.
     * @param full_name_ Fully qualified name for the declaration.
     * @param decl_ Declaration being tracked.
     * @return No return value.
     */
    operator=: (out this, full_name_: std::string, decl_: meta::type_or_namespace_declaration) = {
        full_name = full_name_;
        decl      = decl_;
    }

    /**
     * @brief Find declarations in the current type or namespace by name.
     * @param decl_name Name to look up.
     * @return List of matching declarations (overloads are preserved).
     */
    lookup_declaration: (this, decl_name: std::string) -> (r: std::vector<meta::declaration> = ()) = {
        for decl.get_members() do (cur) {
            if cur.has_name() && decl_name  == cur.name() {
                r.push_back(cur);

                // Do not break for overloads. <3
            }
        }
    }

    /**
     * @brief Find a variable declaration in the current scope chain.
     * @param decl_name Variable name to look up.
     * @return Tuple with `found` flag and the matching variable record.
     */
    lookup_variable_declaration: (this, decl_name: std::string) -> (found: bool = false, r: autodiff_declared_variable = ()) = {
        //  Note: Not using "for std::ranges::views::reverse(...)" because
        //  that does not work correctly in Clang 12 + older libstdc++
        (copy cur_context := declared_variables_stack.rbegin())
        while cur_context != declared_variables_stack.rend()
        next  cur_context++
        {
            for cur_context* do (cur) {
                if cur.name == decl_name {
                    found = true;
                    r = cur;
                    return;
                }
            }
        }
    }


}

/**
 * @brief Shared state for one autodiff run (order, mode, suffixes, lookup caches).
 */
autodiff_context: type = {
    /// Counter for generating unique temporary names.
    private temporary_count : int = 0;

    /// Code in special functions is replaced using placeholder tokens:
    /// _o_ object, _od_ object derivative, _ob_ object adjoint,
    /// _aN_ argument, _adN_ derivative argument, _abN_ adjoint, _rb_ incoming adjoint.
    public special_funcs : std::vector<autodiff_special_func> = (
        autodiff_special_func("sin", 1, /* is_member = */ false,
            "sin(_a1_)",
            "cos(_a1_) * _ad1_",
            "_ab1_ += cos(_a1_) * _rb_;\n",
            "sin(_a1_)",
            "_ad1_.sin(_a1_)",
            "TODO",

        ),
        autodiff_special_func("cos", 1, /* is_member = */ false,
            "cos(_a1_)",
            "-sin(_a1_) * _ad1_",
            "_ab1_ += -sin(_a1_) * _rb_;\n",
            "cos(_a1_)",
            "_ad1_.cos(_a1_)",
            "TODO",
        ),
        autodiff_special_func("exp", 1, /* is_member = */ false,
            "exp(_a1_)",
            "exp(_a1_) * _ad1_",
            "_ab1_ += exp(_a1_) * _rb_;\n",
            "exp(_a1_)",
            "_ad1_.exp(_a1_)",
            "TODO",
        ),
        autodiff_special_func("sqrt", 1, /* is_member = */ false,
            "sqrt(_a1_)",
            "0.5 * _ad1_ / sqrt(_a1_)",
            "_ab1_ += 0.5 * _rb_ / sqrt(_a1_);\n",
            "sqrt(_a1_)",
            "_ad1_.sqrt(_a1_)",
            "TODO",
        ),
        autodiff_special_func("push_back", 1, /* is_member = */ true,
            "_o_.push_back(_a1_);",
            "_od_.push_back(_ad1_);",
            "TODO")
    );

    /// Suffix for forward-mode values.
    public  fwd_suffix : std::string = "_d";
    /// Suffix for reverse-mode adjoints.
    public  rws_suffix : std::string = "_b";
    /// AD order (1 for standard dual/adjoint).
    private order  : int         = 1;
    /// True for reverse mode; forward mode otherwise.
    public  reverse: bool        = false;
    /// True to enable debug output during AD processing.
    public  debug: bool          = false;

    /// Forward-mode AD scalar type for the configured order.
    public fwd_ad_type: std::string = "double";
    /// Reverse-mode AD scalar type for the configured order.
    public rws_ad_type: std::string = "double";

    /// Cache of declaration lookups by fully qualified name.
    public declaration_map  : std::map<std::string, std::vector<meta::declaration>> = ();
    /// Stack of namespace/type contexts.
    public declaration_stack: std::vector<autodiff_declaration_stack_item> = ();

    /**
     * @brief Default initialize the autodiff context.
     * @return No return value.
     */
    operator=:(out this) = {}
    /**
     * @brief Initialize order and mode and configure AD types.
     * @param order_ Differentiation order (1 for standard).
     * @param reverse_ True to enable reverse mode.
     * @return No return value.
     */
    operator=:(out this, order_: int, reverse_: bool) = {
        order = order_;
        reverse = reverse_;

        if 1 != order {
            if reverse {
                fwd_ad_type = "cpp2::taylor<double, (order-1)$>";
                rws_ad_type = "cpp2::taylor<double, (order)$>";
            }
            else {
                fwd_ad_type = "cpp2::taylor<double, (order)$>";
            }
        }

    }

    /**
     * @brief Record a local or member variable and whether it is active.
     * @param name Variable name.
     * @param type Declared type string.
     * @param is_active True if the variable participates in AD.
     * @param is_member True if the variable is a member of `this`.
     * @return No return value.
     */
    add_variable_declaration: (inout this, name: std::string, type: std::string, is_active: bool, is_member: bool = false) = {
        declaration_stack.back().declared_variables_stack.back().push_back(autodiff_declared_variable(name, type, is_active, is_member));
    }

    /**
     * @brief Query whether a variable name is marked active.
     * @param name Variable name to look up.
     * @return True if the variable is marked active.
     */
    is_variable_active: (inout this, name: std::string) -> bool = {
        return lookup_variable_declaration(name).is_active;
    }

    /**
     * @brief Build the declaration stack for nested namespaces/types.
     * @param t Type or namespace declaration to push.
     * @return No return value.
     */
    create_namespace_stack: (inout this, t: meta::type_or_namespace_declaration) = {
        if t.parent_is_nonglobal_namespace() {
            create_namespace_stack(t.get_parent().as_nonglobal_namespace());
        }
        else if t.parent_is_type() {
            create_namespace_stack(t.get_parent().as_type());
        }

        full_name: std::string = "::";
        if !declaration_stack.empty() {
            full_name = declaration_stack.back().full_name + "::";
        }
        full_name += t.name();

        _ = declaration_stack.push_back(autodiff_declaration_stack_item(full_name, t));
    }

    /**
     * @brief Check if forward code should be emitted.
     * @return True when forward-mode code is enabled.
     */
    is_forward: (this) = !reverse || (reverse && order != 1);
    /**
     * @brief Check if reverse code should be emitted.
     * @return True when reverse-mode code is enabled.
     */
    is_reverse: (this) = reverse;
    /**
     * @brief Check if higher-order Taylor types are used.
     * @return True when order is not 1.
     */
    is_taylor : (this) = order != 1;

    /**
     * @brief Generate a unique temporary name for intermediate expressions.
     * @return Fresh temporary identifier.
     */
    gen_temporary : (inout this) -> std::string = {
        temporary_count += 1;
        return "temp_(temporary_count)$";
    }

    /**
     * @brief Determine whether a type is active for AD.
     * @param type Type name to check.
     * @return True if the type is considered active.
     */
    is_type_active: (inout this, type: std::string) -> bool = {
        decls := lookup_type_declaration(type);
        r := false;

        if !decls.empty() {
            assert(decls.ssize() == 1);
            ada: autodiff_activity_check = (this&);
            ada.pre_traverse(decls[0]);
            r = ada.active;
        }

        // TODO: Add template activity lookup.

        if !r {
            // Declaration lookup did not yield an activity: Apply some heuristics.
            r = type.contains("double");
        }

        return r;
    }

    /**
     * @brief Map a type to its forward-mode AD type and request differentiation if needed.
     * @param type Original type name.
     * @return Forward-mode AD type name.
     */
    get_fwd_ad_type: (inout this, type: std::string) -> std::string = {
        type_d := type;

        if "double" != type {
            type_decls := lookup_type_declaration(type);
            if !type_decls.empty() {
                // We found a cpp2 type declaration, mark it for differentiation.
                add_for_differentiation(type_decls[0]);

                // Add the AD suffix to the type
                type_d += fwd_suffix;
            }
        }

        // Replace with AD type for the AD order.
        return string_util::replace_all(type_d, "double", fwd_ad_type);
    }

    /**
     * @brief Map a type to its reverse-mode AD type and request differentiation if needed.
     * @param type Original type name.
     * @return Reverse-mode AD type name.
     */
    get_rws_ad_type: (inout this, type: std::string) -> std::string = {
        type_d := type;

        if "double" != type {
            type_decls := lookup_type_declaration(type);
            if !type_decls.empty() {
                // We found a cpp2 type declaration, mark it for differentiation.
                add_for_differentiation(type_decls[0]);

                // Add the AD suffix to the type
                type_d += rws_suffix;
            }
        }

        // Replace with AD type for the AD order.
        return string_util::replace_all(type_d, "double", rws_ad_type);
    }

    /**
     * @brief Normalize parameter passing for reverse-mode adjoint parameters.
     * @param p Original passing style.
     * @return Passing style to use in reverse mode.
     */
    get_reverse_passing_style: (this, p: passing_style) -> passing_style = {
        // TODO: inspect does not work here: error: error: no matching function for call to is<cpp2::passing_style::in>(const cpp2::passing_style&)
        // return inspect p -> passing_style  {
        //     is passing_style::in          = passing_style::inout;
        //     is passing_style::in_ref      = passing_style::inout;
        //     is passing_style::copy        = passing_style::inout;
        //     is passing_style::inout       = passing_style::inout;
        //     is passing_style::out         = passing_style::inout;
        //     is passing_style::move        = passing_style::inout;
        //     is passing_style::forward     = passing_style::inout;
        //     is passing_style::forward_ref = passing_style::inout;
        //     is _                          = passing_style::inout;
        // };
        if p == passing_style::in          { return  passing_style::inout; }
        if p == passing_style::in_ref      { return  passing_style::inout; }
        if p == passing_style::copy        { return  passing_style::inout; }
        if p == passing_style::inout       { return  passing_style::inout; }
        if p == passing_style::out         { return  passing_style::inout; }
        if p == passing_style::move        { return  passing_style::inout; }
        if p == passing_style::forward     { return  passing_style::inout; }
        if p == passing_style::forward_ref { return  passing_style::inout; }


        declaration_stack.back().decl.error("AD: Do not know how to handle passing style:(p)$");

        return  passing_style::inout;
    }

    /**
     * @brief Lookup a declaration by name using the stack of parent scopes.
     * @param decl_name Name to resolve.
     * @return List of matching declarations.
     */
    lookup_declaration: (inout this, decl_name: std::string) -> (r : std::vector<meta::declaration> = ()) = {
        //  Note: Not using "for std::ranges::views::reverse(...)" because
        //  that does not work correctly in Clang 12 + older libstdc++
        (copy cur := declaration_stack.rbegin())
        while cur != declaration_stack.rend()
        next  cur++
        {
            cur_full_name : std::string = cur*.full_name + "::" + decl_name;
            ele := declaration_map.find(cur_full_name);
            if ele == declaration_map.end() {
                ele = declaration_map.insert_or_assign(cur_full_name, cur*.lookup_declaration(decl_name)).first;
            }

            if !ele*.second.empty() {
                // A simple assignment or emplace_back did not work. It tired to use move copy operators.
                for ele*.second do (cp) {
                    r.push_back(cp);
                }
                //r = ele*.second;
                break;
                // TODO: For overload resolution we may want to continue here and just add everything for all parent namespaces.
            }
        }

        return;
    }

    /**
     * @brief Lookup a variable by name in nested scopes.
     * @param name Variable name to resolve.
     * @return Matching variable record (or empty record with errors reported).
     */
    lookup_variable_declaration: (inout this, name: std::string) -> autodiff_declared_variable = {
        if name == "_" {
            return autodiff_declared_variable(name, "_", false, false);
        }

        //  Note: Not using "for std::ranges::views::reverse(...)" because
        //  that does not work correctly in Clang 12 + older libstdc++
        (copy cur_context := declaration_stack.rbegin())
        while cur_context != declaration_stack.rend()
        next  cur_context++
        {
            r := cur_context*.lookup_variable_declaration(name);
            if r.found {
                return r.r;
            }
        }

        declaration_stack.back().decl.error("AD: Could not find declaration of variable with name `(name)$`.");

        return autodiff_declared_variable();
    }

    /**
     * @brief Lookup free functions in the current scope.
     * @param decl_name Function name.
     * @return Matching function declarations.
     */
    lookup_function_declaration: (inout this, decl_name: std::string) -> (r : std::vector<meta::function_declaration> = ()) = {
        r_all := lookup_declaration(decl_name);

        for r_all do (cur) {
            if cur.is_function() {
                r.push_back(cur.as_function());
            }
        }
    }

    /**
     * @brief Lookup member functions on a concrete type declaration.
     * @param obj_type Type declaration to search.
     * @param decl_name Member function name.
     * @return Matching member function declarations.
     */
    lookup_member_function_declaration: (inout this, obj_type: meta::type_declaration, decl_name: std::string) -> (r : std::vector<meta::function_declaration> = ()) = {
        for obj_type.get_members() do (cur) {
            if cur.is_function() && cur.has_name() && decl_name  == cur.name() {
                r.push_back(cur.as_function());

                // Do not break for overloads. <3
            }
        }
    }

    /**
     * @brief Lookup type declarations in the current scope.
     * @param decl_name Type name.
     * @return Matching type declarations.
     */
    lookup_type_declaration: (inout this, decl_name: std::string) -> (r : std::vector<meta::type_declaration> = ()) = {
        r_all := lookup_declaration(decl_name);

        for r_all do (cur) {
            if cur.is_type() {
                r.push_back(cur.as_type());
            }
        }
    }

    /**
     * @brief Match and expand a special-case function (sin, cos, etc).
     * @param func_name Function name to match.
     * @param n_args Number of arguments.
     * @param is_member True for member function calls.
     * @return Tuple containing match flag and generated templates.
     */
    lookup_special_function_handling: (this, func_name: std::string, n_args: int, is_member: bool) -> (m: bool, code_primal: std::string, code_fwd: std::string, code_rws: std::string) = {
        lookup : autodiff_special_func = (func_name, n_args, is_member);

        m = false;
        code_primal = "";
        code_fwd    = "";
        code_rws    = "";
        for special_funcs do (func) {
            if func.is_match(lookup) {
                m = true;
                if is_taylor() {
                    code_primal = func.code_primal_higher_order;
                    code_fwd    = func.code_fwd_higher_order;
                    code_rws    = func.code_rws_higher_order;
                }
                else {
                    code_primal = func.code_primal;
                    code_fwd    = func.code_fwd;
                    code_rws    = func.code_rws;
                }
                return;
            }
        }
    }

    /**
     * @brief Mark a declaration as already differentiated in the current context.
     * @param t Declaration to mark.
     * @return No return value.
     */
    add_as_differentiated: (inout this, t: meta::declaration) = {
        top := declaration_stack.back()&;

        assert(t.get_parent().is_same(top*.decl));

        top*.diff_done.push_back(t);
    }

    /**
     * @brief Request a declaration to be differentiated by its parent context.
     * @param t Declaration to enqueue.
     * @return No return value.
     */
    add_for_differentiation: (inout this, t: meta::declaration) = {
        t_parent := t.get_parent();

        found := false;

        //  Note: Not using "for std::ranges::views::reverse(...)" because
        //  that does not work correctly in Clang 12 + older libstdc++
        (copy cur := declaration_stack.rbegin())
        while cur != declaration_stack.rend()
        next  cur++
        {
            if t_parent.is_same(cur*.decl) {
                if !is_in_list(t, cur*.diff_request) {
                    cur*.diff_request.push_back(t);
                }

                found = true;
                break;
            }
        }

        if !found {
            t.error("AD: Could not find parent type/namespace for: (t)$");
        }
    }

    /**
     * @brief Check whether a declaration is in a list.
     * @param v Declaration to check.
     * @param list Declarations to search.
     * @return True if v is present in list.
     */
    is_in_list: (v: meta::declaration, list: std::vector<meta::declaration>) -> bool = {
        for list do (cur) {
            if cur.is_same(v) {
                return true;
            }
        }

        return false;
    }

    /**
     * @brief Enter a function scope and reset temporary naming.
     * @return No return value.
     */
    enter_function: (inout this) = {
        temporary_count = 0;
        declaration_stack.back().declared_variables_stack.push_back(std::vector<autodiff_declared_variable>());
    }

    /**
     * @brief Leave the current function scope.
     * @return No return value.
     */
    leave_function: (inout this) = {
        declaration_stack.back().declared_variables_stack.pop_back();
    }

    /**
     * @brief Push a declaration context onto the stack.
     * @param decl Declaration to push.
     * @return No return value.
     */
    push_stack: (inout this, decl: meta::type_or_namespace_declaration) = {
        full_name: std::string = "";

        if !declaration_stack.empty() {
            full_name += declaration_stack.back().full_name;
        }

        full_name += "::";
        full_name += decl.name();

        declaration_stack.push_back(autodiff_declaration_stack_item(full_name, decl));
    }

    /**
     * @brief Pop the current declaration context and process queued differentiations.
     * @return No return value.
     */
    pop_stack: (inout this) = {
        assert(!declaration_stack.empty());

        top := declaration_stack.back()&;
        ad: autodiff_declaration_handler = (this&, top*.decl);

        for top*.diff_request do (cur) {
            if !is_in_list(cur, top*.diff_done) {
                ad.pre_traverse(cur);
            }
        }

        declaration_stack.pop_back();
    }

    /**
     * @brief Pop all remaining contexts and finalize queued differentiations.
     * @return No return value.
     */
    finish: (inout this) = {
        while !declaration_stack.empty() {
            pop_stack();
        }
    }

    /**
     * @brief Temporary helper for legacy callers.
     * @return Pointer to this context.
     */
    get_self: (inout this) -> *autodiff_context = {
        return this&;
    }

}

/**
 * @brief Context for reverse-mode IR construction and naming.
 */
reverse_autodiff_context: type = {
    /// Owning autodiff context.
    public ctx : *autodiff_context;
    /// Function being transformed.
    public mf  : meta::function_declaration;

    /// Suffix used for value temporaries.
    public value_suffix: std::string = "_val";
    /// Suffix used for adjoint temporaries.
    public adj_suffix  : std::string = "_adj";

    /**
     * @brief Initialize the reverse context.
     * @param ctx_ Autodiff context to use.
     * @param mf_ Function being transformed.
     * @return No return value.
     */
    operator=:(out this, ctx_: *autodiff_context, mf_: meta::function_declaration) = {
        ctx = ctx_;
        mf  = mf_;
    }

    /**
     * @brief Create a value name with the configured suffix.
     * @param base Base identifier.
     * @return Value name with suffix.
     */
    make_value_name: (this, base: std::string) -> std::string = {
        if base == "_" {
            return base;
        }
        return base + value_suffix;
    }

    /**
     * @brief Create an adjoint name with the configured suffix.
     * @param base Base identifier.
     * @return Adjoint name with suffix.
     */
    make_adj_name: (this, base: std::string) -> std::string = {
        if base == "_" {
            return base;
        }
        return base + adj_suffix;
    }
}

//-----------------------------------------------------------------------
//
//  Typed AD IR definitions for reverse-mode autodiff
//
//-----------------------------------------------------------------------

//-----------------------------------------------------------------------
//  Type System - Compositional type representation
//-----------------------------------------------------------------------

/**
 * @brief Type kinds for AD IR type system.
 *
 * Enables compositional type representation where complex types
 * are built from simpler ones (e.g., const double& = const_(ref_(double_))).
 */
ad_type_kind: @enum type = {
    auto_;          // auto keyword
    void_;          // void
    int_;           // int
    size_t_;        // size_t
    double_;        // double
    float_;         // float
    bool_;          // bool
    char_;          // char
    named;          // Named type (e.g., std::vector<double>, custom types)
    const_;         // const T (inner type in inner_type)
    ref;            // T& (inner type in inner_type)
    rvalue_ref;     // T&& (inner type in inner_type)
    pointer;        // T* (inner type in inner_type)
    array;          // T[N] (inner type in inner_type, size in array_size)
    template_;      // Template instantiation T<Args...> (name + type_args)
}

/**
 * @brief Compositional type representation for AD IR.
 *
 * Types are represented as trees where qualifiers and modifiers
 * wrap inner types. This enables type transformations as tree operations.
 *
 * Examples:
 * - double -> ad_type_kind::double_
 * - const double -> ad_type_kind::const_ with inner = double_
 * - double& -> ad_type_kind::ref with inner = double_
 * - const double& -> ad_type_kind::const_ with inner = (ref with inner = double_)
 * - std::vector<double> -> ad_type_kind::template_ with name="std::vector", type_args=[double_]
 */
ad_type: type = {
    public kind       : ad_type_kind = ad_type_kind::double_;
    public name       : std::string = "";                      // For named/template types
    public inner_type : std::shared_ptr<ad_type> = ();         // For const/ref/ptr/array
    public type_args  : std::vector<ad_type> = ();             // For template types
    public array_size : int = 0;                               // For array types

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    // ===== Factory methods for primitive types =====

    /**
     * @brief Create an auto type.
     * @return auto type node.
     */
    make_auto: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::auto_;
        return t;
    }

    /**
     * @brief Create a void type.
     * @return void type node.
     */
    make_void: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::void_;
        return t;
    }

    /**
     * @brief Create an int type.
     * @return int type node.
     */
    make_int: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::int_;
        return t;
    }

    /**
     * @brief Create a size_t type.
     * @return size_t type node.
     */
    make_size_t: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::size_t_;
        return t;
    }

    /**
     * @brief Create a double type.
     * @return double type node.
     */
    make_double: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::double_;
        return t;
    }

    /**
     * @brief Create a float type.
     * @return float type node.
     */
    make_float: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::float_;
        return t;
    }

    /**
     * @brief Create a bool type.
     * @return bool type node.
     */
    make_bool: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::bool_;
        return t;
    }

    /**
     * @brief Create a char type.
     * @return char type node.
     */
    make_char: () -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::char_;
        return t;
    }

    // ===== Factory methods for composite types =====

    /**
     * @brief Create a named type (non-template).
     * @param type_name Fully qualified type name.
     * @return Named type node.
     */
    make_named: (type_name: std::string) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::named;
        t.name = type_name;
        return t;
    }

    /**
     * @brief Create a const-qualified type.
     * @param inner The type being const-qualified.
     * @return const T type node.
     */
    make_const: (inner: ad_type) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::const_;
        t.inner_type = std::make_shared<ad_type>(inner);
        return t;
    }

    /**
     * @brief Create an lvalue reference type.
     * @param inner The type being referenced.
     * @return T& type node.
     */
    make_ref: (inner: ad_type) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::ref;
        t.inner_type = std::make_shared<ad_type>(inner);
        return t;
    }

    /**
     * @brief Create an rvalue reference type.
     * @param inner The type being referenced.
     * @return T&& type node.
     */
    make_rvalue_ref: (inner: ad_type) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::rvalue_ref;
        t.inner_type = std::make_shared<ad_type>(inner);
        return t;
    }

    /**
     * @brief Create a pointer type.
     * @param inner The pointed-to type.
     * @return T* type node.
     */
    make_pointer: (inner: ad_type) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::pointer;
        t.inner_type = std::make_shared<ad_type>(inner);
        return t;
    }

    /**
     * @brief Create an array type.
     * @param inner Element type.
     * @param size Array size (0 for unsized).
     * @return T[N] type node.
     */
    make_array: (inner: ad_type, size: int) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::array;
        t.inner_type = std::make_shared<ad_type>(inner);
        t.array_size = size;
        return t;
    }

    /**
     * @brief Create a template instantiation type.
     * @param template_name Template name (e.g., "std::vector").
     * @param args Template type arguments.
     * @return Template type node.
     */
    make_template: (template_name: std::string, args: std::vector<ad_type>) -> ad_type = {
        t: ad_type = ();
        t.kind = ad_type_kind::template_;
        t.name = template_name;
        t.type_args = args;
        return t;
    }

    // ===== Convenience factory methods for common patterns =====

    /**
     * @brief Create a const reference type (const T&).
     * @param inner The type being const-referenced.
     * @return const T& type node.
     */
    make_const_ref: (inner: ad_type) -> ad_type = {
        return make_const(make_ref(inner));
    }

    /**
     * @brief Create std::vector<T> type.
     * @param elem Element type.
     * @return std::vector<T> type node.
     */
    make_std_vector: (elem: ad_type) -> ad_type = {
        args: std::vector<ad_type> = ();
        args.push_back(elem);
        return make_template("std::vector", args);
    }

    // ===== Type query methods =====

    /**
     * @brief Check if this type is const-qualified.
     * @return true if const-qualified.
     */
    is_const: (this) -> bool = {
        return kind == ad_type_kind::const_;
    }

    /**
     * @brief Check if this type is a reference.
     * @return true if lvalue or rvalue reference.
     */
    is_reference: (this) -> bool = {
        return kind == ad_type_kind::ref || kind == ad_type_kind::rvalue_ref;
    }

    /**
     * @brief Check if this type is a pointer.
     * @return true if pointer type.
     */
    is_pointer: (this) -> bool = {
        return kind == ad_type_kind::pointer;
    }

    /**
     * @brief Get the underlying type, stripping qualifiers and modifiers.
     * @return Base type (recursive unwrap).
     */
    get_base_type: (this) -> ad_type = {
        if inner_type != nullptr {
            return inner_type*.get_base_type();
        }
        return this;
    }
}

/**
 * @brief Convert ad_type to string representation for code emission.
 * @param t Type to convert.
 * @return String representation of the type.
 */
ad_type_to_string: (t: ad_type) -> std::string = {
    if t.kind == ad_type_kind::auto_    { return "auto"; }
    if t.kind == ad_type_kind::void_    { return "void"; }
    if t.kind == ad_type_kind::int_     { return "int"; }
    if t.kind == ad_type_kind::size_t_  { return "size_t"; }
    if t.kind == ad_type_kind::double_  { return "double"; }
    if t.kind == ad_type_kind::float_   { return "float"; }
    if t.kind == ad_type_kind::bool_    { return "bool"; }
    if t.kind == ad_type_kind::char_    { return "char"; }
    if t.kind == ad_type_kind::named    { return t.name; }

    if t.kind == ad_type_kind::const_ {
        if t.inner_type != nullptr {
            return "const " + ad_type_to_string(t.inner_type*);
        }
        return "const";
    }
    if t.kind == ad_type_kind::ref {
        if t.inner_type != nullptr {
            return ad_type_to_string(t.inner_type*) + "&";
        }
        return "&";
    }
    if t.kind == ad_type_kind::rvalue_ref {
        if t.inner_type != nullptr {
            return ad_type_to_string(t.inner_type*) + "&&";
        }
        return "&&";
    }
    if t.kind == ad_type_kind::pointer {
        if t.inner_type != nullptr {
            return ad_type_to_string(t.inner_type*) + "*";
        }
        return "*";
    }
    if t.kind == ad_type_kind::array {
        if t.inner_type != nullptr {
            if t.array_size > 0 {
                return ad_type_to_string(t.inner_type*) + "[" + std::to_string(t.array_size) + "]";
            }
            return ad_type_to_string(t.inner_type*) + "[]";
        }
        return "[]";
    }
    if t.kind == ad_type_kind::template_ {
        result := t.name + "<";
        (copy first := true)
        for t.type_args do (arg) {
            if !first { result += ", "; }
            first = false;
            result += ad_type_to_string(arg);
        }
        result += ">";
        return result;
    }
    return "unknown_type";
}

/**
 * @brief Convert ad_type_kind to string for debug output.
 * @param kind Type kind.
 * @return String representation.
 */
ad_type_kind_to_string: (kind: ad_type_kind) -> std::string = {
    if kind == ad_type_kind::auto_      { return "auto"; }
    if kind == ad_type_kind::void_      { return "void"; }
    if kind == ad_type_kind::int_       { return "int"; }
    if kind == ad_type_kind::size_t_    { return "size_t"; }
    if kind == ad_type_kind::double_    { return "double"; }
    if kind == ad_type_kind::float_     { return "float"; }
    if kind == ad_type_kind::bool_      { return "bool"; }
    if kind == ad_type_kind::char_      { return "char"; }
    if kind == ad_type_kind::named      { return "named"; }
    if kind == ad_type_kind::const_     { return "const"; }
    if kind == ad_type_kind::ref        { return "ref"; }
    if kind == ad_type_kind::rvalue_ref { return "rvalue_ref"; }
    if kind == ad_type_kind::pointer    { return "pointer"; }
    if kind == ad_type_kind::array      { return "array"; }
    if kind == ad_type_kind::template_  { return "template"; }
    return "unknown";
}

//-----------------------------------------------------------------------
//  Operation kinds for AD expressions
//-----------------------------------------------------------------------

/**
 * @brief Operation kinds for AD expressions.
 *
 * These tags identify the operation type for expression nodes in the AD IR.
 * Binary operators (+, -, *, /) are handled explicitly by the builder.
 * Function calls (sin, cos, exp, log, etc.) use the call tag.
 */
ad_op_kind: @enum type = {
    // Arithmetic operators
    add;        // Binary addition
    sub;        // Binary subtraction
    mul;        // Binary multiplication
    div;        // Binary division
    mod;        // Binary modulo
    neg;        // Unary negation
    pos;        // Unary plus

    // Increment/Decrement
    pre_inc;    // Prefix increment (++x)
    pre_dec;    // Prefix decrement (--x)
    post_inc;   // Postfix increment (x++)
    post_dec;   // Postfix decrement (x--)

    // Comparison operators
    eq;         // Equal (==)
    ne;         // Not equal (!=)
    lt;         // Less than (<)
    gt;         // Greater than (>)
    le;         // Less or equal (<=)
    ge;         // Greater or equal (>=)
    spaceship;  // Three-way comparison (<=>)

    // Logical operators
    land;       // Logical AND (&&)
    lor;        // Logical OR (||)
    lnot;       // Logical NOT (!)

    // Bitwise operators
    band;       // Bitwise AND (&)
    bor;        // Bitwise OR (|)
    bxor;       // Bitwise XOR (^)
    bnot;       // Bitwise NOT (~)
    shl;        // Left shift (<<)
    shr;        // Right shift (>>)

    // Pointer/Reference operators
    deref;      // Dereference (*)
    addr_of;    // Address-of (&)

    // Assignment operators (for compound assignments)
    assign;     // Simple assignment (=)
    assign_add; // Add-assign (+=)
    assign_sub; // Subtract-assign (-=)
    assign_mul; // Multiply-assign (*=)
    assign_div; // Divide-assign (/=)
    assign_mod; // Modulo-assign (%=)
    assign_band;// Bitwise AND-assign (&=)
    assign_bor; // Bitwise OR-assign (|=)
    assign_bxor;// Bitwise XOR-assign (^=)
    assign_shl; // Left shift-assign (<<=)
    assign_shr; // Right shift-assign (>>=)

    // Member access operators
    dot;        // Member access (.)
    arrow;      // Pointer member access (->)

    // Function call (unchanged from before)
    call;       // Function call (differentiation rules looked up by name)
    literal;    // Numeric literal
    identifier; // Variable reference
}

/**
 * @brief Expression node kinds for AD IR.
 *
 * Distinguishes between different expression forms in the typed IR.
 * Extended to cover all C++ expression forms needed in autodiff rules.
 */
ad_expr_kind: @enum type = {
    // Values
    literal;        // Numeric/string literal (e.g., 3.0, "hello")
    identifier;     // Variable reference (e.g., x)

    // Operations
    unary;          // Unary operation (e.g., -x, !x, ++x)
    binary;         // Binary operation (e.g., x + y, x && y)
    ternary;        // Conditional expression (a ? b : c)

    // Access
    member;         // Member access (obj.member or obj->member)
    subscript;      // Array/container subscript (arr[i])

    // Calls
    call;           // Function call (e.g., sin(x), std::abs(y))
    method_call;    // Method call (obj.method(args))

    // Type operations
    cast;           // Type cast (static_cast<T>(x))
    construct;      // Constructor call (T(args) or T{args})

    // Special
    paren;          // Parenthesized expression ((expr))
    lambda;         // Lambda expression ([captures](params) { body })
    initializer_list; // Initializer list ({a, b, c})
}

/**
 * @brief Statement node kinds for AD IR.
 *
 * Distinguishes between different statement forms in the typed IR.
 * Extended to support loops, jumps, and all compound assignment forms.
 */
ad_stmt_kind: @enum type = {
    // Declarations
    decl;           // Local variable declaration (name: type = init)

    // Assignments
    assign;         // Simple assignment (x = expr)
    compound_assign;// Compound assignment (x += expr, x -= expr, etc.)
                    // Uses op field to determine the compound operator

    // Legacy compound assignments (kept for backward compatibility)
    assign_add;     // Add-assignment statement (+=) - prefer compound_assign

    // Control flow
    if_stmt;        // If statement with optional else
    for_stmt;       // C-style for loop (for init; cond; incr { body })
    foreach_stmt;   // Range-based for loop (for item in range { body })
    while_stmt;     // While loop (while cond { body })
    do_while_stmt;  // Do-while loop (do { body } while cond)
    switch_stmt;    // Switch statement (switch expr { cases })

    // Jumps
    return_;        // Return statement
    break_stmt;     // Break statement
    continue_stmt;  // Continue statement

    // Blocks
    compound;       // Compound statement/block ({ stmts })
    expr_stmt;      // Expression statement (expr;) - alias for expr

    // Legacy
    expr;           // Expression statement (kept for backward compatibility)
    raw_code;       // Raw code string - DEPRECATED, to be removed

    // Exception handling (future)
    try_catch;      // Try-catch block
    throw_stmt;     // Throw statement
}

/**
 * @brief Typed IR expression node.
 *
 * Represents an expression in the AD IR. The `kind` field determines
 * how other fields are interpreted:
 * - literal: `name` holds the literal value string
 * - identifier: `name` holds the variable name
 * - unary: `op` holds the operation, `args[0]` is the operand
 * - binary: `op` holds the operation, `args[0]` and `args[1]` are operands
 * - ternary: `args[0]` is condition, `args[1]` is then-expr, `args[2]` is else-expr
 * - member: `args[0]` is object, `member_name` is member, `op` is dot/arrow
 * - subscript: `args[0]` is array/container, `args[1]` is index
 * - call: `name` is function name, `args` are arguments, `type_args` for template args
 * - method_call: `args[0]` is object, `name` is method, `args[1..]` are call arguments
 * - cast: `name` is cast kind (static_cast etc), `cast_type` is target type, `args[0]` is expr
 * - construct: `name` is type name, `args` are constructor arguments
 * - paren: `args[0]` is inner expression
 * - lambda: `lambda_body` holds the body statements, `lambda_params` holds parameters
 * - initializer_list: `args` holds the list elements
 */
ad_expr: type = {
    public kind         : ad_expr_kind = ad_expr_kind::literal;
    public type_name    : std::string = "";                       // Result type (string form)
    public expr_type    : std::shared_ptr<ad_type> = ();          // Result type (structured form)
    public name         : std::string = "";                       // For identifiers/literals/calls
    public op           : ad_op_kind  = ad_op_kind::add;          // Operation kind
    public args         : std::vector<ad_expr> = ();              // Operands/arguments
    public member_name  : std::string = "";                       // For member access
    public type_args    : std::vector<ad_type> = ();              // Template type arguments
    public cast_type    : std::shared_ptr<ad_type> = ();          // Target type for casts
    public lambda_params: std::vector<std::pair<std::string, std::string>> = (); // Lambda params (name, type)
    public lambda_body  : std::shared_ptr<std::vector<ad_stmt>> = (); // Lambda body (forward decl workaround)

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    // ===== Factory methods for basic expressions =====

    /**
     * @brief Create a literal expression.
     * @param value Literal value as string.
     * @param type_name_ Type of the literal.
     * @return Literal expression node.
     */
    make_literal: (value: std::string, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::literal;
        e.name = value;
        e.type_name = type_name_;
        e.op = ad_op_kind::literal;
        return e;
    }

    /**
     * @brief Create a literal expression with structured type.
     * @param value Literal value as string.
     * @param t Structured type.
     * @return Literal expression node.
     */
    make_literal_typed: (value: std::string, t: ad_type) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::literal;
        e.name = value;
        e.type_name = ad_type_to_string(t);
        e.expr_type = std::make_shared<ad_type>(t);
        e.op = ad_op_kind::literal;
        return e;
    }

    /**
     * @brief Create an identifier expression.
     * @param name_ Variable name.
     * @param type_name_ Type of the variable.
     * @return Identifier expression node.
     */
    make_identifier: (name_: std::string, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::identifier;
        e.name = name_;
        e.type_name = type_name_;
        e.op = ad_op_kind::identifier;
        return e;
    }

    /**
     * @brief Create an identifier expression with structured type.
     * @param name_ Variable name.
     * @param t Structured type.
     * @return Identifier expression node.
     */
    make_identifier_typed: (name_: std::string, t: ad_type) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::identifier;
        e.name = name_;
        e.type_name = ad_type_to_string(t);
        e.expr_type = std::make_shared<ad_type>(t);
        e.op = ad_op_kind::identifier;
        return e;
    }

    // ===== Factory methods for operations =====

    /**
     * @brief Create a unary expression.
     * @param op_ Operation kind (e.g., neg, lnot, pre_inc).
     * @param operand Operand expression.
     * @param type_name_ Result type.
     * @return Unary expression node.
     */
    make_unary: (op_: ad_op_kind, operand: ad_expr, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::unary;
        e.op = op_;
        e.type_name = type_name_;
        e.args.push_back(operand);
        return e;
    }

    /**
     * @brief Create a binary expression.
     * @param op_ Operation kind (e.g., add, mul, lt, land).
     * @param lhs Left operand.
     * @param rhs Right operand.
     * @param type_name_ Result type.
     * @return Binary expression node.
     */
    make_binary: (op_: ad_op_kind, lhs: ad_expr, rhs: ad_expr, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::binary;
        e.op = op_;
        e.type_name = type_name_;
        e.args.push_back(lhs);
        e.args.push_back(rhs);
        return e;
    }

    /**
     * @brief Create a ternary (conditional) expression.
     * @param condition Condition expression.
     * @param then_expr Expression if condition is true.
     * @param else_expr Expression if condition is false.
     * @param type_name_ Result type.
     * @return Ternary expression node.
     */
    make_ternary: (condition: ad_expr, then_expr: ad_expr, else_expr: ad_expr,
                   type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::ternary;
        e.type_name = type_name_;
        e.args.push_back(condition);
        e.args.push_back(then_expr);
        e.args.push_back(else_expr);
        return e;
    }

    // ===== Factory methods for access expressions =====

    /**
     * @brief Create a member access expression (obj.member or obj->member).
     * @param object Object expression.
     * @param member Member name.
     * @param is_arrow true for ->, false for .
     * @param type_name_ Result type.
     * @return Member access expression node.
     */
    make_member: (object: ad_expr, member: std::string, is_arrow: bool,
                  type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::member;
        if is_arrow { e.op = ad_op_kind::arrow; }
        else        { e.op = ad_op_kind::dot; }
        e.member_name = member;
        e.type_name = type_name_;
        e.args.push_back(object);
        return e;
    }

    /**
     * @brief Create a subscript expression (arr[index]).
     * @param array Array/container expression.
     * @param index Index expression.
     * @param type_name_ Result type (element type).
     * @return Subscript expression node.
     */
    make_subscript: (array: ad_expr, index: ad_expr, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::subscript;
        e.type_name = type_name_;
        e.args.push_back(array);
        e.args.push_back(index);
        return e;
    }

    // ===== Factory methods for calls =====

    /**
     * @brief Create a function call expression.
     * @param func_name Function name.
     * @param op_ Operation kind (call or specific like sin).
     * @param call_args Arguments to the function.
     * @param type_name_ Result type.
     * @return Call expression node.
     */
    make_call: (func_name: std::string, op_: ad_op_kind, call_args: std::vector<ad_expr>, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::call;
        e.name = func_name;
        e.op = op_;
        e.type_name = type_name_;
        e.args = call_args;
        return e;
    }

    /**
     * @brief Create a function call with template arguments.
     * @param func_name Function name.
     * @param call_args Arguments to the function.
     * @param template_args Template type arguments.
     * @param type_name_ Result type.
     * @return Call expression node with template arguments.
     */
    make_template_call: (func_name: std::string, call_args: std::vector<ad_expr>,
                         template_args: std::vector<ad_type>, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::call;
        e.name = func_name;
        e.op = ad_op_kind::call;
        e.type_name = type_name_;
        e.args = call_args;
        e.type_args = template_args;
        return e;
    }

    /**
     * @brief Create a method call expression (obj.method(args)).
     * @param object Object expression.
     * @param method_name Method name.
     * @param call_args Arguments to the method.
     * @param type_name_ Result type.
     * @return Method call expression node.
     */
    make_method_call: (object: ad_expr, method_name: std::string,
                       call_args: std::vector<ad_expr>, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::method_call;
        e.name = method_name;
        e.op = ad_op_kind::call;
        e.type_name = type_name_;
        e.args.push_back(object);
        for call_args do (arg) {
            e.args.push_back(arg);
        }
        return e;
    }

    // ===== Factory methods for type operations =====

    /**
     * @brief Create a type cast expression.
     * @param cast_kind Cast kind ("static_cast", "dynamic_cast", "reinterpret_cast", "const_cast", or "").
     * @param target_type Target type.
     * @param expr Expression to cast.
     * @param type_name_ Result type name.
     * @return Cast expression node.
     */
    make_cast: (cast_kind: std::string, target_type: ad_type, expr: ad_expr,
                type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::cast;
        e.name = cast_kind;  // "static_cast", etc.
        e.type_name = type_name_;
        e.cast_type = std::make_shared<ad_type>(target_type);
        e.args.push_back(expr);
        return e;
    }

    /**
     * @brief Create a constructor call expression (T(args) or T{args}).
     * @param type_name_ Type being constructed.
     * @param construct_args Constructor arguments.
     * @return Constructor expression node.
     */
    make_construct: (type_name_: std::string, construct_args: std::vector<ad_expr>) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::construct;
        e.name = type_name_;
        e.type_name = type_name_;
        e.args = construct_args;
        return e;
    }

    // ===== Factory methods for special expressions =====

    /**
     * @brief Create a parenthesized expression.
     * @param inner Inner expression.
     * @return Parenthesized expression node.
     */
    make_paren: (inner: ad_expr) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::paren;
        e.type_name = inner.type_name;
        e.args.push_back(inner);
        return e;
    }

    /**
     * @brief Create an initializer list expression ({a, b, c}).
     * @param elements List elements.
     * @param type_name_ Result type (e.g., "std::initializer_list<int>").
     * @return Initializer list expression node.
     */
    make_initializer_list: (elements: std::vector<ad_expr>, type_name_: std::string) -> ad_expr = {
        e: ad_expr = ();
        e.kind = ad_expr_kind::initializer_list;
        e.type_name = type_name_;
        e.args = elements;
        return e;
    }

    // ===== Convenience factory methods =====

    /**
     * @brief Create an integer literal.
     * @param value Integer value.
     * @return Integer literal expression.
     */
    make_int_literal: (value: int) -> ad_expr = {
        return make_literal(std::to_string(value), "int");
    }

    /**
     * @brief Create a double literal.
     * @param value Double value.
     * @return Double literal expression.
     */
    make_double_literal: (value: double) -> ad_expr = {
        return make_literal(std::to_string(value), "double");
    }

    /**
     * @brief Create a boolean literal.
     * @param value Boolean value.
     * @return Boolean literal expression.
     */
    make_bool_literal: (value: bool) -> ad_expr = {
        if value { return make_literal("true", "bool"); }
        return make_literal("false", "bool");
    }
}

/**
 * @brief Typed IR statement node.
 *
 * Represents a statement in the AD IR. The `kind` field determines
 * how other fields are interpreted:
 * - decl: `target` is variable name, `type_name`/`decl_type` is its type, `expr` is initializer
 * - assign: `target` is variable name, `expr` is the value
 * - compound_assign: `target` is variable, `op` determines operator, `expr` is value
 * - expr/expr_stmt: `expr` is the expression to evaluate
 * - return_: `expr` is the return value
 * - compound: `stmts` contains nested statements
 * - if_stmt: `expr` is condition, `stmts` is then-branch, `else_stmts` is else-branch
 * - for_stmt: `init_stmt` is init, `expr` is condition, `incr_expr` is increment, `stmts` is body
 * - foreach_stmt: `target` is loop var, `type_name` is var type, `range_expr` is range, `stmts` is body
 * - while_stmt: `expr` is condition, `stmts` is body
 * - do_while_stmt: `stmts` is body, `expr` is condition
 * - break_stmt/continue_stmt: no additional fields
 * - switch_stmt: `expr` is switch expression, `switch_cases` holds case/default blocks
 */
ad_stmt: type = {
    public kind       : ad_stmt_kind = ad_stmt_kind::expr;
    public target     : std::string = "";                      // Variable name for decl/assign
    public type_name  : std::string = "";                      // Type string for declarations
    public decl_type  : std::shared_ptr<ad_type> = ();         // Structured type for declarations
    public op         : ad_op_kind = ad_op_kind::assign;       // For compound_assign
    public expr       : ad_expr = ();                          // Main expression
    public stmts      : std::vector<ad_stmt> = ();             // Body statements
    public else_stmts : std::vector<ad_stmt> = ();             // Else branch for if_stmt

    // Loop-specific fields
    public init_stmt  : std::shared_ptr<ad_stmt> = ();         // for(init; ...; ...)
    public incr_expr  : ad_expr = ();                          // for(...; ...; incr)
    public range_expr : ad_expr = ();                          // foreach range expression

    // Switch-specific fields (case value expr, case body statements)
    public switch_cases: std::vector<std::pair<ad_expr, std::vector<ad_stmt>>> = ();
    public default_case: std::vector<ad_stmt> = ();            // default case body

    // Exception handling fields
    public catch_var  : std::string = "";                      // catch(Type catch_var)
    public catch_type : std::string = "";                      // catch type
    public catch_stmts: std::vector<ad_stmt> = ();             // catch body

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    // ===== Factory methods for declarations and assignments =====

    /**
     * @brief Create a declaration statement.
     * @param name Variable name.
     * @param type_name_ Variable type.
     * @param init Initializer expression.
     * @return Declaration statement node.
     */
    make_decl: (name: std::string, type_name_: std::string, init: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::decl;
        s.target = name;
        s.type_name = type_name_;
        s.expr = init;
        return s;
    }

    /**
     * @brief Create a declaration statement with structured type.
     * @param name Variable name.
     * @param t Structured type.
     * @param init Initializer expression.
     * @return Declaration statement node.
     */
    make_decl_typed: (name: std::string, t: ad_type, init: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::decl;
        s.target = name;
        s.type_name = ad_type_to_string(t);
        s.decl_type = std::make_shared<ad_type>(t);
        s.expr = init;
        return s;
    }

    /**
     * @brief Create an assignment statement.
     * @param name Target variable name.
     * @param value Value expression.
     * @return Assignment statement node.
     */
    make_assign: (name: std::string, value: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::assign;
        s.target = name;
        s.expr = value;
        return s;
    }

    /**
     * @brief Create a compound assignment statement (+=, -=, *=, /=, etc.).
     * @param name Target variable name.
     * @param op_ Compound assignment operator (assign_add, assign_sub, etc.).
     * @param value Value expression.
     * @return Compound assignment statement node.
     */
    make_compound_assign: (name: std::string, op_: ad_op_kind, value: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::compound_assign;
        s.target = name;
        s.op = op_;
        s.expr = value;
        return s;
    }

    /**
     * @brief Create an add-assignment statement (+=).
     * @param name Target variable name.
     * @param value Value expression to add.
     * @return Add-assignment statement node.
     * @note Legacy method - prefer make_compound_assign for new code.
     */
    make_assign_add: (name: std::string, value: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::assign_add;
        s.target = name;
        s.expr = value;
        return s;
    }

    /**
     * @brief Create a subtract-assignment statement (-=).
     * @param name Target variable name.
     * @param value Value expression to subtract.
     * @return Subtract-assignment statement node.
     */
    make_assign_sub: (name: std::string, value: ad_expr) -> ad_stmt = {
        return make_compound_assign(name, ad_op_kind::assign_sub, value);
    }

    /**
     * @brief Create a multiply-assignment statement (*=).
     * @param name Target variable name.
     * @param value Value expression to multiply.
     * @return Multiply-assignment statement node.
     */
    make_assign_mul: (name: std::string, value: ad_expr) -> ad_stmt = {
        return make_compound_assign(name, ad_op_kind::assign_mul, value);
    }

    /**
     * @brief Create a divide-assignment statement (/=).
     * @param name Target variable name.
     * @param value Value expression to divide.
     * @return Divide-assignment statement node.
     */
    make_assign_div: (name: std::string, value: ad_expr) -> ad_stmt = {
        return make_compound_assign(name, ad_op_kind::assign_div, value);
    }

    // ===== Factory methods for expression and return statements =====

    /**
     * @brief Create an expression statement.
     * @param e Expression to evaluate.
     * @return Expression statement node.
     */
    make_expr: (e: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::expr;
        s.expr = e;
        return s;
    }

    /**
     * @brief Create a return statement.
     * @param value Return value expression.
     * @return Return statement node.
     */
    make_return: (value: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::return_;
        s.expr = value;
        return s;
    }

    // ===== Factory methods for control flow =====

    /**
     * @brief Create a compound statement.
     * @param nested Nested statements.
     * @return Compound statement node.
     */
    make_compound: (nested: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::compound;
        s.stmts = nested;
        return s;
    }

    /**
     * @brief Create an if statement.
     * @param condition Condition expression.
     * @param then_body Statements for the then branch.
     * @param else_body Statements for the else branch (may be empty).
     * @return If statement node.
     */
    make_if: (condition: ad_expr, then_body: std::vector<ad_stmt>,
              else_body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::if_stmt;
        s.expr = condition;
        s.stmts = then_body;
        s.else_stmts = else_body;
        return s;
    }

    /**
     * @brief Create a C-style for loop.
     * @param init Initialization statement.
     * @param condition Loop condition.
     * @param increment Increment expression.
     * @param body Loop body statements.
     * @return For loop statement node.
     */
    make_for: (init: ad_stmt, condition: ad_expr, increment: ad_expr,
               body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::for_stmt;
        s.init_stmt = std::make_shared<ad_stmt>(init);
        s.expr = condition;
        s.incr_expr = increment;
        s.stmts = body;
        return s;
    }

    /**
     * @brief Create a range-based for loop (foreach).
     * @param var_name Loop variable name.
     * @param var_type Loop variable type.
     * @param range Range expression.
     * @param body Loop body statements.
     * @return Foreach loop statement node.
     */
    make_foreach: (var_name: std::string, var_type: std::string,
                   range: ad_expr, body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::foreach_stmt;
        s.target = var_name;
        s.type_name = var_type;
        s.range_expr = range;
        s.stmts = body;
        return s;
    }

    /**
     * @brief Create a while loop.
     * @param condition Loop condition.
     * @param body Loop body statements.
     * @return While loop statement node.
     */
    make_while: (condition: ad_expr, body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::while_stmt;
        s.expr = condition;
        s.stmts = body;
        return s;
    }

    /**
     * @brief Create a do-while loop.
     * @param body Loop body statements.
     * @param condition Loop condition (checked after body).
     * @return Do-while loop statement node.
     */
    make_do_while: (body: std::vector<ad_stmt>, condition: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::do_while_stmt;
        s.stmts = body;
        s.expr = condition;
        return s;
    }

    // ===== Factory methods for jump statements =====

    /**
     * @brief Create a break statement.
     * @return Break statement node.
     */
    make_break: () -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::break_stmt;
        return s;
    }

    /**
     * @brief Create a continue statement.
     * @return Continue statement node.
     */
    make_continue: () -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::continue_stmt;
        return s;
    }

    // ===== Factory methods for switch statement =====

    /**
     * @brief Create a switch statement.
     * @param switch_expr Expression to switch on.
     * @param cases Vector of (case_value, case_body) pairs.
     * @param default_body Default case body (may be empty).
     * @return Switch statement node.
     */
    make_switch: (switch_expr: ad_expr,
                  cases: std::vector<std::pair<ad_expr, std::vector<ad_stmt>>>,
                  default_body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::switch_stmt;
        s.expr = switch_expr;
        s.switch_cases = cases;
        s.default_case = default_body;
        return s;
    }

    // ===== Factory methods for exception handling =====

    /**
     * @brief Create a try-catch statement.
     * @param try_body Try block statements.
     * @param catch_type_ Exception type to catch.
     * @param catch_var_ Variable name for caught exception.
     * @param catch_body Catch block statements.
     * @return Try-catch statement node.
     */
    make_try_catch: (try_body: std::vector<ad_stmt>,
                     catch_type_: std::string, catch_var_: std::string,
                     catch_body: std::vector<ad_stmt>) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::try_catch;
        s.stmts = try_body;
        s.catch_type = catch_type_;
        s.catch_var = catch_var_;
        s.catch_stmts = catch_body;
        return s;
    }

    /**
     * @brief Create a throw statement.
     * @param throw_expr Expression to throw.
     * @return Throw statement node.
     */
    make_throw: (throw_expr: ad_expr) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::throw_stmt;
        s.expr = throw_expr;
        return s;
    }

    // ===== Legacy factory methods =====

    /**
     * @brief Create a raw code statement for inlined rule bodies.
     * @param code Raw Cpp2 code string to emit.
     * @return Raw code statement node.
     * @deprecated Will be removed after IR-based rule substitution is complete.
     */
    make_raw_code: (code: std::string) -> ad_stmt = {
        s: ad_stmt = ();
        s.kind = ad_stmt_kind::raw_code;
        s.target = code;  // Store raw code in target field
        return s;
    }
}

/**
 * @brief Typed IR parameter declaration.
 *
 * Represents a function parameter or return value in the AD IR.
 */
ad_param: type = {
    public name      : std::string = "";
    public type_name : std::string = "";
    public pass      : passing_style = passing_style::in;
    public is_active : bool = false;

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    /**
     * @brief Create a parameter.
     * @param name_ Parameter name.
     * @param type_name_ Parameter type.
     * @param pass_ Passing style.
     * @param is_active_ Whether the parameter is active for AD.
     * @return Parameter node.
     */
    make: (name_: std::string, type_name_: std::string, pass_: passing_style, is_active_: bool) -> ad_param = {
        p: ad_param = ();
        p.name = name_;
        p.type_name = type_name_;
        p.pass = pass_;
        p.is_active = is_active_;
        return p;
    }
}

/**
 * @brief Typed IR for a reverse-mode function.
 *
 * Contains the complete IR representation of a function being transformed
 * for reverse-mode autodiff, including parameters, returns, and the
 * forward/reverse pass statements.
 */
ad_function_ir: type = {
    public name    : std::string = "";
    public params  : std::vector<ad_param> = ();
    public returns : std::vector<ad_param> = ();
    public forward : std::vector<ad_stmt>  = ();
    public reverse : std::vector<ad_stmt>  = ();

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}
}

//-----------------------------------------------------------------------
//
//  AD IR Helper Modules - Convenience builders following Stan's pattern
//
//-----------------------------------------------------------------------

/**
 * @brief Type helper namespace for creating common types.
 *
 * Provides convenient factory functions for commonly used types in autodiff.
 * Following Stan compiler's MIR pattern of reducing boilerplate.
 */
ad_types: namespace = {

    // ===== Primitive types =====

    /**
     * @brief Create a double type.
     */
    double_: () -> ad_type = {
        return ad_type::make_double();
    }

    /**
     * @brief Create an int type.
     */
    int_: () -> ad_type = {
        return ad_type::make_int();
    }

    /**
     * @brief Create a size_t type.
     */
    size_t_: () -> ad_type = {
        return ad_type::make_size_t();
    }

    /**
     * @brief Create a bool type.
     */
    bool_: () -> ad_type = {
        return ad_type::make_bool();
    }

    /**
     * @brief Create a void type.
     */
    void_: () -> ad_type = {
        return ad_type::make_void();
    }

    /**
     * @brief Create an auto type.
     */
    auto_: () -> ad_type = {
        return ad_type::make_auto();
    }

    // ===== Qualified types =====

    /**
     * @brief Create const double type.
     */
    const_double: () -> ad_type = {
        return ad_type::make_const(ad_type::make_double());
    }

    /**
     * @brief Create double reference type (double&).
     */
    double_ref: () -> ad_type = {
        return ad_type::make_ref(ad_type::make_double());
    }

    /**
     * @brief Create const double reference type (const double&).
     */
    const_double_ref: () -> ad_type = {
        return ad_type::make_const(ad_type::make_ref(ad_type::make_double()));
    }

    /**
     * @brief Create int reference type (int&).
     */
    int_ref: () -> ad_type = {
        return ad_type::make_ref(ad_type::make_int());
    }

    /**
     * @brief Create const int reference type (const int&).
     */
    const_int_ref: () -> ad_type = {
        return ad_type::make_const(ad_type::make_ref(ad_type::make_int()));
    }

    // ===== Container types =====

    /**
     * @brief Create std::vector<T> type.
     * @param elem Element type.
     */
    std_vector: (elem: ad_type) -> ad_type = {
        return ad_type::make_std_vector(elem);
    }

    /**
     * @brief Create std::vector<double> type.
     */
    vector_double: () -> ad_type = {
        return ad_type::make_std_vector(ad_type::make_double());
    }

    /**
     * @brief Create std::vector<int> type.
     */
    vector_int: () -> ad_type = {
        return ad_type::make_std_vector(ad_type::make_int());
    }

    /**
     * @brief Create const reference to std::vector<double>.
     */
    const_vector_double_ref: () -> ad_type = {
        return ad_type::make_const(ad_type::make_ref(ad_type::make_std_vector(ad_type::make_double())));
    }

    // ===== Named types =====

    /**
     * @brief Create a named type.
     * @param name Type name.
     */
    named: (name: std::string) -> ad_type = {
        return ad_type::make_named(name);
    }

    /**
     * @brief Create a template type.
     * @param name Template name.
     * @param args Type arguments.
     */
    template_: (name: std::string, args: std::vector<ad_type>) -> ad_type = {
        return ad_type::make_template(name, args);
    }
}

/**
 * @brief Expression helper namespace for creating common expressions.
 *
 * Provides convenient factory functions for commonly used expressions in autodiff.
 */
ad_exprs: namespace = {

    // ===== Literals =====

    /**
     * @brief Create a variable reference (identifier).
     * @param name Variable name.
     */
    var: (name: std::string) -> ad_expr = {
        return ad_expr::make_identifier(name, "double");
    }

    /**
     * @brief Create a typed variable reference.
     * @param name Variable name.
     * @param type_name Type name.
     */
    var_typed: (name: std::string, type_name: std::string) -> ad_expr = {
        return ad_expr::make_identifier(name, type_name);
    }

    /**
     * @brief Create a double literal.
     * @param value Numeric value.
     */
    lit: (value: double) -> ad_expr = {
        return ad_expr::make_literal(std::to_string(value), "double");
    }

    /**
     * @brief Create a string literal.
     * @param value String value (as Cpp2 source).
     */
    lit_str: (value: std::string) -> ad_expr = {
        return ad_expr::make_literal(value, "double");
    }

    /**
     * @brief Create an integer literal.
     * @param value Integer value.
     */
    lit_int: (value: int) -> ad_expr = {
        return ad_expr::make_int_literal(value);
    }

    /**
     * @brief Create a boolean literal.
     * @param value Boolean value.
     */
    lit_bool: (value: bool) -> ad_expr = {
        return ad_expr::make_bool_literal(value);
    }

    /**
     * @brief Create zero literal (0.0).
     */
    zero: () -> ad_expr = {
        return ad_expr::make_literal("0.0", "double");
    }

    /**
     * @brief Create one literal (1.0).
     */
    one: () -> ad_expr = {
        return ad_expr::make_literal("1.0", "double");
    }

    // ===== Arithmetic operations =====

    /**
     * @brief Create addition expression.
     */
    add: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::add, lhs, rhs, "double");
    }

    /**
     * @brief Create subtraction expression.
     */
    sub: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::sub, lhs, rhs, "double");
    }

    /**
     * @brief Create multiplication expression.
     */
    mul: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::mul, lhs, rhs, "double");
    }

    /**
     * @brief Create division expression.
     */
    div: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::div, lhs, rhs, "double");
    }

    /**
     * @brief Create negation expression.
     */
    neg: (operand: ad_expr) -> ad_expr = {
        return ad_expr::make_unary(ad_op_kind::neg, operand, "double");
    }

    // ===== Comparison operations =====

    /**
     * @brief Create less-than comparison.
     */
    lt: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::lt, lhs, rhs, "bool");
    }

    /**
     * @brief Create greater-than comparison.
     */
    gt: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::gt, lhs, rhs, "bool");
    }

    /**
     * @brief Create less-or-equal comparison.
     */
    le: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::le, lhs, rhs, "bool");
    }

    /**
     * @brief Create greater-or-equal comparison.
     */
    ge: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::ge, lhs, rhs, "bool");
    }

    /**
     * @brief Create equality comparison.
     */
    eq: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::eq, lhs, rhs, "bool");
    }

    /**
     * @brief Create inequality comparison.
     */
    ne: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::ne, lhs, rhs, "bool");
    }

    // ===== Logical operations =====

    /**
     * @brief Create logical AND.
     */
    land: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::land, lhs, rhs, "bool");
    }

    /**
     * @brief Create logical OR.
     */
    lor: (lhs: ad_expr, rhs: ad_expr) -> ad_expr = {
        return ad_expr::make_binary(ad_op_kind::lor, lhs, rhs, "bool");
    }

    /**
     * @brief Create logical NOT.
     */
    lnot: (operand: ad_expr) -> ad_expr = {
        return ad_expr::make_unary(ad_op_kind::lnot, operand, "bool");
    }

    // ===== Increment/Decrement =====

    /**
     * @brief Create prefix increment (++x).
     */
    pre_inc: (operand: ad_expr) -> ad_expr = {
        return ad_expr::make_unary(ad_op_kind::pre_inc, operand, operand.type_name);
    }

    /**
     * @brief Create prefix decrement (--x).
     */
    pre_dec: (operand: ad_expr) -> ad_expr = {
        return ad_expr::make_unary(ad_op_kind::pre_dec, operand, operand.type_name);
    }

    /**
     * @brief Create postfix increment (x++).
     */
    post_inc: (operand: ad_expr) -> ad_expr = {
        return ad_expr::make_unary(ad_op_kind::post_inc, operand, operand.type_name);
    }

    /**
     * @brief Create postfix decrement (x--).
     */
    post_dec: (operand: ad_expr) -> ad_expr = {
        return ad_expr::make_unary(ad_op_kind::post_dec, operand, operand.type_name);
    }

    // ===== Access expressions =====

    /**
     * @brief Create member access (obj.member).
     */
    member: (obj: ad_expr, member_name: std::string) -> ad_expr = {
        return ad_expr::make_member(obj, member_name, false, "auto");
    }

    /**
     * @brief Create pointer member access (obj->member).
     */
    arrow: (obj: ad_expr, member_name: std::string) -> ad_expr = {
        return ad_expr::make_member(obj, member_name, true, "auto");
    }

    /**
     * @brief Create subscript access (arr[index]).
     */
    subscript: (arr: ad_expr, index: ad_expr) -> ad_expr = {
        return ad_expr::make_subscript(arr, index, "auto");
    }

    /**
     * @brief Create subscript with integer index.
     */
    at: (arr: ad_expr, index: int) -> ad_expr = {
        return ad_expr::make_subscript(arr, ad_expr::make_int_literal(index), "auto");
    }

    // ===== Calls =====

    /**
     * @brief Create a function call.
     * @param fn Function name.
     * @param args Call arguments.
     */
    call: (fn: std::string, args: std::vector<ad_expr>) -> ad_expr = {
        return ad_expr::make_call(fn, ad_op_kind::call, args, "double");
    }

    /**
     * @brief Create a method call.
     * @param obj Object expression.
     * @param method Method name.
     * @param args Call arguments.
     */
    method: (obj: ad_expr, method_name: std::string, args: std::vector<ad_expr>) -> ad_expr = {
        return ad_expr::make_method_call(obj, method_name, args, "auto");
    }

    /**
     * @brief Create a method call with no arguments.
     */
    method0: (obj: ad_expr, method_name: std::string) -> ad_expr = {
        empty_args: std::vector<ad_expr> = ();
        return ad_expr::make_method_call(obj, method_name, empty_args, "auto");
    }

    // ===== Common math function calls =====

    /**
     * @brief Create sin(x) call.
     */
    sin: (x: ad_expr) -> ad_expr = {
        args: std::vector<ad_expr> = ();
        args.push_back(x);
        return ad_expr::make_call("std::sin", ad_op_kind::call, args, "double");
    }

    /**
     * @brief Create cos(x) call.
     */
    cos: (x: ad_expr) -> ad_expr = {
        args: std::vector<ad_expr> = ();
        args.push_back(x);
        return ad_expr::make_call("std::cos", ad_op_kind::call, args, "double");
    }

    /**
     * @brief Create exp(x) call.
     */
    exp: (x: ad_expr) -> ad_expr = {
        args: std::vector<ad_expr> = ();
        args.push_back(x);
        return ad_expr::make_call("std::exp", ad_op_kind::call, args, "double");
    }

    /**
     * @brief Create log(x) call.
     */
    log: (x: ad_expr) -> ad_expr = {
        args: std::vector<ad_expr> = ();
        args.push_back(x);
        return ad_expr::make_call("std::log", ad_op_kind::call, args, "double");
    }

    /**
     * @brief Create sqrt(x) call.
     */
    sqrt: (x: ad_expr) -> ad_expr = {
        args: std::vector<ad_expr> = ();
        args.push_back(x);
        return ad_expr::make_call("std::sqrt", ad_op_kind::call, args, "double");
    }

    /**
     * @brief Create pow(x, y) call.
     */
    pow: (x: ad_expr, y: ad_expr) -> ad_expr = {
        args: std::vector<ad_expr> = ();
        args.push_back(x);
        args.push_back(y);
        return ad_expr::make_call("std::pow", ad_op_kind::call, args, "double");
    }

    // ===== Ternary and other =====

    /**
     * @brief Create a ternary expression (cond ? then : else).
     */
    ternary: (cond: ad_expr, then_expr: ad_expr, else_expr: ad_expr) -> ad_expr = {
        return ad_expr::make_ternary(cond, then_expr, else_expr, then_expr.type_name);
    }

    /**
     * @brief Create a parenthesized expression.
     */
    paren: (inner: ad_expr) -> ad_expr = {
        return ad_expr::make_paren(inner);
    }
}

/**
 * @brief Statement helper namespace for creating common statements.
 *
 * Provides convenient factory functions for commonly used statements in autodiff.
 */
ad_stmts: namespace = {

    // ===== Declarations =====

    /**
     * @brief Create a declaration with initializer.
     */
    decl_init: (name: std::string, init: ad_expr) -> ad_stmt = {
        return ad_stmt::make_decl(name, init.type_name, init);
    }

    /**
     * @brief Create a double declaration with initializer.
     */
    decl_double: (name: std::string, init: ad_expr) -> ad_stmt = {
        return ad_stmt::make_decl(name, "double", init);
    }

    /**
     * @brief Create an int declaration with initializer.
     */
    decl_int: (name: std::string, init: ad_expr) -> ad_stmt = {
        return ad_stmt::make_decl(name, "int", init);
    }

    /**
     * @brief Create a declaration with zero initializer.
     */
    decl_zero: (name: std::string) -> ad_stmt = {
        return ad_stmt::make_decl(name, "double", ad_exprs::zero());
    }

    // ===== Assignments =====

    /**
     * @brief Create an assignment.
     */
    assign: (target: std::string, value: ad_expr) -> ad_stmt = {
        return ad_stmt::make_assign(target, value);
    }

    /**
     * @brief Create an add-assignment (+=).
     */
    assign_add: (target: std::string, value: ad_expr) -> ad_stmt = {
        return ad_stmt::make_assign_add(target, value);
    }

    /**
     * @brief Create a subtract-assignment (-=).
     */
    assign_sub: (target: std::string, value: ad_expr) -> ad_stmt = {
        return ad_stmt::make_assign_sub(target, value);
    }

    /**
     * @brief Create a multiply-assignment (*=).
     */
    assign_mul: (target: std::string, value: ad_expr) -> ad_stmt = {
        return ad_stmt::make_assign_mul(target, value);
    }

    /**
     * @brief Create a divide-assignment (/=).
     */
    assign_div: (target: std::string, value: ad_expr) -> ad_stmt = {
        return ad_stmt::make_assign_div(target, value);
    }

    // ===== Control flow =====

    /**
     * @brief Create an if-then statement (no else).
     */
    if_then: (cond: ad_expr, body: std::vector<ad_stmt>) -> ad_stmt = {
        empty: std::vector<ad_stmt> = ();
        return ad_stmt::make_if(cond, body, empty);
    }

    /**
     * @brief Create an if-then-else statement.
     */
    if_else: (cond: ad_expr, then_body: std::vector<ad_stmt>, else_body: std::vector<ad_stmt>) -> ad_stmt = {
        return ad_stmt::make_if(cond, then_body, else_body);
    }

    /**
     * @brief Create a for loop with int counter.
     * @param var Loop variable name.
     * @param start Start value.
     * @param end_exclusive End value (exclusive).
     * @param body Loop body.
     */
    for_range: (var: std::string, start: int, end_exclusive: ad_expr, body: std::vector<ad_stmt>) -> ad_stmt = {
        init := ad_stmt::make_decl(var, "int", ad_expr::make_int_literal(start));
        cond := ad_exprs::lt(ad_exprs::var_typed(var, "int"), end_exclusive);
        incr := ad_exprs::post_inc(ad_exprs::var_typed(var, "int"));
        return ad_stmt::make_for(init, cond, incr, body);
    }

    /**
     * @brief Create a while loop.
     */
    while_: (cond: ad_expr, body: std::vector<ad_stmt>) -> ad_stmt = {
        return ad_stmt::make_while(cond, body);
    }

    /**
     * @brief Create a foreach loop.
     */
    foreach: (var: std::string, range: ad_expr, body: std::vector<ad_stmt>) -> ad_stmt = {
        return ad_stmt::make_foreach(var, "auto", range, body);
    }

    // ===== Jump statements =====

    /**
     * @brief Create a return statement.
     */
    return_: (value: ad_expr) -> ad_stmt = {
        return ad_stmt::make_return(value);
    }

    /**
     * @brief Create a break statement.
     */
    break_: () -> ad_stmt = {
        return ad_stmt::make_break();
    }

    /**
     * @brief Create a continue statement.
     */
    continue_: () -> ad_stmt = {
        return ad_stmt::make_continue();
    }

    // ===== Expression statements =====

    /**
     * @brief Create an expression statement.
     */
    expr: (e: ad_expr) -> ad_stmt = {
        return ad_stmt::make_expr(e);
    }

    /**
     * @brief Create a compound statement (block).
     */
    block: (stmts: std::vector<ad_stmt>) -> ad_stmt = {
        return ad_stmt::make_compound(stmts);
    }
}

//-----------------------------------------------------------------------
//
//  AD IR debug dump functions
//
//-----------------------------------------------------------------------

/**
 * @brief Convert ad_op_kind to string for debug output.
 * @param op Operation kind.
 * @return String representation.
 */
ad_op_kind_to_string: (op: ad_op_kind) -> std::string = {
    // Arithmetic
    if op == ad_op_kind::add        { return "add"; }
    if op == ad_op_kind::sub        { return "sub"; }
    if op == ad_op_kind::mul        { return "mul"; }
    if op == ad_op_kind::div        { return "div"; }
    if op == ad_op_kind::mod        { return "mod"; }
    if op == ad_op_kind::neg        { return "neg"; }
    if op == ad_op_kind::pos        { return "pos"; }

    // Increment/Decrement
    if op == ad_op_kind::pre_inc    { return "pre_inc"; }
    if op == ad_op_kind::pre_dec    { return "pre_dec"; }
    if op == ad_op_kind::post_inc   { return "post_inc"; }
    if op == ad_op_kind::post_dec   { return "post_dec"; }

    // Comparison
    if op == ad_op_kind::eq         { return "eq"; }
    if op == ad_op_kind::ne         { return "ne"; }
    if op == ad_op_kind::lt         { return "lt"; }
    if op == ad_op_kind::gt         { return "gt"; }
    if op == ad_op_kind::le         { return "le"; }
    if op == ad_op_kind::ge         { return "ge"; }
    if op == ad_op_kind::spaceship  { return "spaceship"; }

    // Logical
    if op == ad_op_kind::land       { return "land"; }
    if op == ad_op_kind::lor        { return "lor"; }
    if op == ad_op_kind::lnot       { return "lnot"; }

    // Bitwise
    if op == ad_op_kind::band       { return "band"; }
    if op == ad_op_kind::bor        { return "bor"; }
    if op == ad_op_kind::bxor       { return "bxor"; }
    if op == ad_op_kind::bnot       { return "bnot"; }
    if op == ad_op_kind::shl        { return "shl"; }
    if op == ad_op_kind::shr        { return "shr"; }

    // Pointer/Reference
    if op == ad_op_kind::deref      { return "deref"; }
    if op == ad_op_kind::addr_of    { return "addr_of"; }

    // Assignment
    if op == ad_op_kind::assign     { return "assign"; }
    if op == ad_op_kind::assign_add { return "assign_add"; }
    if op == ad_op_kind::assign_sub { return "assign_sub"; }
    if op == ad_op_kind::assign_mul { return "assign_mul"; }
    if op == ad_op_kind::assign_div { return "assign_div"; }
    if op == ad_op_kind::assign_mod { return "assign_mod"; }
    if op == ad_op_kind::assign_band{ return "assign_band"; }
    if op == ad_op_kind::assign_bor { return "assign_bor"; }
    if op == ad_op_kind::assign_bxor{ return "assign_bxor"; }
    if op == ad_op_kind::assign_shl { return "assign_shl"; }
    if op == ad_op_kind::assign_shr { return "assign_shr"; }

    // Member access
    if op == ad_op_kind::dot        { return "dot"; }
    if op == ad_op_kind::arrow      { return "arrow"; }

    // Other
    if op == ad_op_kind::call       { return "call"; }
    if op == ad_op_kind::literal    { return "literal"; }
    if op == ad_op_kind::identifier { return "identifier"; }

    return "unknown";
}

/**
 * @brief Convert ad_expr_kind to string for debug output.
 * @param kind Expression kind.
 * @return String representation.
 */
ad_expr_kind_to_string: (kind: ad_expr_kind) -> std::string = {
    if kind == ad_expr_kind::literal         { return "literal"; }
    if kind == ad_expr_kind::identifier      { return "identifier"; }
    if kind == ad_expr_kind::unary           { return "unary"; }
    if kind == ad_expr_kind::binary          { return "binary"; }
    if kind == ad_expr_kind::ternary         { return "ternary"; }
    if kind == ad_expr_kind::member          { return "member"; }
    if kind == ad_expr_kind::subscript       { return "subscript"; }
    if kind == ad_expr_kind::call            { return "call"; }
    if kind == ad_expr_kind::method_call     { return "method_call"; }
    if kind == ad_expr_kind::cast            { return "cast"; }
    if kind == ad_expr_kind::construct       { return "construct"; }
    if kind == ad_expr_kind::paren           { return "paren"; }
    if kind == ad_expr_kind::lambda          { return "lambda"; }
    if kind == ad_expr_kind::initializer_list{ return "initializer_list"; }
    return "unknown";
}

/**
 * @brief Convert ad_stmt_kind to string for debug output.
 * @param kind Statement kind.
 * @return String representation.
 */
ad_stmt_kind_to_string: (kind: ad_stmt_kind) -> std::string = {
    if kind == ad_stmt_kind::decl           { return "decl"; }
    if kind == ad_stmt_kind::assign         { return "assign"; }
    if kind == ad_stmt_kind::compound_assign{ return "compound_assign"; }
    if kind == ad_stmt_kind::assign_add     { return "assign_add"; }
    if kind == ad_stmt_kind::if_stmt        { return "if_stmt"; }
    if kind == ad_stmt_kind::for_stmt       { return "for_stmt"; }
    if kind == ad_stmt_kind::foreach_stmt   { return "foreach_stmt"; }
    if kind == ad_stmt_kind::while_stmt     { return "while_stmt"; }
    if kind == ad_stmt_kind::do_while_stmt  { return "do_while_stmt"; }
    if kind == ad_stmt_kind::switch_stmt    { return "switch_stmt"; }
    if kind == ad_stmt_kind::return_        { return "return"; }
    if kind == ad_stmt_kind::break_stmt     { return "break_stmt"; }
    if kind == ad_stmt_kind::continue_stmt  { return "continue_stmt"; }
    if kind == ad_stmt_kind::compound       { return "compound"; }
    if kind == ad_stmt_kind::expr_stmt      { return "expr_stmt"; }
    if kind == ad_stmt_kind::expr           { return "expr"; }
    if kind == ad_stmt_kind::raw_code       { return "raw_code"; }
    if kind == ad_stmt_kind::try_catch      { return "try_catch"; }
    if kind == ad_stmt_kind::throw_stmt     { return "throw_stmt"; }
    return "unknown";
}

/**
 * @brief Print indentation for debug output.
 * @param indent Indentation level.
 */
ad_ir_print_indent: (indent: i32) = {
    i := 0;
    while i < indent next i++ {
        std::cout << "  ";
    }
}

/**
 * @brief Print a readable form of an IR expression.
 * @param e Expression to dump.
 * @param indent Indentation level.
 */
ad_ir_debug_dump_expr: (e: ad_expr, indent: i32 = 0) = {
    ad_ir_print_indent(indent);
    std::cout << "expr(" << ad_expr_kind_to_string(e.kind) << ")";

    if e.kind == ad_expr_kind::literal {
        std::cout << " value=" << e.name << " type=" << e.type_name << "\n";
    }
    else if e.kind == ad_expr_kind::identifier {
        std::cout << " name=" << e.name << " type=" << e.type_name << "\n";
    }
    else if e.kind == ad_expr_kind::unary {
        std::cout << " op=" << ad_op_kind_to_string(e.op) << " type=" << e.type_name << "\n";
        for e.args do (arg) {
            ad_ir_debug_dump_expr(arg, indent + 1);
        }
    }
    else if e.kind == ad_expr_kind::binary {
        std::cout << " op=" << ad_op_kind_to_string(e.op) << " type=" << e.type_name << "\n";
        for e.args do (arg) {
            ad_ir_debug_dump_expr(arg, indent + 1);
        }
    }
    else if e.kind == ad_expr_kind::ternary {
        std::cout << " type=" << e.type_name << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "condition:\n";
        if e.args.ssize() > 0 { ad_ir_debug_dump_expr(e.args[0], indent + 2); }
        ad_ir_print_indent(indent + 1);
        std::cout << "then:\n";
        if e.args.ssize() > 1 { ad_ir_debug_dump_expr(e.args[1], indent + 2); }
        ad_ir_print_indent(indent + 1);
        std::cout << "else:\n";
        if e.args.ssize() > 2 { ad_ir_debug_dump_expr(e.args[2], indent + 2); }
    }
    else if e.kind == ad_expr_kind::member {
        std::cout << " member=" << e.member_name << " op=" << ad_op_kind_to_string(e.op) << " type=" << e.type_name << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "object:\n";
        if !e.args.empty() { ad_ir_debug_dump_expr(e.args[0], indent + 2); }
    }
    else if e.kind == ad_expr_kind::subscript {
        std::cout << " type=" << e.type_name << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "array:\n";
        if e.args.ssize() > 0 { ad_ir_debug_dump_expr(e.args[0], indent + 2); }
        ad_ir_print_indent(indent + 1);
        std::cout << "index:\n";
        if e.args.ssize() > 1 { ad_ir_debug_dump_expr(e.args[1], indent + 2); }
    }
    else if e.kind == ad_expr_kind::call {
        std::cout << " func=" << e.name << " op=" << ad_op_kind_to_string(e.op) << " type=" << e.type_name << "\n";
        for e.args do (arg) {
            ad_ir_debug_dump_expr(arg, indent + 1);
        }
    }
    else if e.kind == ad_expr_kind::method_call {
        std::cout << " method=" << e.name << " type=" << e.type_name << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "object:\n";
        if !e.args.empty() { ad_ir_debug_dump_expr(e.args[0], indent + 2); }
        ad_ir_print_indent(indent + 1);
        std::cout << "arguments:\n";
        i := 1;
        while i < e.args.ssize() next i++ {
            ad_ir_debug_dump_expr(e.args[i], indent + 2);
        }
    }
    else if e.kind == ad_expr_kind::cast {
        std::cout << " cast_kind=" << e.name << " type=" << e.type_name << "\n";
        for e.args do (arg) {
            ad_ir_debug_dump_expr(arg, indent + 1);
        }
    }
    else if e.kind == ad_expr_kind::construct {
        std::cout << " type=" << e.name << "\n";
        for e.args do (arg) {
            ad_ir_debug_dump_expr(arg, indent + 1);
        }
    }
    else if e.kind == ad_expr_kind::paren {
        std::cout << " type=" << e.type_name << "\n";
        if !e.args.empty() { ad_ir_debug_dump_expr(e.args[0], indent + 1); }
    }
    else if e.kind == ad_expr_kind::initializer_list {
        std::cout << " type=" << e.type_name << " elements=" << e.args.ssize() << "\n";
        for e.args do (arg) {
            ad_ir_debug_dump_expr(arg, indent + 1);
        }
    }
    else {
        std::cout << " type=" << e.type_name << "\n";
    }
}

/**
 * @brief Print a readable form of an IR statement.
 * @param s Statement to dump.
 * @param indent Indentation level.
 */
ad_ir_debug_dump_stmt: (s: ad_stmt, indent: i32 = 0) = {
    ad_ir_print_indent(indent);
    std::cout << "stmt(" << ad_stmt_kind_to_string(s.kind) << ")";

    if s.kind == ad_stmt_kind::decl {
        std::cout << " target=" << s.target << " type=" << s.type_name << "\n";
        ad_ir_debug_dump_expr(s.expr, indent + 1);
    }
    else if s.kind == ad_stmt_kind::assign {
        std::cout << " target=" << s.target << "\n";
        ad_ir_debug_dump_expr(s.expr, indent + 1);
    }
    else if s.kind == ad_stmt_kind::compound_assign {
        std::cout << " target=" << s.target << " op=" << ad_op_kind_to_string(s.op) << "\n";
        ad_ir_debug_dump_expr(s.expr, indent + 1);
    }
    else if s.kind == ad_stmt_kind::assign_add {
        std::cout << " target=" << s.target << " (+=)\n";
        ad_ir_debug_dump_expr(s.expr, indent + 1);
    }
    else if s.kind == ad_stmt_kind::if_stmt {
        std::cout << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "condition:\n";
        ad_ir_debug_dump_expr(s.expr, indent + 2);
        ad_ir_print_indent(indent + 1);
        std::cout << "then (" << s.stmts.ssize() << " statements):\n";
        for s.stmts do (nested) {
            ad_ir_debug_dump_stmt(nested, indent + 2);
        }
        if !s.else_stmts.empty() {
            ad_ir_print_indent(indent + 1);
            std::cout << "else (" << s.else_stmts.ssize() << " statements):\n";
            for s.else_stmts do (nested) {
                ad_ir_debug_dump_stmt(nested, indent + 2);
            }
        }
    }
    else if s.kind == ad_stmt_kind::for_stmt {
        std::cout << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "init:\n";
        if s.init_stmt != nullptr {
            ad_ir_debug_dump_stmt(s.init_stmt*, indent + 2);
        }
        ad_ir_print_indent(indent + 1);
        std::cout << "condition:\n";
        ad_ir_debug_dump_expr(s.expr, indent + 2);
        ad_ir_print_indent(indent + 1);
        std::cout << "increment:\n";
        ad_ir_debug_dump_expr(s.incr_expr, indent + 2);
        ad_ir_print_indent(indent + 1);
        std::cout << "body (" << s.stmts.ssize() << " statements):\n";
        for s.stmts do (nested) {
            ad_ir_debug_dump_stmt(nested, indent + 2);
        }
    }
    else if s.kind == ad_stmt_kind::foreach_stmt {
        std::cout << " var=" << s.target << " type=" << s.type_name << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "range:\n";
        ad_ir_debug_dump_expr(s.range_expr, indent + 2);
        ad_ir_print_indent(indent + 1);
        std::cout << "body (" << s.stmts.ssize() << " statements):\n";
        for s.stmts do (nested) {
            ad_ir_debug_dump_stmt(nested, indent + 2);
        }
    }
    else if s.kind == ad_stmt_kind::while_stmt {
        std::cout << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "condition:\n";
        ad_ir_debug_dump_expr(s.expr, indent + 2);
        ad_ir_print_indent(indent + 1);
        std::cout << "body (" << s.stmts.ssize() << " statements):\n";
        for s.stmts do (nested) {
            ad_ir_debug_dump_stmt(nested, indent + 2);
        }
    }
    else if s.kind == ad_stmt_kind::do_while_stmt {
        std::cout << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "body (" << s.stmts.ssize() << " statements):\n";
        for s.stmts do (nested) {
            ad_ir_debug_dump_stmt(nested, indent + 2);
        }
        ad_ir_print_indent(indent + 1);
        std::cout << "condition:\n";
        ad_ir_debug_dump_expr(s.expr, indent + 2);
    }
    else if s.kind == ad_stmt_kind::break_stmt {
        std::cout << "\n";
    }
    else if s.kind == ad_stmt_kind::continue_stmt {
        std::cout << "\n";
    }
    else if s.kind == ad_stmt_kind::expr || s.kind == ad_stmt_kind::expr_stmt {
        std::cout << "\n";
        ad_ir_debug_dump_expr(s.expr, indent + 1);
    }
    else if s.kind == ad_stmt_kind::return_ {
        std::cout << "\n";
        ad_ir_debug_dump_expr(s.expr, indent + 1);
    }
    else if s.kind == ad_stmt_kind::compound {
        std::cout << " (" << s.stmts.ssize() << " statements)\n";
        for s.stmts do (nested) {
            ad_ir_debug_dump_stmt(nested, indent + 1);
        }
    }
    else if s.kind == ad_stmt_kind::try_catch {
        std::cout << "\n";
        ad_ir_print_indent(indent + 1);
        std::cout << "try (" << s.stmts.ssize() << " statements):\n";
        for s.stmts do (nested) {
            ad_ir_debug_dump_stmt(nested, indent + 2);
        }
        ad_ir_print_indent(indent + 1);
        std::cout << "catch(" << s.catch_type << " " << s.catch_var << ") (" << s.catch_stmts.ssize() << " statements):\n";
        for s.catch_stmts do (nested) {
            ad_ir_debug_dump_stmt(nested, indent + 2);
        }
    }
    else if s.kind == ad_stmt_kind::throw_stmt {
        std::cout << "\n";
        ad_ir_debug_dump_expr(s.expr, indent + 1);
    }
    else if s.kind == ad_stmt_kind::raw_code {
        std::cout << " code='" << s.target << "'\n";
    }
    else {
        std::cout << "\n";
    }
}

/**
 * @brief Print a readable form of a function IR.
 * @param ir Function IR to dump.
 */
ad_ir_debug_dump: (ir: ad_function_ir) = {
    std::cout << "=== AD Function IR: " << ir.name << " ===\n";

    std::cout << "Parameters:\n";
    for ir.params do (p) {
        std::cout << "  " << p.name << ": " << p.type_name
                  << " (active=" << p.is_active << ")\n";
    }

    std::cout << "Returns:\n";
    for ir.returns do (r) {
        std::cout << "  " << r.name << ": " << r.type_name
                  << " (active=" << r.is_active << ")\n";
    }

    std::cout << "Forward pass (" << ir.forward.ssize() << " statements):\n";
    for ir.forward do (s) {
        ad_ir_debug_dump_stmt(s, 1);
    }

    std::cout << "Reverse pass (" << ir.reverse.ssize() << " statements):\n";
    for ir.reverse do (s) {
        ad_ir_debug_dump_stmt(s, 1);
    }

    std::cout << "=== End AD Function IR ===\n";
}

//-----------------------------------------------------------------------
//
//  IR-based parameter substitution for rule bodies
//
//-----------------------------------------------------------------------

/**
 * @brief Substitution context maps parameter names to IR expressions.
 *
 * Used during rule body parsing to replace parameter names (like res_val,
 * x_adj) with the actual IR expressions for those values/adjoints.
 */
ad_substitution_context: type = {
    public substitutions : std::vector<std::pair<std::string, ad_expr>> = ();

    /// Default constructor
    operator=: (out this) = {}

    /// Copy constructor
    operator=: (out this, that) = {}

    /**
     * @brief Add a substitution mapping.
     * @param param_name Parameter name to substitute (e.g., "res_val", "x_adj").
     * @param expr IR expression to substitute in place of the parameter.
     */
    add: (inout this, param_name: std::string, expr: ad_expr) = {
        substitutions.push_back(std::make_pair(param_name, expr));
    }

    /**
     * @brief Find a substitution for a parameter name.
     * @param name Parameter name to look up.
     * @param result Output parameter for the found expression.
     * @return true if found, false otherwise.
     */
    find: (this, name: std::string, inout result: ad_expr) -> bool = {
        for substitutions do (sub) {
            if sub.first == name {
                result = sub.second;
                return true;
            }
        }
        return false;
    }

    /**
     * @brief Check if a name has a substitution.
     * @param name Parameter name to check.
     * @return true if a substitution exists for this name.
     */
    has: (this, name: std::string) -> bool = {
        for substitutions do (sub) {
            if sub.first == name {
                return true;
            }
        }
        return false;
    }

    /**
     * @brief Get the number of substitutions.
     * @return Number of substitution mappings.
     */
    size: (this) -> int = {
        return substitutions.ssize();
    }
}

/**
 * @brief Substitute parameter names in an IR expression.
 *
 * Recursively walks the expression tree and replaces identifier nodes
 * whose names match entries in the substitution context.
 *
 * @param expr Expression to process.
 * @param ctx Substitution context mapping names to replacement expressions.
 * @return New expression with substitutions applied.
 */
substitute_expr_params: (expr: ad_expr, ctx: ad_substitution_context) -> ad_expr = {
    // Check if this is an identifier that should be substituted
    if expr.kind == ad_expr_kind::identifier {
        substituted: ad_expr = ();
        if ctx.find(expr.name, substituted) {
            return substituted;
        }
        return expr;
    }

    // For literals, return as-is
    if expr.kind == ad_expr_kind::literal {
        return expr;
    }

    // For unary expressions, substitute in the operand
    if expr.kind == ad_expr_kind::unary {
        if !expr.args.empty() {
            new_operand := substitute_expr_params(expr.args[0], ctx);
            return ad_expr::make_unary(expr.op, new_operand, expr.type_name);
        }
        return expr;
    }

    // For binary expressions, substitute in both operands
    if expr.kind == ad_expr_kind::binary {
        if expr.args.ssize() >= 2 {
            new_lhs := substitute_expr_params(expr.args[0], ctx);
            new_rhs := substitute_expr_params(expr.args[1], ctx);
            return ad_expr::make_binary(expr.op, new_lhs, new_rhs, expr.type_name);
        }
        return expr;
    }

    // For function calls, substitute in the arguments
    if expr.kind == ad_expr_kind::call {
        new_args: std::vector<ad_expr> = ();
        for expr.args do (arg) {
            new_args.push_back(substitute_expr_params(arg, ctx));
        }
        return ad_expr::make_call(expr.name, expr.op, new_args, expr.type_name);
    }

    return expr;
}

/**
 * @brief Substitute parameter names in an IR statement.
 *
 * Recursively processes the statement and any nested expressions/statements,
 * replacing identifier names according to the substitution context.
 *
 * @param stmt Statement to process.
 * @param ctx Substitution context mapping names to replacement expressions.
 * @return New statement with substitutions applied.
 */
substitute_stmt_params: (stmt: ad_stmt, ctx: ad_substitution_context) -> ad_stmt = {
    if stmt.kind == ad_stmt_kind::decl {
        // Substitute in the initializer expression
        new_init := substitute_expr_params(stmt.expr, ctx);
        // Also check if the target name should be substituted
        new_target := stmt.target;
        target_expr: ad_expr = ();
        if ctx.find(stmt.target, target_expr) && target_expr.kind == ad_expr_kind::identifier {
            new_target = target_expr.name;
        }
        return ad_stmt::make_decl(new_target, stmt.type_name, new_init);
    }

    if stmt.kind == ad_stmt_kind::assign {
        new_value := substitute_expr_params(stmt.expr, ctx);
        // Check if target should be substituted
        new_target := stmt.target;
        target_expr: ad_expr = ();
        if ctx.find(stmt.target, target_expr) && target_expr.kind == ad_expr_kind::identifier {
            new_target = target_expr.name;
        }
        return ad_stmt::make_assign(new_target, new_value);
    }

    if stmt.kind == ad_stmt_kind::assign_add {
        new_value := substitute_expr_params(stmt.expr, ctx);
        // Check if target should be substituted
        new_target := stmt.target;
        target_expr: ad_expr = ();
        if ctx.find(stmt.target, target_expr) && target_expr.kind == ad_expr_kind::identifier {
            new_target = target_expr.name;
        }
        return ad_stmt::make_assign_add(new_target, new_value);
    }

    if stmt.kind == ad_stmt_kind::expr {
        new_expr := substitute_expr_params(stmt.expr, ctx);
        return ad_stmt::make_expr(new_expr);
    }

    if stmt.kind == ad_stmt_kind::return_ {
        new_value := substitute_expr_params(stmt.expr, ctx);
        return ad_stmt::make_return(new_value);
    }

    if stmt.kind == ad_stmt_kind::compound {
        new_stmts: std::vector<ad_stmt> = ();
        for stmt.stmts do (s) {
            new_stmts.push_back(substitute_stmt_params(s, ctx));
        }
        return ad_stmt::make_compound(new_stmts);
    }

    if stmt.kind == ad_stmt_kind::if_stmt {
        new_cond := substitute_expr_params(stmt.expr, ctx);
        new_then: std::vector<ad_stmt> = ();
        for stmt.stmts do (s) {
            new_then.push_back(substitute_stmt_params(s, ctx));
        }
        new_else: std::vector<ad_stmt> = ();
        for stmt.else_stmts do (s) {
            new_else.push_back(substitute_stmt_params(s, ctx));
        }
        return ad_stmt::make_if(new_cond, new_then, new_else);
    }

    // For raw_code, we can't substitute (it's a string), return as-is
    return stmt;
}

//-----------------------------------------------------------------------
//
//  Subtask 3: ad_rule registry + discovery
//
//-----------------------------------------------------------------------

/**
 * @brief Metadata for a discovered user-defined AD rule type.
 *
 * An ad_rule is a nested type inside a @autodiff<"reverse"> annotated type
 * that declares `name`, `n_args`, `is_member`, `forward`, and `reverse` members.
 * These rules override the default differentiation for specific function calls.
 */
ad_rule_meta: type = {
    public name      : std::string = "";
    public n_args    : int = 0;
    public is_member : bool = false;
    public rule_type : std::string = "";  // Type name for debug
    public forward_body : std::string = "";  // Forward function body (for debug/emit)
    public reverse_body : std::string = "";  // Reverse function body (for debug/emit)

    // NEW: Store AST statements from the reverse() function body for IR-based parsing
    // This enables proper IR-based substitution instead of string manipulation
    public reverse_body_stmts : std::vector<statement> = ();
    public has_reverse_body_stmts : bool = false;

    // DEPRECATED: Stores the reverse() function body string for inlining at code generation time.
    // This is extracted during rule discovery. Will be removed after IR migration is complete.
    public reverse_body_str : std::string = "";
    public has_reverse_body : bool = false;

    /// Default constructor
    operator=: (out this) = {}

    // ad_rule_meta is move-only because it contains std::vector<statement>
    // and statement has deleted copy assignment (it's @polymorphic_base)

    /// Move constructor
    operator=: (out this, move that) = {
        name = that.name;
        n_args = that.n_args;
        is_member = that.is_member;
        rule_type = that.rule_type;
        forward_body = that.forward_body;
        reverse_body = that.reverse_body;
        reverse_body_stmts = that.reverse_body_stmts;
        has_reverse_body_stmts = that.has_reverse_body_stmts;
        reverse_body_str = that.reverse_body_str;
        has_reverse_body = that.has_reverse_body;
    }

    /**
     * @brief Create rule metadata.
     * @param name_ Rule name (matches function name).
     * @param n_args_ Number of arguments.
     * @param is_member_ Whether this is a member function rule.
     * @param rule_type_ Name of the rule type (for debug).
     * @return Rule metadata.
     */
    make: (name_: std::string, n_args_: int, is_member_: bool, rule_type_: std::string) -> ad_rule_meta = {
        r: ad_rule_meta = ();
        r.name = name_;
        r.n_args = n_args_;
        r.is_member = is_member_;
        r.rule_type = rule_type_;
        return r;
    }
}

/**
 * @brief Result of applying an AD rule's reverse body.
 *
 * Contains the generated IR statements.
 * All data is owned by this result - no references to registry internals.
 * If ir_success is false, the caller MUST fail with an error - there is no fallback.
 */
ad_reverse_rule_result: type = {
    public found           : bool = false;              // Whether rule exists
    public ir_stmts        : std::vector<ad_stmt> = (); // Generated IR statements
    public ir_success      : bool = false;              // Whether IR parsing succeeded
    public rule_type       : std::string = "";          // For debug messages
    public error_message   : std::string = "";          // Error description if parsing failed

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make_not_found: () -> ad_reverse_rule_result = {
        r: ad_reverse_rule_result = ();
        return r;
    }

    make_success: (stmts: std::vector<ad_stmt>, rule_type_: std::string) -> ad_reverse_rule_result = {
        r: ad_reverse_rule_result = ();
        r.found = true;
        r.ir_stmts = stmts;
        r.ir_success = true;
        r.rule_type = rule_type_;
        return r;
    }

    make_parse_error: (rule_type_: std::string, error_msg: std::string) -> ad_reverse_rule_result = {
        r: ad_reverse_rule_result = ();
        r.found = true;           // Rule was found
        r.ir_success = false;     // But parsing failed
        r.rule_type = rule_type_;
        r.error_message = error_msg;
        return r;
    }
}

/**
 * @brief Registry of user-defined AD rules.
 *
 * Rules are discovered by scanning nested types in the annotated type.
 * The registry owns all rules and provides methods to apply them.
 * Rules never leave the registry - callers receive results, not rule references.
 */
ad_rule_registry: type = {
    public rules: std::vector<ad_rule_meta> = ();

    /// Default constructor
    operator=: (out this) = {}

    /**
     * @brief Register a new rule (takes ownership via move).
     * @param rule Rule metadata to register.
     */
    register_rule: (inout this, move rule: ad_rule_meta) = {
        rules.push_back(rule);
    }

    /**
     * @brief Check if a rule exists.
     */
    has_rule: (this, name_: std::string, n_args_: int, is_member_: bool) -> bool = {
        for rules do (r) {
            if r.name == name_ && r.n_args == n_args_ && r.is_member == is_member_ {
                return true;
            }
        }
        return false;
    }

    /**
     * @brief Get rule type name for debug messages.
     */
    get_rule_type: (this, name_: std::string, n_args_: int, is_member_: bool) -> std::string = {
        for rules do (r) {
            if r.name == name_ && r.n_args == n_args_ && r.is_member == is_member_ {
                return r.rule_type;
            }
        }
        return "";
    }

    /**
     * @brief Apply rule's reverse body with substitutions.
     *
     * Parses the rule's reverse body statements into IR with the given substitution context.
     * All work is done inside the registry - no rule references escape.
     * If the rule has no body or parsing fails, ir_success will be false.
     *
     * @param name_ Function name to match.
     * @param n_args_ Number of arguments.
     * @param is_member_ Whether to match member functions.
     * @param ctx Substitution context for parameter replacement.
     * @return Result with IR statements. Caller MUST check ir_success and fail if false.
     */
    apply_reverse_rule: (this, name_: std::string, n_args_: int, is_member_: bool,
                         ctx: ad_substitution_context) -> ad_reverse_rule_result = {
        for rules do (r) {
            if r.name == name_ && r.n_args == n_args_ && r.is_member == is_member_ {
                // Found the rule - it MUST have a parseable body
                if !r.has_reverse_body_stmts {
                    // Rule exists but has no body - this is a user error
                    return ad_reverse_rule_result::make_parse_error(r.rule_type,
                        "Rule '" + name_ + "' has no reverse() body statements");
                }

                ir_stmts: std::vector<ad_stmt> = ();
                if !parse_rule_body_stmts(r.reverse_body_stmts, ctx, ir_stmts) {
                    // Parsing failed - this is an error, not a fallback case
                    return ad_reverse_rule_result::make_parse_error(r.rule_type,
                        "Failed to parse reverse() body for rule '" + name_ + "'");
                }

                return ad_reverse_rule_result::make_success(ir_stmts, r.rule_type);
            }
        }
        return ad_reverse_rule_result::make_not_found();
    }

    /**
     * @brief Get the number of registered rules.
     * @return Number of rules.
     */
    size: (this) -> int = {
        return rules.ssize();
    }
}

/**
 * @brief Debug dump for ad_rule_meta.
 * @param rule Rule to dump.
 */
ad_rule_debug_dump: (rule: ad_rule_meta) = {
    std::cout << "  rule: name=" << rule.name
              << " n_args=" << rule.n_args
              << " is_member=" << rule.is_member
              << " type=" << rule.rule_type << "\n";
}

/**
 * @brief Debug dump for ad_rule_registry.
 * @param reg Registry to dump.
 */
ad_rule_registry_debug_dump: (reg: ad_rule_registry) = {
    std::cout << "=== AD Rule Registry (" << reg.size() << " rules) ===\n";
    for reg.rules do (r) {
        ad_rule_debug_dump(r);
    }
    std::cout << "=== End AD Rule Registry ===\n";
}

/**
 * @brief Check if a type member looks like an ad_rule definition.
 *
 * A valid ad_rule type must have:
 * - A `name` member object (string)
 * - An `n_args` member object (int)
 * - A `forward` member function
 * - A `reverse` member function
 *
 * @param member_type Type declaration to check.
 * @return True if this looks like an ad_rule.
 */
is_ad_rule_type: (member_type: meta::type_declaration) -> bool = {
    has_name := false;
    has_n_args := false;
    has_forward := false;
    has_reverse := false;

    // Check member objects for name and n_args
    for member_type.get_member_objects() do (obj) {
        if obj.name() == "name" {
            has_name = true;
        }
        if obj.name() == "n_args" {
            has_n_args = true;
        }
    }

    // Check member functions for forward and reverse
    for member_type.get_member_functions() do (func) {
        if func.name() == "forward" {
            has_forward = true;
        }
        if func.name() == "reverse" {
            has_reverse = true;
        }
    }

    return has_name && has_n_args && has_forward && has_reverse;
}

/**
 * @brief Extract ad_rule metadata from a type declaration.
 *
 * Assumes is_ad_rule_type() has already returned true.
 * Extracts the reverse() function body for later inlining.
 *
 * @param member_type Pointer to the rule type to extract from.
 * @return Extracted rule metadata with reverse_body_str set.
 */
extract_ad_rule_meta: (member_type: *meta::type_declaration) -> ad_rule_meta = {
    rule: ad_rule_meta = ();
    rule.rule_type = member_type*.name() as std::string;

    // Extract name, n_args, is_member from member objects
    for member_type*.get_member_objects() do (obj) {
        if obj.name() == "name" {
            // Try to get the initializer value
            if obj.has_initializer() {
                rule.name = obj.initializer().to_string();
                // Strip quotes if present
                if rule.name.starts_with("\"") && rule.name.ends_with("\"") {
                    rule.name = rule.name.substr(1, rule.name.ssize() - 2);
                }
            }
        }
        if obj.name() == "n_args" {
            if obj.has_initializer() {
                init_str := obj.initializer().to_string();
                val: int = 0;
                if string_util::string_to_int(init_str, val) {
                    rule.n_args = val;
                }
            }
        }
        if obj.name() == "is_member" {
            if obj.has_initializer() {
                init_str := obj.initializer().to_string();
                rule.is_member = (init_str == "true");
            }
        }
    }

    // Extract the reverse() function body for later inlining
    // Extract the reverse() function body for later inlining
    for member_type*.get_member_functions() do (func) {
        if func.name() == "reverse" && func.has_compound_body() {
            body := func.get_compound_body();

            // NEW: Store the AST statements for IR-based parsing
            for body.get_statements() do (move stmt) {
                rule.reverse_body_stmts.push_back(stmt);
            }
            rule.has_reverse_body_stmts = true;
            std::cout << "AD: Extracted " << rule.reverse_body_stmts.ssize()
                      << " AST statements for '" << rule.name << "'\n";

            // DEPRECATED: Also build the string representation for backward compatibility
            body_stmts: std::string = "";
            for body.get_statements() do (stmt) {
                stmt_str := stmt.to_string() as std::string;

                // BUG FIX: Trim trailing whitespace before checking last character
                trimmed := stmt_str;
                while !trimmed.empty() && std::isspace(trimmed.back() as int) != 0 {
                    trimmed.pop_back();
                }

                // Add semicolon if not present (statement may or may not have it)
                if !trimmed.empty() && trimmed.back() != ';' && trimmed.back() != '}' {
                    body_stmts += trimmed + ";\n";
                } else if !trimmed.empty() {
                    body_stmts += trimmed + "\n";
                }
            }
            rule.reverse_body_str = body_stmts;
            rule.has_reverse_body = true;
            std::cout << "AD: Extracted reverse() body for '" << rule.name << "': " << rule.reverse_body_str << "\n";
        }
    }

    return rule;
}

/**
 * @brief Discover ad_rule types inside an annotated type.
 *
 * Scans all nested types and checks if they conform to the ad_rule pattern.
 * Matching rules are registered in the output registry.
 *
 * @param t Type declaration to scan.
 * @param out Registry to populate.
 */
discover_ad_rules: (t: meta::type_declaration, inout out: ad_rule_registry) = {
    std::cout << "AD: Discovering rules in type " << t.name() << "\n";

    // 1. Nested types inside the @autodiff type (highest priority)
    for t.get_member_types() do (inout member_type) {
        type_name := member_type.name();
        std::cout << "AD: Checking nested type: " << type_name << "\n";

        if is_ad_rule_type(member_type) {
            rule := extract_ad_rule_meta(member_type&);
            std::cout << "AD: Found nested rule: " << rule.name << " (n_args=" << rule.n_args << ")\n";
            out.register_rule(rule);
        }
    }

    // 2. Sibling types in the parent namespace (same file only)
    //    NOTE: #include doesn't merge ASTs, so rules from included files are NOT visible.
    //    Users must define all rules in the same file as their @autodiff type.
    if t.parent_is_nonglobal_namespace() {
        ns := t.get_parent().as_nonglobal_namespace();
        std::cout << "AD: Checking siblings in namespace '" << ns.name() << "'\n";

        // DEBUG: List ALL members returned by get_members()
        members := ns.get_members();
        std::cout << "AD DEBUG: ns.get_members() returned " << members.size() << " members:\n";
        for members do (m) {
            std::cout << "AD DEBUG:   - '" << m.name() << "' is_type=" << m.is_type()
                      << " is_func=" << m.is_function() << " is_ns=" << m.is_namespace() << "\n";
        }

        for members do (m) {
            if m.is_type() && !m.is_same(t) {
                type_name := m.name() as std::string;
                if type_name.starts_with("ad_rule_") {
                    sibling_type := m.as_type();
                    if is_ad_rule_type(sibling_type) {
                        rule := extract_ad_rule_meta(sibling_type&);
                        std::cout << "AD: Found sibling rule: " << rule.name << " (n_args=" << rule.n_args << ")\n";
                        out.register_rule(rule);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------
//
//  Subtask 3b: Rule body extraction and inlining
//
//-----------------------------------------------------------------------

/**
 * @brief Result of extracting a rule's reverse() body.
 */
ad_rule_body_result: type = {
    public ok       : bool = false;
    public body_str : std::string = "";

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (ok_: bool, body_: std::string) -> ad_rule_body_result = {
        r: ad_rule_body_result = ();
        r.ok = ok_;
        r.body_str = body_;
        return r;
    }
}

/**
 * @brief Get the reverse() function body from an ad_rule.
 *
 * Returns the body string that was extracted during rule discovery.
 *
 * @param rule The rule metadata (must have has_reverse_body set).
 * @return Result with ok=true and body string if available.
 */
extract_rule_reverse_body: (rule: ad_rule_meta) -> ad_rule_body_result = {
    if rule.has_reverse_body {
        return ad_rule_body_result::make(true, rule.reverse_body_str);
    }
    return ad_rule_body_result::make(false, "");
}

//-----------------------------------------------------------------------
//
//  AST-to-IR parsing for rule bodies
//
//-----------------------------------------------------------------------

/**
 * @brief Result of parsing an AST expression to IR.
 */
ad_parse_expr_result: type = {
    public ok   : bool = false;
    public expr : ad_expr = ();

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (ok_: bool, expr_: ad_expr) -> ad_parse_expr_result = {
        r: ad_parse_expr_result = ();
        r.ok = ok_;
        r.expr = expr_;
        return r;
    }

    make_fail: () -> ad_parse_expr_result = {
        r: ad_parse_expr_result = ();
        r.ok = false;
        return r;
    }
}

/**
 * @brief Result of parsing an AST statement to IR.
 */
ad_parse_stmt_result: type = {
    public ok   : bool = false;
    public stmt : ad_stmt = ();

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (ok_: bool, stmt_: ad_stmt) -> ad_parse_stmt_result = {
        r: ad_parse_stmt_result = ();
        r.ok = ok_;
        r.stmt = stmt_;
        return r;
    }

    make_fail: () -> ad_parse_stmt_result = {
        r: ad_parse_stmt_result = ();
        r.ok = false;
        return r;
    }
}

/**
 * @brief Parse an AST expression into IR with parameter substitution.
 *
 * This function converts a meta::expression AST node into an ad_expr IR node,
 * applying substitutions from the context during parsing. This is used to
 * parse rule bodies like "x_adj += std::cos(x_val) * res_adj" into IR.
 *
 * @param expr The AST expression to parse.
 * @param ctx Substitution context mapping parameter names to IR expressions.
 * @return Result with ok=true and parsed expression if successful.
 */

/**
 * @brief Map operator string to ad_op_kind.
 */
map_op_string: (op: std::string) -> ad_op_kind = {
    if op == "+" { return ad_op_kind::add; }
    if op == "-" { return ad_op_kind::sub; }
    if op == "*" { return ad_op_kind::mul; }
    if op == "/" { return ad_op_kind::div; }
    if op == "%" { return ad_op_kind::mod; }
    if op == "==" { return ad_op_kind::eq; }
    if op == "!=" { return ad_op_kind::ne; }
    if op == "<" { return ad_op_kind::lt; }
    if op == ">" { return ad_op_kind::gt; }
    if op == "<=" { return ad_op_kind::le; }
    if op == ">=" { return ad_op_kind::ge; }
    if op == "&&" { return ad_op_kind::land; }
    if op == "||" { return ad_op_kind::lor; }
    if op == "&" { return ad_op_kind::band; }
    if op == "|" { return ad_op_kind::bor; }
    if op == "^" { return ad_op_kind::bxor; }
    if op == "<<" { return ad_op_kind::shl; }
    if op == ">>" { return ad_op_kind::shr; }
    return ad_op_kind::add; // Default
}

// Assignment expression: = += -= etc.
parse_assignment_expr: (expr: meta::assignment_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() {
        return ad_parse_expr_result::make_fail();
    }
    // If only one term, no assignment - drill down
    if terms.ssize() == 1 {
        return parse_logical_or_expr(terms.front().get_term(), ctx);
    }
    // Actual assignment - for now just parse the RHS
    // (assignments in rule bodies are handled at statement level)
    return parse_logical_or_expr(terms.back().get_term(), ctx);
}

// Logical OR: ||
parse_logical_or_expr: (expr: meta::logical_or_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_logical_and_expr(terms.front().get_term(), ctx);
    }
    // LHS is first term (with empty operator)
    lhs_result := parse_logical_and_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    // Process remaining terms (which have actual operators)
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_logical_and_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::lor, result, rhs_result.expr, "bool");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Logical AND: &&
parse_logical_and_expr: (expr: meta::logical_and_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_bit_or_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_bit_or_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_bit_or_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::land, result, rhs_result.expr, "bool");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Bit OR: |
parse_bit_or_expr: (expr: meta::bit_or_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_bit_xor_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_bit_xor_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_bit_xor_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::bor, result, rhs_result.expr, "int");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Bit XOR: ^
parse_bit_xor_expr: (expr: meta::bit_xor_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_bit_and_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_bit_and_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_bit_and_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::bxor, result, rhs_result.expr, "int");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Bit AND: &
parse_bit_and_expr: (expr: meta::bit_and_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_equality_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_equality_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_equality_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::band, result, rhs_result.expr, "int");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Equality: == !=
parse_equality_expr: (expr: meta::equality_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_relational_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_relational_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_relational_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        op_kind := map_op_string(terms[i].get_op());
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "bool");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Relational: < > <= >=
parse_relational_expr: (expr: meta::relational_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_compare_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_compare_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_compare_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        op_kind := map_op_string(terms[i].get_op());
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "bool");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Compare: <=>
parse_compare_expr: (expr: meta::compare_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_shift_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_shift_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_shift_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        result = ad_expr::make_binary(ad_op_kind::spaceship, result, rhs_result.expr, "auto");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Shift: << >>
parse_shift_expr: (expr: meta::shift_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_additive_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_additive_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_additive_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        op_kind := map_op_string(terms[i].get_op());
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "int");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Additive: + -
parse_additive_expr: (expr: meta::additive_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        return parse_multiplicative_expr(terms.front().get_term(), ctx);
    }
    lhs_result := parse_multiplicative_expr(terms.front().get_term(), ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    i := 1;
    while i < terms.ssize() {
        rhs_result := parse_multiplicative_expr(terms[i].get_term(), ctx);
        if !rhs_result.ok { return rhs_result; }
        op_kind := map_op_string(terms[i].get_op());
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "double");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Multiplicative: * / %
parse_multiplicative_expr: (expr: meta::multiplicative_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    terms := expr.get_terms();
    std::cout << "AD: multiplicative terms.ssize() = " << terms.ssize() << "\n";
    if terms.empty() { return ad_parse_expr_result::make_fail(); }
    if terms.ssize() == 1 {
        // No actual multiplication - drill down to is_as_expression -> prefix -> postfix
        // First term has empty operator, so we get the is_as_expression and drill down
        is_as := terms.front().get_term();
        pf_expr := is_as.get_expression();  // prefix_expression
        pf := pf_expr.get_postfix_expression();
        return parse_postfix_expr(pf, ctx);
    }
    // Actual multiplication/division
    // Get the LHS via the first term (which has empty operator)
    lhs_is_as := terms.front().get_term();
    lhs_pf_expr := lhs_is_as.get_expression();
    lhs_pf := lhs_pf_expr.get_postfix_expression();
    lhs_result := parse_postfix_expr(lhs_pf, ctx);
    if !lhs_result.ok { return lhs_result; }
    result := lhs_result.expr;
    // Process remaining terms (which have actual operators)
    i := 1;
    while i < terms.ssize() {
        term := terms[i];
        rhs_is_as := term.get_term();
        rhs_pf_expr := rhs_is_as.get_expression();
        rhs_pf := rhs_pf_expr.get_postfix_expression();
        rhs_result := parse_postfix_expr(rhs_pf, ctx);
        if !rhs_result.ok { return rhs_result; }
        op_str := term.get_op();
        std::cout << "AD: multiplicative op = '" << op_str << "'\n";
        op_kind := map_op_string(op_str);
        result = ad_expr::make_binary(op_kind, result, rhs_result.expr, "double");
        i++;
    }
    return ad_parse_expr_result::make(true, result);
}

// Prefix expression: - ! etc.
parse_prefix_expr: (expr: meta::prefix_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    ops := expr.get_ops();
    pf := expr.get_postfix_expression();
    inner_result := parse_postfix_expr(pf, ctx);
    if !inner_result.ok { return inner_result; }

    // Apply prefix operators from right to left
    result := inner_result.expr;
    i := ops.ssize() - 1;
    while i >= 0 {
        op_str := ops[i];
        if op_str == "-" {
            result = ad_expr::make_unary(ad_op_kind::neg, result, "double");
        } else if op_str == "!" {
            result = ad_expr::make_unary(ad_op_kind::lnot, result, "bool");
        } else if op_str == "~" {
            result = ad_expr::make_unary(ad_op_kind::bnot, result, "int");
        } else if op_str == "*" {
            result = ad_expr::make_unary(ad_op_kind::deref, result, "double");
        } else if op_str == "&" {
            result = ad_expr::make_unary(ad_op_kind::addr_of, result, "double*");
        }
        i--;
    }
    return ad_parse_expr_result::make(true, result);
}

// Postfix expression: identifiers, literals, function calls, member access
parse_postfix_expr: (expr: meta::postfix_expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    std::cout << "AD: parse_postfix_expr: '" << expr.to_string() << "'\n";

    // Check if it's a simple identifier
    if expr.is_identifier() {
        id_name := expr.as_identifier();
        substituted: ad_expr = ();
        if ctx.find(id_name, substituted) {
            return ad_parse_expr_result::make(true, substituted);
        }
        return ad_parse_expr_result::make(true, ad_expr::make_identifier(id_name, "double"));
    }

    // Check if it's a literal
    if expr.is_literal() {
        return ad_parse_expr_result::make(true, ad_expr::make_literal(expr.as_literal(), "double"));
    }

    // For function calls and other postfix operations, use the string representation for now
    // TODO: Properly handle function calls via get_terms()
    expr_str := expr.to_string() as std::string;
    return ad_parse_expr_result::make(true, ad_expr::make_identifier(expr_str, "double"));
}

/**
 * @brief Parse an expression from meta::expression into IR.
 * Entry point - dispatches to assignment_expression parsing.
 */
parse_rule_expr: (expr: meta::expression, ctx: ad_substitution_context) -> ad_parse_expr_result = {
    std::cout << "AD: parse_rule_expr: '" << expr.to_string() << "'\n";

    // Check for simple cases first
    if expr.is_identifier() {
        id_name := expr.to_string() as std::string;
        substituted: ad_expr = ();
        if ctx.find(id_name, substituted) {
            return ad_parse_expr_result::make(true, substituted);
        }
        return ad_parse_expr_result::make(true, ad_expr::make_identifier(id_name, "double"));
    }

    if expr.is_literal() {
        return ad_parse_expr_result::make(true, ad_expr::make_literal(expr.to_string(), "double"));
    }

    // Traverse the expression hierarchy starting with assignment_expression
    if expr.is_assignment_expression() {
        return parse_assignment_expr(expr.as_assignment_expression(), ctx);
    }

    std::cout << "AD: Failed to parse expression: '" << expr.to_string() << "'\n";
    return ad_parse_expr_result::make_fail();
}

/**
 * @brief Parse an AST statement into IR with parameter substitution.
 *
 * This function converts a meta::statement AST node into an ad_stmt IR node,
 * applying substitutions from the context during parsing.
 *
 * Handles:
 * - Expression statements (e.g., "x_adj += cos(x_val) * res_adj;")
 * - Compound statements (blocks)
 * - If statements
 *
 * @param stmt The AST statement to parse.
 * @param ctx Substitution context mapping parameter names to IR expressions.
 * @return Result with ok=true and parsed statement if successful.
 */
parse_rule_stmt: (stmt: meta::statement, ctx: ad_substitution_context) -> ad_parse_stmt_result = {
    stmt_str := string_util::trim_copy(stmt.to_string());

    std::cout << "AD: parse_rule_stmt: '" << stmt_str << "'\n";

    // Check for compound statement
    if stmt.is_compound_statement() {
        compound := stmt.as_compound_statement();
        nested_stmts: std::vector<ad_stmt> = ();
        for compound.get_statements() do (s) {
            nested_result := parse_rule_stmt(s, ctx);
            if !nested_result.ok {
                std::cout << "AD: Failed to parse nested statement in compound\n";
                return ad_parse_stmt_result::make_fail();
            }
            nested_stmts.push_back(nested_result.stmt);
        }
        return ad_parse_stmt_result::make(true, ad_stmt::make_compound(nested_stmts));
    }

    // Check for selection (if) statement
    if stmt.is_selection_statement() {
        sel := stmt.as_selection_statement();
        // Parse condition - need to convert logical_or_expression to expression
        // For now, use the string representation
        cond_str := sel.get_expression().to_string() as std::string;
        std::cout << "AD: If condition string: '" << cond_str << "'\n";

        // Create a simple condition expression (for now just use the string)
        cond_expr := ad_expr::make_identifier(cond_str, "bool");

        // Parse then branch
        then_compound := sel.get_true_branch();
        then_stmts: std::vector<ad_stmt> = ();
        for then_compound.get_statements() do (s) {
            then_result := parse_rule_stmt(s, ctx);
            if !then_result.ok {
                std::cout << "AD: Failed to parse if then-branch\n";
                return ad_parse_stmt_result::make_fail();
            }
            then_stmts.push_back(then_result.stmt);
        }

        // Parse else branch if present
        else_stmts: std::vector<ad_stmt> = ();
        if sel.has_false_branch() {
            else_compound := sel.get_false_branch();
            for else_compound.get_statements() do (s) {
                else_result := parse_rule_stmt(s, ctx);
                if else_result.ok {
                    else_stmts.push_back(else_result.stmt);
                }
            }
        }

        return ad_parse_stmt_result::make(true,
            ad_stmt::make_if(cond_expr, then_stmts, else_stmts));
    }

    // Check for expression statement - this is the common case for AD rules
    // Statements like "x_adj += cos(x_val) * res_adj;"
    if stmt.is_expression_statement() {
        expr_stmt := stmt.as_expression_statement();
        expr := expr_stmt.get_expression();
        expr_str2 := expr.to_string() as std::string;

        std::cout << "AD: Expression statement: '" << expr_str2 << "'\n";

        // Check for assignment-add (+=)
        // Format: target += value
        plus_eq_pos := expr_str2.find("+=");
        if plus_eq_pos != std::string::npos {
            target_str := string_util::trim_copy(expr_str2.substr(0, plus_eq_pos));
            value_str := string_util::trim_copy(expr_str2.substr(plus_eq_pos + 2));
            // Remove trailing semicolon if present
            while !value_str.empty() && value_str.back() == ';' {
                value_str.pop_back();
            }
            value_str = string_util::trim_copy(value_str);

            std::cout << "AD: Assignment-add: target='" << target_str << "' value='" << value_str << "'\n";

            // DEBUG: Check what the expression actually is
            std::cout << "AD DEBUG: expr.is_assignment_expression() = " << expr.is_assignment_expression() << "\n";
            std::cout << "AD DEBUG: expr.is_expression_list() = " << expr.is_expression_list() << "\n";
            std::cout << "AD DEBUG: expr.is_identifier() = " << expr.is_identifier() << "\n";

            // Substitute the target if needed
            new_target := target_str;
            target_expr: ad_expr = ();
            if ctx.find(target_str, target_expr) && target_expr.kind == ad_expr_kind::identifier {
                new_target = target_expr.name;
            }

            // For assignment expressions, use get_terms() to get the operator and RHS
            // terms[0] is LHS with empty operator, terms[1] has the actual operator and RHS
            if expr.is_assignment_expression() {
                assign_expr := expr.as_assignment_expression();
                terms := assign_expr.get_terms();
                std::cout << "AD DEBUG: assignment_expression has " << terms.ssize() << " terms\n";

                if terms.ssize() >= 2 {
                    // terms[0] = LHS (empty op), terms[1] = RHS (with operator like +=)
                    op_str := terms[1].get_op();
                    std::cout << "AD DEBUG: operator is '" << op_str << "'\n";

                    if op_str == "+=" {
                        // Get the RHS term (logical_or_expression)
                        rhs_term := terms[1].get_term();
                        std::cout << "AD DEBUG: RHS term is '" << rhs_term.to_string() << "'\n";

                        // Parse the RHS expression using proper AST traversal
                        rhs_result := parse_logical_or_expr(rhs_term, ctx);
                        if rhs_result.ok {
                            return ad_parse_stmt_result::make(true,
                                ad_stmt::make_assign_add(new_target, rhs_result.expr));
                        }
                        std::cout << "AD DEBUG: Failed to parse RHS expression\n";
                    }
                }
            }

            // Try to substitute the value string directly
            subst_val: ad_expr = ();
            if ctx.find(value_str, subst_val) {
                return ad_parse_stmt_result::make(true,
                    ad_stmt::make_assign_add(new_target, subst_val));
            }

            // Could not parse RHS of += expression
            std::cout << "AD: ERROR - Could not parse += RHS value: '" << value_str << "'\n";
            return ad_parse_stmt_result::make_fail();
        }

        // Check for regular assignment (=)
        eq_pos := expr_str2.find('=');
        if eq_pos != std::string::npos && (eq_pos == 0 || expr_str2[eq_pos - 1] != '+') {
            // Make sure it's not +=, -=, etc.
            if eq_pos > 0uz && (expr_str2[eq_pos - 1] == '-' || expr_str2[eq_pos - 1] == '*' || expr_str2[eq_pos - 1] == '/') {
                // Skip compound assignment
            } else {
                target_str := string_util::trim_copy(expr_str2.substr(0, eq_pos));
                value_str := string_util::trim_copy(expr_str2.substr(eq_pos + 1));
                // Remove trailing semicolon if present
                while !value_str.empty() && value_str.back() == ';' {
                    value_str.pop_back();
                }
                value_str = string_util::trim_copy(value_str);

                // Substitute target if needed
                new_target := target_str;
                target_expr: ad_expr = ();
                if ctx.find(target_str, target_expr) && target_expr.kind == ad_expr_kind::identifier {
                    new_target = target_expr.name;
                }

                // For simple assignment, get the RHS via expression list
                if expr.is_expression_list() {
                    exp_list := expr.as_expression_list();
                    sub_exprs := exp_list.get_expressions();
                    // The second expression should be the RHS
                    if sub_exprs.ssize() >= 2 {
                        rhs_result := parse_rule_expr(sub_exprs[1], ctx);
                        if rhs_result.ok {
                            return ad_parse_stmt_result::make(true,
                                ad_stmt::make_assign(new_target, rhs_result.expr));
                        }
                    }
                }

                // Try to substitute the value string directly
                subst_val: ad_expr = ();
                if ctx.find(value_str, subst_val) {
                    return ad_parse_stmt_result::make(true,
                        ad_stmt::make_assign(new_target, subst_val));
                }

                // Could not parse RHS of assignment expression
                std::cout << "AD: ERROR - Could not parse assignment RHS value: '" << value_str << "'\n";
                return ad_parse_stmt_result::make_fail();
            }
        }

        // General expression statement - just wrap the parsed expression
        expr_result := parse_rule_expr(expr, ctx);
        if expr_result.ok {
            return ad_parse_stmt_result::make(true, ad_stmt::make_expr(expr_result.expr));
        }
    }

    std::cout << "AD: Failed to parse statement: '" << stmt_str << "'\n";
    return ad_parse_stmt_result::make_fail();
}

/**
 * @brief Parse all AST statements from a rule body into IR.
 *
 * This is the main entry point for converting a rule's reverse() body
 * from AST to IR with parameter substitution applied.
 *
 * @param stmts Vector of AST statements from the rule body.
 * @param ctx Substitution context mapping parameter names to IR expressions.
 * @param out Output vector for the parsed IR statements.
 * @return true if all statements were successfully parsed.
 */
parse_rule_body_stmts: (stmts: std::vector<meta::statement>, ctx: ad_substitution_context,
                        inout out: std::vector<ad_stmt>) -> bool = {
    std::cout << "AD DEBUG: parse_rule_body_stmts called with " << stmts.ssize() << " statements\n";
    for stmts do (stmt) {
        std::cout << "AD DEBUG: About to call parse_rule_stmt\n";
        result := parse_rule_stmt(stmt, ctx);
        std::cout << "AD DEBUG: parse_rule_stmt returned ok=" << result.ok << "\n";
        if !result.ok {
            return false;
        }
        out.push_back(result.stmt);
    }
    return true;
}

/**
 * @brief Standard parameter names used in ad_rule reverse() functions.
 *
 * These are the expected parameter names that will be substituted:
 * - res_val: result value from forward pass
 * - res_adj: incoming adjoint (to propagate)
 * - x_val, y_val, z_val, w_val: argument values
 * - x_adj, y_adj, z_adj, w_adj: argument adjoints (inout)
 */
ad_rule_param_names: type = {
    result_val: std::string = "res_val";
    result_adj: std::string = "res_adj";
    arg_vals: std::array<std::string, 4> = ("x_val", "y_val", "z_val", "w_val");
    arg_adjs: std::array<std::string, 4> = ("x_adj", "y_adj", "z_adj", "w_adj");
}

/**
 * @brief Check if a character is an identifier character (alphanumeric or underscore).
 */
is_identifier_char: (c: char) -> bool = {
    return std::isalnum(c as int) != 0 || c == '_';
}

/**
 * @brief Replace all whole-word occurrences of a pattern in a string.
 *
 * Only replaces when the pattern is not part of a larger identifier.
 * For example, replacing "x_val" won't affect "extra_x_val" or "x_value".
 *
 * @param str The input string.
 * @param pattern The pattern to find (must be a whole word/identifier).
 * @param replacement The replacement string.
 * @return String with all whole-word occurrences replaced.
 */
replace_word: (str: std::string, pattern: std::string, replacement: std::string) -> std::string = {
    if pattern.empty() {
        return str;
    }

    result: std::string = "";
    pos: size_t = 0;
    pattern_len := pattern.size();

    while pos < str.size() {
        found := str.find(pattern, pos);
        if found == std::string::npos {
            // No more matches, append rest of string
            result += str.substr(pos);
            break;
        }

        // Check word boundaries
        is_word_start := (found == 0) || !is_identifier_char(str[found - 1]);
        is_word_end := (found + pattern_len >= str.size()) || !is_identifier_char(str[found + pattern_len]);

        if is_word_start && is_word_end {
            // It's a whole word match - do the replacement
            result += str.substr(pos, found - pos);
            result += replacement;
            pos = found + pattern_len;
        } else {
            // Not a whole word - copy including the first char and continue
            result += str.substr(pos, found - pos + 1);
            pos = found + 1;
        }
    }

    return result;
}

/**
 * @brief Substitute rule parameter names with actual values in body string.
 *
 * Performs textual substitution to replace:
 * - res_val -> target value name (e.g., "_t0_val")
 * - res_adj -> target adjoint name (e.g., "_t0_adj")
 * - x_val -> first argument value name
 * - x_adj -> first argument adjoint name
 * etc.
 *
 * Uses word-boundary-aware replacement to avoid corrupting identifiers like
 * "extra_res_val" or "x_value".
 *
 * @param body_str Original body string from rule.
 * @param target_val Name of the target variable's value.
 * @param target_adj Name of the target variable's adjoint.
 * @param arg_vals Vector of argument value names.
 * @param arg_adjs Vector of argument adjoint names.
 * @return Body string with substitutions applied.
 */
substitute_rule_params: (body_str: std::string,
                         target_val: std::string, target_adj: std::string,
                         arg_vals: std::vector<std::string>,
                         arg_adjs: std::vector<std::string>) -> std::string = {
    result := body_str;

    // Substitute result value and adjoint using word-boundary-aware replacement
    result = replace_word(result, "res_val", target_val);
    result = replace_word(result, "res_adj", target_adj);

    // Substitute argument values and adjoints
    // BUG FIX: Check both arg_vals and arg_adjs sizes
    param_names: std::array<std::string, 4> = ("x", "y", "z", "w");
    i := 0;
    while i < param_names.ssize() && i < arg_vals.ssize() && i < arg_adjs.ssize() {
        val_param := param_names[i] + "_val";
        adj_param := param_names[i] + "_adj";

        // Always substitute value params
        result = replace_word(result, val_param, arg_vals[i]);

        // BUG FIX: Only substitute adjoint if it's not empty
        // Empty adjoints occur when argument is not an identifier (e.g., literal)
        if !arg_adjs[i].empty() {
            result = replace_word(result, adj_param, arg_adjs[i]);
        } else {
            // Check if the rule body references this adjoint - if so, it's an error
            if result.find(adj_param) != std::string::npos {
                std::cout << "AD: WARNING - rule body references '" << adj_param
                          << "' but argument is not a variable (cannot accumulate adjoint)\n";
                // Replace with an error marker to make the issue visible
                result = replace_word(result, adj_param, "/*ERROR:no_adj_for_" + param_names[i] + "*/0.0");
            }
        }
        i++;
    }

    std::cout << "AD: Substituted body: " << result << "\n";
    return result;
}

//-----------------------------------------------------------------------
//
//  Subtask 4: Operator token mapping for + - * /
//
//-----------------------------------------------------------------------

/**
 * @brief Result of mapping an operator or function name to ad_op_kind.
 */
ad_op_mapping_result: type = {
    public ok   : bool = false;
    public kind : ad_op_kind = ad_op_kind::add;

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (ok_: bool, kind_: ad_op_kind) -> ad_op_mapping_result = {
        r: ad_op_mapping_result = ();
        r.ok = ok_;
        r.kind = kind_;
        return r;
    }
}

/**
 * @brief Map an operator token string to ad_op_kind.
 *
 * Handles the basic arithmetic operators used in additive and multiplicative
 * expressions.
 *
 * @param op Operator token string ("+", "-", "*", "/").
 * @return Result with ok=true and kind set if recognized.
 */
map_operator_token: (op: std::string_view) -> ad_op_mapping_result = {
    if op == "+" {
        return ad_op_mapping_result::make(true, ad_op_kind::add);
    }
    if op == "-" {
        return ad_op_mapping_result::make(true, ad_op_kind::sub);
    }
    if op == "*" {
        return ad_op_mapping_result::make(true, ad_op_kind::mul);
    }
    if op == "/" {
        return ad_op_mapping_result::make(true, ad_op_kind::div);
    }
    return ad_op_mapping_result::make(false, ad_op_kind::add);
}

/**
 * @brief Map a function name to ad_op_kind.
 *
 * All function calls use ad_op_kind::call - actual differentiation
 * rules are looked up by function name in the ad_rule_registry.
 *
 * @param name Function name.
 * @return Result with ad_op_kind::call.
 */
map_function_to_op: (name: std::string_view) -> ad_op_mapping_result = {
    // All functions use ad_op_kind::call - differentiation is handled by
    // looking up ad_rule_* definitions in the rule registry by name
    return ad_op_mapping_result::make(true, ad_op_kind::call);
}

/**
 * @brief Debug: print operator mapping result.
 * @param op Operator string.
 * @param ok Whether the operator was recognized.
 * @param kind The mapped kind.
 */
debug_operator_mapping: (op: std::string_view, ok: bool, kind: ad_op_kind) = {
    std::cout << "AD: map_operator_token(\"" << op << "\") -> ";
    if ok {
        std::cout << "ok, " << ad_op_kind_to_string(kind) << "\n";
    } else {
        std::cout << "not recognized\n";
    }
}

//-----------------------------------------------------------------------
//
//  AD IR Error handling
//
//-----------------------------------------------------------------------

/**
 * @brief Error information for AD IR processing.
 */
ad_ir_error: type = {
    public message  : std::string = "";
    public location : std::string = "";
    public context  : std::string = "";

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    make: (msg: std::string, loc: std::string = "", ctx: std::string = "") -> ad_ir_error = {
        e: ad_ir_error = ();
        e.message = msg;
        e.location = loc;
        e.context = ctx;
        return e;
    }
}

/**
 * @brief Print an AD IR error with formatting.
 */
ad_ir_error_print: (err: ad_ir_error) = {
    std::cout << "\n";
    std::cout << " AD IR ERROR \n";
    std::cout << " " << err.message << "\n";
    if !err.location.empty() {
        std::cout << " Location: " << err.location << "\n";
    }
    if !err.context.empty() {
        std::cout << " Context: " << err.context << "\n";
    }
    std::cout << "\n";
}

/**
 * @brief Collection of errors during AD IR processing.
 */
ad_ir_error_list: type = {
    public errors: std::vector<ad_ir_error> = ();

    operator=: (out this) = {}
    operator=: (out this, that) = {}

    /**
     * @brief Add an error to the list.
     */
    add_error: (inout this, msg: std::string, loc: std::string = "", ctx: std::string = "") = {
        errors.push_back(ad_ir_error::make(msg, loc, ctx));
    }

    /**
     * @brief Check if any errors occurred.
     */
    has_errors: (this) -> bool = {
        return !errors.empty();
    }

    /**
     * @brief Get number of errors.
     */
    count: (this) -> int = {
        return errors.ssize();
    }

    /**
     * @brief Print all errors.
     */
    print_all: (this) = {
        if errors.empty() {
            return;
        }
        std::cout << "\n";
        std::cout << "\n";
        std::cout << "  AD IR encountered " << errors.ssize() << " error(s):\n";
        std::cout << "\n";
        for errors do (err) {
            ad_ir_error_print(err);
        }
    }

    /**
     * @brief Clear all errors.
     */
    clear: (inout this) = {
        errors.clear();
    }
}

//-----------------------------------------------------------------------
//
//  Subtask 5: Base expression builder
//
//-----------------------------------------------------------------------

/**
 * @brief IR builder context for constructing AD IR from reflection AST.
 *
 * The builder walks the reflection AST and constructs typed AD IR nodes.
 * It maintains context for naming temporaries and tracking active variables.
 */
ad_ir_builder: type = {
    public ctx        : *reverse_autodiff_context;
    public registry   : *ad_rule_registry;
    public temp_counter: int = 0;
    public temp_names : std::vector<std::string> = ();
    public errors     : ad_ir_error_list = ();

    /// Default constructor
    operator=: (out this) = {
        ctx = nullptr;
        registry = nullptr;
    }

    /// Initialize with context and registry
    operator=: (out this, ctx_: *reverse_autodiff_context, registry_: *ad_rule_registry) = {
        ctx = ctx_;
        registry = registry_;
    }

    /**
     * @brief Report an error during IR building.
     * @param msg Error message.
     * @param loc Location string (optional).
     * @param context Additional context (optional).
     */
    report_error: (inout this, msg: std::string, loc: std::string = "", context: std::string = "") = {
        errors.add_error(msg, loc, context);
        std::cout << "AD IR Builder Error: " << msg;
        if !loc.empty() { std::cout << " at " << loc; }
        if !context.empty() { std::cout << " (" << context << ")"; }
        std::cout << "\n";
    }

    /**
     * @brief Check if any errors occurred.
     */
    has_errors: (this) -> bool = {
        return errors.has_errors();
    }

    /**
     * @brief Get error count.
     */
    error_count: (this) -> int = {
        return errors.count();
    }

    /**
     * @brief Print all accumulated errors.
     */
    print_errors: (this) = {
        errors.print_all();
    }

    /**
     * @brief Generate a unique temporary name.
     * @param base Base name for the temporary.
     * @return Unique temporary name.
     */
    gen_temp_name: (inout this, base: std::string) -> std::string = {
        name := "(base)$_t(temp_counter)$";
        temp_counter++;
        temp_names.push_back(name);
        return name;
    }

    /**
     * @brief Emit an expression as a Cpp2 string.
     *
     * Full expression-to-string conversion supporting all expression kinds.
     *
     * @param expr Expression to emit.
     * @return Cpp2 source string.
     */
    emit_expr: (this, expr: ad_expr) -> std::string = {
        if expr.kind == ad_expr_kind::literal {
            return expr.name;
        }
        else if expr.kind == ad_expr_kind::identifier {
            return expr.name;
        }
        else if expr.kind == ad_expr_kind::unary {
            if !expr.args.empty() {
                operand := emit_expr(expr.args[0]);
                // Handle different unary operators
                if expr.op == ad_op_kind::neg { return "(-" + operand + ")"; }
                if expr.op == ad_op_kind::pos { return "(+" + operand + ")"; }
                if expr.op == ad_op_kind::lnot { return "(!" + operand + ")"; }
                if expr.op == ad_op_kind::bnot { return "(~" + operand + ")"; }
                if expr.op == ad_op_kind::deref { return "(*" + operand + ")"; }
                if expr.op == ad_op_kind::addr_of { return "(&" + operand + ")"; }
                if expr.op == ad_op_kind::pre_inc { return "(++" + operand + ")"; }
                if expr.op == ad_op_kind::pre_dec { return "(--" + operand + ")"; }
                if expr.op == ad_op_kind::post_inc { return "(" + operand + "++)"; }
                if expr.op == ad_op_kind::post_dec { return "(" + operand + "--)"; }
            }
            return "(unary " + ad_op_kind_to_string(expr.op) + ")";
        }
        else if expr.kind == ad_expr_kind::binary {
            if expr.args.ssize() >= 2 {
                lhs := emit_expr(expr.args[0]);
                rhs := emit_expr(expr.args[1]);
                op_str := ad_op_kind_to_binary_str(expr.op);
                if op_str.empty() { op_str = " ?? "; }
                return "(" + lhs + op_str + rhs + ")";
            }
            return "(binary)";
        }
        else if expr.kind == ad_expr_kind::ternary {
            if expr.args.ssize() >= 3 {
                cond := emit_expr(expr.args[0]);
                then_expr := emit_expr(expr.args[1]);
                else_expr := emit_expr(expr.args[2]);
                return "(" + cond + " ? " + then_expr + " : " + else_expr + ")";
            }
            return "(ternary)";
        }
        else if expr.kind == ad_expr_kind::member {
            if !expr.args.empty() {
                obj := emit_expr(expr.args[0]);
                op_str := "->";
                if expr.op != ad_op_kind::arrow { op_str = "."; }
                return obj + op_str + expr.member_name;
            }
            return "(member)";
        }
        else if expr.kind == ad_expr_kind::subscript {
            if expr.args.ssize() >= 2 {
                arr := emit_expr(expr.args[0]);
                idx := emit_expr(expr.args[1]);
                return arr + "[" + idx + "]";
            }
            return "(subscript)";
        }
        else if expr.kind == ad_expr_kind::call {
            result := expr.name;
            // Add template args if present
            if !expr.type_args.empty() {
                result += "<";
                (copy first := true)
                for expr.type_args do (targ) {
                    if !first { result += ", "; }
                    first = false;
                    result += ad_type_to_string(targ);
                }
                result += ">";
            }
            result += "(";
            (copy first := true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += ")";
            return result;
        }
        else if expr.kind == ad_expr_kind::method_call {
            if !expr.args.empty() {
                obj := emit_expr(expr.args[0]);
                result := obj + "." + expr.name + "(";
                // Skip first arg (the object), emit remaining args
                if expr.args.ssize() > 1 {
                    result += emit_expr(expr.args[1]);
                    i := 2;
                    while i < expr.args.ssize() {
                        result += ", ";
                        result += emit_expr(expr.args[i]);
                        i++;
                    }
                }
                result += ")";
                return result;
            }
            return "(method_call)";
        }
        else if expr.kind == ad_expr_kind::cast {
            if !expr.args.empty() {
                target_type: std::string = "";
                if expr.cast_type != nullptr {
                    target_type = ad_type_to_string(expr.cast_type*);
                } else {
                    target_type = expr.type_name;
                }
                inner := emit_expr(expr.args[0]);
                // C++ style cast
                if expr.name != "" {
                    return expr.name + "<" + target_type + ">(" + inner + ")";
                }
                // C-style cast
                return "(" + target_type + ")" + inner;
            }
            return "(cast)";
        }
        else if expr.kind == ad_expr_kind::construct {
            result := expr.name + "(";
            (copy first := true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += ")";
            return result;
        }
        else if expr.kind == ad_expr_kind::paren {
            if !expr.args.empty() {
                return "(" + emit_expr(expr.args[0]) + ")";
            }
            return "()";
        }
        else if expr.kind == ad_expr_kind::initializer_list {
            result: std::string = "{";
            (copy first := true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += "}";
            return result;
        }
        return "(??)";
    }

    /**
     * @brief Derive a readable operation name from op and args.
     *
     * Creates names like "mul_x_y", "sin_x", "add_z_w" for debugging.
     *
     * @param op Operation kind.
     * @param args Argument expressions.
     * @return Derived name.
     */
    derive_op_name: (this, op: ad_op_kind, args: std::vector<ad_expr>) -> std::string = {
        result := ad_op_kind_to_string(op);
        for args do (arg) {
            if arg.kind == ad_expr_kind::identifier || arg.kind == ad_expr_kind::literal {
                result += "_" + arg.name;
            }
        }
        return result;
    }

    /**
     * @brief Build an identifier IR node.
     * @param name Variable name.
     * @param type_name Type of the variable (or empty for unknown).
     * @return Identifier expression node.
     */
    build_identifier_expr: (this, name: std::string, type_name: std::string = "double") -> ad_expr = {
        return ad_expr::make_identifier(name, type_name);
    }

    /**
     * @brief Build a literal IR node.
     * @param value Literal value as string.
     * @param type_name Type of the literal (default "double").
     * @return Literal expression node.
     */
    build_literal_expr: (this, value: std::string, type_name: std::string = "double") -> ad_expr = {
        return ad_expr::make_literal(value, type_name);
    }

    /**
     * @brief Build a member-access IR node (obj.field).
     *
     * Represented as a call expression with the object as first argument.
     *
     * @param object Object expression.
     * @param field Field name.
     * @param type_name Result type.
     * @return Member access expression node.
     */
    build_member_access_expr: (this, object: ad_expr, field: std::string, type_name: std::string = "double") -> ad_expr = {
        args: std::vector<ad_expr> = ();
        args.push_back(object);
        return ad_expr::make_call(field, ad_op_kind::call, args, type_name);
    }

    /**
     * @brief Build IR from a primary expression.
     *
     * Handles identifiers, literals, and parenthesized expressions.
     *
     * @param primary Primary expression from reflection AST.
     * @return IR expression node.
     */
    build_primary_expr: (inout this, primary: meta::primary_expression) -> ad_expr = {
        if primary.is_identifier() {
            name := primary.as_identifier();
            std::cout << "AD IR Builder: primary identifier '" << name << "'\n";
            return build_identifier_expr(name as std::string);
        }
        else if primary.is_literal() {
            value := primary.as_literal();
            std::cout << "AD IR Builder: primary literal '" << value << "'\n";
            return build_literal_expr(value as std::string);
        }
        else if primary.is_expression_list() {
            // Parenthesized expression - recursively parse
            std::cout << "AD IR Builder: primary expression_list (parenthesized)\n";
            expr_list := primary.as_expression_list();
            exprs := expr_list.get_expressions();
            if exprs.ssize() == 1 {
                // Single expression in parentheses - unwrap it
                return build_expression(exprs[0]);
            }
            // Multiple expressions - error
            report_error(
                "Unsupported: multiple expressions in parentheses",
                primary.to_string() as std::string,
                "Expected a single expression"
            );
            return ad_expr::make_literal("__ERROR__", "error");
        }
        else {
            // Unknown primary expression type - hard fail
            str := primary.to_string();
            report_error(
                "Unknown primary expression type",
                str as std::string,
                "Could not parse primary expression into AD IR"
            );
            return ad_expr::make_literal("__ERROR__", "error");
        }
    }

    /**
     * @brief Build IR from a postfix expression.
     *
     * Handles function calls, member access, and subscript operations.
     *
     * @param postfix Postfix expression from reflection AST.
     * @return IR expression node.
     */
    build_postfix_expr: (inout this, postfix: meta::postfix_expression) -> ad_expr = {
        terms := postfix.get_terms();

        // If no terms, just build the primary expression
        if terms.empty() {
            return build_primary_expr(postfix.get_primary_expression());
        }

        // Start with the primary expression
        result := build_primary_expr(postfix.get_primary_expression());

        // Process each postfix term
        for terms do (term) {
            op_str := term.get_op().to_string();
            std::cout << "AD IR Builder: postfix term op='" << op_str << "'\n";

            if term.is_expression_list() {
                // Function call: f(args)
                func_name := result.name;
                std::cout << "AD IR Builder: function call '" << func_name << "'\n";

                // Parse argument list
                call_args: std::vector<ad_expr> = ();
                expr_list := term.get_expression_list();
                for expr_list.get_expressions() do (arg_expr) {
                    arg_ir := build_expression(arg_expr);
                    call_args.push_back(arg_ir);
                    std::cout << "AD IR Builder:   arg: " << arg_ir.name << "\n";
                }

                fn_op := map_function_to_op(func_name);
                if fn_op.ok {
                    result = ad_expr::make_call(func_name, fn_op.kind, call_args, "double");
                } else {
                    result = ad_expr::make_call(func_name, ad_op_kind::call, call_args, "double");
                }
            }
            else if term.is_id_expression() {
                // Member access: obj.member
                field := term.get_id_expression().to_string();
                std::cout << "AD IR Builder: member access '." << field << "'\n";
                result = build_member_access_expr(result, field as std::string);
            }
        }

        return result;
    }

    /**
     * @brief Build IR from a prefix expression.
     *
     * Handles unary operators like -x and +x.
     *
     * @param prefix Prefix expression from reflection AST.
     * @return IR expression node.
     */
    build_prefix_expr: (inout this, prefix: meta::prefix_expression) -> ad_expr = {
        ops := prefix.get_ops();

        // If no ops, just build the postfix expression
        if ops.empty() {
            return build_postfix_expr(prefix.get_postfix_expression());
        }

        // Build the inner expression first
        inner := build_postfix_expr(prefix.get_postfix_expression());

        // Apply prefix operators from right to left (innermost first)
        result := inner;
        // Iterate in reverse order
        i := ops.ssize() - 1;
        while i >= 0 {
            op_str := ops[i].to_string();
            std::cout << "AD IR Builder: prefix op '" << op_str << "'\n";

            if op_str == "-" {
                result = ad_expr::make_unary(ad_op_kind::neg, result, result.type_name);
            }
            else if op_str == "+" {
                // Unary plus is a no-op
            }
            else {
                report_error(
                    "unsupported prefix operator: '" + (op_str as std::string) + "'",
                    prefix.to_string() as std::string,
                    "prefix expression"
                );
            }
            i--;
        }

        return result;
    }

    /**
     * @brief Build IR from an is-as expression.
     *
     * Handles type checks and casts, but for AD we typically just descend.
     *
     * @param isas Is-as expression from reflection AST.
     * @return IR expression node.
     */
    build_is_as_expr: (inout this, isas: meta::is_as_expression) -> ad_expr = {
        terms := isas.get_terms();

        // If no is/as terms, descend to prefix expression
        if terms.empty() {
            return build_prefix_expr(isas.get_expression());
        }

        // For now, just build the base expression (ignoring is/as)
        std::cout << "AD IR Builder: is-as expression (ignoring is/as terms)\n";
        return build_prefix_expr(isas.get_expression());
    }

    /**
     * @brief Build IR from a multiplicative expression.
     *
     * Handles x * y, x / y chains.
     *
     * @param binexpr Multiplicative expression from reflection AST.
     * @return IR expression node.
     */
    build_multiplicative_expr: (inout this, binexpr: meta::multiplicative_expression) -> ad_expr = {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        // If only one term, descend to is-as
        if terms.ssize() == 1 {
            return build_is_as_expr(terms.front().get_term());
        }

        // Build left-to-right chain of binary ops
        result := build_is_as_expr(terms.front().get_term());

        i := 1;
        while i < terms.ssize() {
            term := terms[i];
            op_str := term.get_op().to_string();
            rhs := build_is_as_expr(term.get_term());

            op_result := map_operator_token(op_str);
            debug_operator_mapping(op_str, op_result.ok, op_result.kind);

            if op_result.ok {
                result = ad_expr::make_binary(op_result.kind, result, rhs, "double");
            } else {
                report_error(
                    "unsupported multiplicative operator: '" + (op_str as std::string) + "'",
                    binexpr.to_string() as std::string,
                    "multiplicative expression"
                );
            }
            i++;
        }

        return result;
    }

    /**
     * @brief Build IR from an additive expression.
     *
     * Handles x + y, x - y chains.
     *
     * @param binexpr Additive expression from reflection AST.
     * @return IR expression node.
     */
    build_additive_expr: (inout this, binexpr: meta::additive_expression) -> ad_expr = {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        // If only one term, descend to multiplicative
        if terms.ssize() == 1 {
            return build_multiplicative_expr(terms.front().get_term());
        }

        // Build left-to-right chain of binary ops
        result := build_multiplicative_expr(terms.front().get_term());

        i := 1;
        while i < terms.ssize() {
            term := terms[i];
            op_str := term.get_op().to_string();
            rhs := build_multiplicative_expr(term.get_term());

            op_result := map_operator_token(op_str);
            debug_operator_mapping(op_str, op_result.ok, op_result.kind);

            if op_result.ok {
                result = ad_expr::make_binary(op_result.kind, result, rhs, "double");
            } else {
                report_error(
                    "unsupported additive operator: '" + (op_str as std::string) + "'",
                    binexpr.to_string() as std::string,
                    "additive expression"
                );
            }
            i++;
        }

        return result;
    }

    //-----------------------------------------------------------------------
    // Task 7: Call builder + rule application
    //-----------------------------------------------------------------------

    /**
     * @brief Parse call arguments from an expression list.
     * @param expr_list Expression list from function call.
     * @return Vector of IR expressions for each argument.
     */
    parse_call_args: (inout this, expr_list: meta::expression_list) -> std::vector<ad_expr> = {
        args: std::vector<ad_expr> = ();
        for expr_list.get_expressions() do (expr) {
            arg_ir := build_expression(expr);
            args.push_back(arg_ir);
        }
        return args;
    }

    /**
     * @brief Build IR from a general expression node.
     * @param expr Expression from reflection AST.
     * @return IR expression node.
     */
    build_expression: (inout this, expr: meta::expression) -> ad_expr = {
        // For now, use string representation and try to identify patterns
        str := expr.to_string();
        std::cout << "AD IR Builder: expression '" << str << "'\n";

        // Check for simple identifier
        if expr.is_identifier() {
            return build_identifier_expr(str as std::string);
        }
        // Check for literal
        if expr.is_literal() {
            return build_literal_expr(str as std::string, "double");
        }

        // For complex expressions, parse from the assignment structure
        if expr.is_assignment_expression() {
            assign := expr.as_assignment_expression();
            return build_from_assignment(assign);
        }

        // Unknown expression type - hard fail
        report_error(
            "Unknown expression type",
            str as std::string,
            "Could not parse expression into AD IR. Expression is neither identifier, literal, nor assignment."
        );
        return ad_expr::make_literal("__ERROR__", "error");
    }

    /**
     * @brief Build IR from an assignment expression (top-level of most expressions).
     * @param assign Assignment expression from reflection AST.
     * @return IR expression node.
     */
    build_from_assignment: (inout this, assign: meta::assignment_expression) -> ad_expr = {
        terms := assign.get_terms();
        if terms.ssize() == 1 {
            // Single term - just descend
            return build_logical_or_expr(terms.front().get_term());
        }
        // Multiple terms means actual assignment - error for now
        report_error(
            "Unsupported: assignment expression with multiple terms",
            "",
            "AD IR builder does not support chained assignments"
        );
        return ad_expr::make_literal("__ERROR__", "error");
    }

    // Traverse down the binary expression chain to get to additive expression
    build_logical_or_expr: (inout this, expr: meta::logical_or_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_logical_and_expr(terms.front().get_term());
        }
        // TODO: handle || operators
        return build_logical_and_expr(terms.front().get_term());
    }

    build_logical_and_expr: (inout this, expr: meta::logical_and_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_bit_or_expr(terms.front().get_term());
        }
        // TODO: handle && operators
        return build_bit_or_expr(terms.front().get_term());
    }

    build_bit_or_expr: (inout this, expr: meta::bit_or_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_bit_xor_expr(terms.front().get_term());
        }
        // TODO: handle | operators
        return build_bit_xor_expr(terms.front().get_term());
    }

    build_bit_xor_expr: (inout this, expr: meta::bit_xor_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_bit_and_expr(terms.front().get_term());
        }
        // TODO: handle ^ operators
        return build_bit_and_expr(terms.front().get_term());
    }

    build_bit_and_expr: (inout this, expr: meta::bit_and_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_equality_expr(terms.front().get_term());
        }
        // TODO: handle & operators
        return build_equality_expr(terms.front().get_term());
    }

    build_equality_expr: (inout this, expr: meta::equality_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_relational_expr(terms.front().get_term());
        }
        // TODO: handle == != operators
        return build_relational_expr(terms.front().get_term());
    }

    build_relational_expr: (inout this, expr: meta::relational_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_compare_expr(terms.front().get_term());
        }
        // TODO: handle < > <= >= operators
        return build_compare_expr(terms.front().get_term());
    }

    build_compare_expr: (inout this, expr: meta::compare_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_shift_expr(terms.front().get_term());
        }
        // TODO: handle <=> operators
        return build_shift_expr(terms.front().get_term());
    }

    build_shift_expr: (inout this, expr: meta::shift_expression) -> ad_expr = {
        terms := expr.get_terms();
        if terms.ssize() == 1 {
            return build_additive_expr(terms.front().get_term());
        }
        // TODO: handle << >> operators
        return build_additive_expr(terms.front().get_term());
    }

    /**
     * @brief Apply rule override or default implementation for a call.
     *
     * If the registry has a rule for this function, marks has_rule=true.
     * Otherwise, has_rule=false and the reverse pass will generate a call to
     * ad_rule_<func>::reverse() which the C++ compiler can resolve from
     * externally-defined rules (e.g., from cpp2ad_rules.h2 or user code).
     *
     * @param name Function name.
     * @param n_args Number of arguments.
     * @param is_member True for member calls.
     * @param args Argument IR nodes.
     * @return Rule application result with forward expression.
     */
    apply_rule_or_default: (inout this, name: std::string, n_args: int, is_member: bool, args: std::vector<ad_expr>)
        -> ad_rule_application_result =
    {
        result: ad_rule_application_result = ();

        // Check registry for rule with IR body
        if registry != nullptr && registry*.has_rule(name, n_args, is_member) {
            std::cout << "AD IR Builder: found rule '" << name << "' in registry\n";
            result.has_rule = true;
        } else {
            // No rule in registry - reverse pass will generate call to ad_rule_<func>::reverse()
            // The C++ compiler will resolve this from externally-defined ad_rule_* types
            std::cout << "AD IR Builder: no registry rule for '" << name << "', will use ad_rule_" << name << "::reverse()\n";
            result.has_rule = false;
        }

        // Forward expression is always the function call itself
        result.forward = ad_expr::make_call(name, ad_op_kind::call, args, "double");
        return result;
    }

    //-----------------------------------------------------------------------
    // Task 8: Activity analysis
    //-----------------------------------------------------------------------

    /**
     * @brief Check if an expression is active for AD.
     * @param expr IR expression to check.
     * @return True if the expression is active.
     */
    is_active_ir_expr: (this, expr: ad_expr) -> bool = {
        // Literals are not active
        if expr.kind == ad_expr_kind::literal {
            return false;
        }
        // Identifiers: check if it's a known active variable
        if expr.kind == ad_expr_kind::identifier {
            // For now, assume all identifiers are active (parameters)
            // A more sophisticated check would track active variables
            return true;
        }
        // Unary: active if operand is active
        if expr.kind == ad_expr_kind::unary {
            if !expr.args.empty() {
                return is_active_ir_expr(expr.args[0]);
            }
            return false;
        }
        // Binary: active if either operand is active
        if expr.kind == ad_expr_kind::binary {
            if expr.args.ssize() >= 2 {
                return is_active_ir_expr(expr.args[0]) || is_active_ir_expr(expr.args[1]);
            }
            return false;
        }
        // Call: active if any argument is active
        if expr.kind == ad_expr_kind::call {
            for expr.args do (arg) {
                if is_active_ir_expr(arg) { return true; }
            }
            return false;
        }
        return false;
    }

    //-----------------------------------------------------------------------
    // Task 9: Statement builder (decl + assignment)
    //-----------------------------------------------------------------------

    /**
     * @brief Build IR statements for a local object declaration.
     * @param decl Declaration to process.
     * @param body_stmts Output vector for forward statements.
     * @param reverse_stmts Output vector for reverse statements.
     */
    build_object_decl: (inout this, decl: meta::declaration,
                        inout body_stmts: std::vector<ad_stmt>,
                        inout reverse_stmts: std::vector<ad_stmt>) = {
        if !decl.is_object() {
            return;
        }
        obj := decl.as_object();
        name := obj.name() as std::string;
        type_str := obj.type() as std::string;

        std::cout << "AD IR Builder: object decl '" << name << "': " << type_str << "\n";

        // Check if it has an initializer
        if obj.has_initializer() {
            init_stmt := obj.get_initializer();
            init_ir: ad_expr = ();
            if init_stmt.is_expression_statement() {
                init_expr := init_stmt.as_expression_statement().get_expression();
                init_ir = build_expression(init_expr);
            } else {
                // Non-expression initializer - error
                report_error(
                    "Unsupported initializer type in AD",
                    init_stmt.to_string() as std::string,
                    "Expected an expression statement for variable initializer"
                );
                init_ir = ad_expr::make_literal("__ERROR__", "error");
            }

            // Create value declaration with _val suffix
            // Transform expression to use _val suffixes for identifiers
            val_name := ctx*.make_value_name(name);
            transformed_init := transform_expr_to_val(init_ir);
            val_decl := ad_stmt::make_decl(val_name, type_str, transformed_init);
            body_stmts.push_back(val_decl);

            // Create adjoint declaration: name_adj := 0.0
            adj_name := ctx*.make_adj_name(name);
            zero := ad_expr::make_literal("0.0", type_str);
            adj_decl := ad_stmt::make_decl(adj_name, type_str, zero);
            body_stmts.push_back(adj_decl);

            // Generate reverse statement if active
            if is_active_ir_expr(init_ir) {
                reverse_stmt := generate_reverse_for_expr(name, init_ir);
                reverse_stmts.push_back(reverse_stmt);
            }
        }
    }

    /**
     * @brief Build IR statements for an assignment.
     * @param target Target variable name.
     * @param value_expr RHS expression IR.
     * @param body_stmts Output vector for forward statements.
     * @param reverse_stmts Output vector for reverse statements.
     */
    build_assignment: (inout this, target: std::string, value_expr: ad_expr,
                       inout body_stmts: std::vector<ad_stmt>,
                       inout reverse_stmts: std::vector<ad_stmt>) = {
        // Forward pass: Store the result in target_val (with _val suffix)
        // This is needed because the reverse pass uses target_val for the chain rule
        //
        // Transform the value expression to use _val suffixes for identifiers
        transformed_expr := transform_expr_to_val(value_expr);

        // Create declaration: target_val := transformed_expr
        val_name := ctx*.make_value_name(target);
        decl_stmt := ad_stmt::make_decl(val_name, "double", transformed_expr);
        body_stmts.push_back(decl_stmt);

        // Also assign to the raw target (for the return value)
        val_ref := ad_expr::make_identifier(val_name, "double");
        assign_stmt := ad_stmt::make_assign(target, val_ref);
        body_stmts.push_back(assign_stmt);

        // Reverse: propagate adjoint if active
        if is_active_ir_expr(value_expr) {
            reverse_stmt := generate_reverse_for_expr(target, value_expr);
            reverse_stmts.push_back(reverse_stmt);
        }
    }

    /**
     * @brief Transform expression to use _val suffixes for identifiers.
     * @param expr Expression to transform.
     * @return Transformed expression with _val suffixes.
     */
    transform_expr_to_val: (inout this, expr: ad_expr) -> ad_expr = {
        if expr.kind == ad_expr_kind::identifier {
            // Transform identifier to use _val suffix
            return ad_expr::make_identifier(ctx*.make_value_name(expr.name), expr.type_name);
        }
        else if expr.kind == ad_expr_kind::literal {
            // Literals stay as-is
            return expr;
        }
        else if expr.kind == ad_expr_kind::unary {
            // Transform operand
            if !expr.args.empty() {
                result := expr;
                result.args[0] = transform_expr_to_val(expr.args[0]);
                return result;
            }
            return expr;
        }
        else if expr.kind == ad_expr_kind::binary {
            // Transform both operands
            if expr.args.ssize() >= 2 {
                result := expr;
                result.args[0] = transform_expr_to_val(expr.args[0]);
                result.args[1] = transform_expr_to_val(expr.args[1]);
                return result;
            }
            return expr;
        }
        else if expr.kind == ad_expr_kind::call {
            // Transform all arguments
            result := expr;
            i := 0;
            while i < result.args.ssize() {
                result.args[i] = transform_expr_to_val(result.args[i]);
                i++;
            }
            return result;
        }
        return expr;
    }

    /**
     * @brief Generate reverse (adjoint) statement for an expression.
     * @param target Target variable name (whose adjoint receives contribution).
     * @param expr Expression IR.
     * @return Reverse statement.
     */
    generate_reverse_for_expr: (inout this, target: std::string, expr: ad_expr) -> ad_stmt = {
        target_adj := ctx*.make_adj_name(target);

        // For binary ops, generate partial derivative contributions
        if expr.kind == ad_expr_kind::binary {
            if expr.args.ssize() >= 2 {
                lhs := expr.args[0];
                rhs := expr.args[1];

                if expr.op == ad_op_kind::add {
                    // d(a+b)/da = 1, d(a+b)/db = 1
                    // Reverse: lhs_adj += target_adj; rhs_adj += target_adj
                    compound: std::vector<ad_stmt> = ();
                    if lhs.kind == ad_expr_kind::identifier {
                        lhs_adj := ctx*.make_adj_name(lhs.name);
                        adj_ref := ad_expr::make_identifier(target_adj, "double");
                        compound.push_back(ad_stmt::make_assign_add(lhs_adj, adj_ref));
                    }
                    if rhs.kind == ad_expr_kind::identifier {
                        rhs_adj := ctx*.make_adj_name(rhs.name);
                        adj_ref := ad_expr::make_identifier(target_adj, "double");
                        compound.push_back(ad_stmt::make_assign_add(rhs_adj, adj_ref));
                    }
                    return ad_stmt::make_compound(compound);
                }
                else if expr.op == ad_op_kind::sub {
                    // d(a-b)/da = 1, d(a-b)/db = -1
                    compound: std::vector<ad_stmt> = ();
                    if lhs.kind == ad_expr_kind::identifier {
                        lhs_adj := ctx*.make_adj_name(lhs.name);
                        adj_ref := ad_expr::make_identifier(target_adj, "double");
                        compound.push_back(ad_stmt::make_assign_add(lhs_adj, adj_ref));
                    }
                    if rhs.kind == ad_expr_kind::identifier {
                        rhs_adj := ctx*.make_adj_name(rhs.name);
                        adj_ref := ad_expr::make_identifier(target_adj, "double");
                        neg_adj := ad_expr::make_unary(ad_op_kind::neg, adj_ref, "double");
                        compound.push_back(ad_stmt::make_assign_add(rhs_adj, neg_adj));
                    }
                    return ad_stmt::make_compound(compound);
                }
                else if expr.op == ad_op_kind::mul {
                    // d(a*b)/da = b, d(a*b)/db = a
                    compound: std::vector<ad_stmt> = ();
                    adj_ref := ad_expr::make_identifier(target_adj, "double");

                    // Handle LHS (contribution to lhs_adj)
                    if lhs.kind == ad_expr_kind::identifier {
                        lhs_adj := ctx*.make_adj_name(lhs.name);
                        // lhs_adj += rhs * target_adj
                        // Need to get rhs value - could be identifier or call result
                        rhs_val: ad_expr = ();
                        if rhs.kind == ad_expr_kind::identifier {
                            rhs_val = ad_expr::make_identifier(ctx*.make_value_name(rhs.name), "double");
                        } else if rhs.kind == ad_expr_kind::call {
                            // Use the call expression itself as the value (forward pass computes it)
                            rhs_val = rhs;
                        } else {
                            // For literals, binary expressions, etc. - use the expression directly
                            rhs_val = rhs;
                        }
                        contrib := ad_expr::make_binary(ad_op_kind::mul, rhs_val, adj_ref, "double");
                        compound.push_back(ad_stmt::make_assign_add(lhs_adj, contrib));
                    }
                    else if lhs.kind == ad_expr_kind::call {
                        // LHS is a call - need chain rule through it
                        // tmp_adj = rhs * target_adj, then apply call's reverse
                        // For now, recursively generate reverse for the call
                        // The call's arguments will receive contributions scaled by lhs_val * target_adj
                        call_reverse := generate_reverse_for_call_with_scale(lhs, rhs, adj_ref);
                        compound.push_back(call_reverse);
                    }

                    // Handle RHS (contribution to rhs_adj)
                    if rhs.kind == ad_expr_kind::identifier {
                        rhs_adj := ctx*.make_adj_name(rhs.name);
                        // rhs_adj += lhs * target_adj
                        lhs_val: ad_expr = ();
                        if lhs.kind == ad_expr_kind::identifier {
                            lhs_val = ad_expr::make_identifier(ctx*.make_value_name(lhs.name), "double");
                        } else if lhs.kind == ad_expr_kind::call {
                            lhs_val = lhs;
                        } else {
                            lhs_val = lhs;
                        }
                        contrib := ad_expr::make_binary(ad_op_kind::mul, lhs_val, adj_ref, "double");
                        compound.push_back(ad_stmt::make_assign_add(rhs_adj, contrib));
                    }
                    else if rhs.kind == ad_expr_kind::call {
                        // RHS is a call - need chain rule through it
                        // The call's arguments receive: lhs_val * target_adj * d(call)/d(arg)
                        lhs_val: ad_expr = ();
                        if lhs.kind == ad_expr_kind::identifier {
                            lhs_val = ad_expr::make_identifier(ctx*.make_value_name(lhs.name), "double");
                        } else {
                            lhs_val = lhs;
                        }
                        call_reverse := generate_reverse_for_call_with_scale(rhs, lhs_val, adj_ref);
                        compound.push_back(call_reverse);
                    }

                    return ad_stmt::make_compound(compound);
                }
                else if expr.op == ad_op_kind::div {
                    // d(a/b)/da = 1/b, d(a/b)/db = -a/b^2
                    compound: std::vector<ad_stmt> = ();
                    adj_ref := ad_expr::make_identifier(target_adj, "double");
                    if lhs.kind == ad_expr_kind::identifier {
                        lhs_adj := ctx*.make_adj_name(lhs.name);
                        // lhs_adj += (1/rhs) * target_adj
                        one := ad_expr::make_literal("1.0", "double");
                        rhs_val := ad_expr::make_identifier(ctx*.make_value_name(rhs.name), "double");
                        inv_rhs := ad_expr::make_binary(ad_op_kind::div, one, rhs_val, "double");
                        contrib := ad_expr::make_binary(ad_op_kind::mul, inv_rhs, adj_ref, "double");
                        compound.push_back(ad_stmt::make_assign_add(lhs_adj, contrib));
                    }
                    if rhs.kind == ad_expr_kind::identifier {
                        rhs_adj := ctx*.make_adj_name(rhs.name);
                        // rhs_adj += (-lhs/rhs^2) * target_adj
                        lhs_val := ad_expr::make_identifier(ctx*.make_value_name(lhs.name), "double");
                        rhs_val := ad_expr::make_identifier(ctx*.make_value_name(rhs.name), "double");
                        neg_lhs := ad_expr::make_unary(ad_op_kind::neg, lhs_val, "double");
                        rhs_sq := ad_expr::make_binary(ad_op_kind::mul, rhs_val, rhs_val, "double");
                        quot := ad_expr::make_binary(ad_op_kind::div, neg_lhs, rhs_sq, "double");
                        contrib := ad_expr::make_binary(ad_op_kind::mul, quot, adj_ref, "double");
                        compound.push_back(ad_stmt::make_assign_add(rhs_adj, contrib));
                    }
                    return ad_stmt::make_compound(compound);
                }
            }
        }
        else if expr.kind == ad_expr_kind::unary && expr.op == ad_op_kind::neg {
            // d(-a)/da = -1
            if !expr.args.empty() && expr.args[0].kind == ad_expr_kind::identifier {
                arg_adj := ctx*.make_adj_name(expr.args[0].name);
                adj_ref := ad_expr::make_identifier(target_adj, "double");
                neg_adj := ad_expr::make_unary(ad_op_kind::neg, adj_ref, "double");
                return ad_stmt::make_assign_add(arg_adj, neg_adj);
            }
        }
        else if expr.kind == ad_expr_kind::call {
            // For function calls, need to apply chain rule with function derivative
            return generate_reverse_for_call(target, expr);
        }
        else if expr.kind == ad_expr_kind::identifier {
            // Simple assignment: target = x => x_adj += target_adj
            arg_adj := ctx*.make_adj_name(expr.name);
            adj_ref := ad_expr::make_identifier(target_adj, "double");
            return ad_stmt::make_assign_add(arg_adj, adj_ref);
        }

        // Default: no-op (placeholder)
        empty: std::vector<ad_stmt> = ();
        return ad_stmt::make_compound(empty);
    }

    /**
     * @brief Generate reverse statement for a function call with scaling factor.
     *
     * Used when a call is part of a larger expression like x * f(y).
     * The derivative is: d(x * f(y))/dy = x * f'(y)
     *
     * @param call_expr Call expression IR.
     * @param scale_expr Expression to multiply the derivative by (e.g., lhs value).
     * @param adj_ref The adjoint of the outer expression.
     * @return Reverse statement.
     */
    generate_reverse_for_call_with_scale: (inout this, call_expr: ad_expr, scale_expr: ad_expr, adj_ref: ad_expr) -> ad_stmt = {
        compound: std::vector<ad_stmt> = ();
        func_name := call_expr.name;
        n_args : int = cpp2::unchecked_narrow<int>(call_expr.args.ssize());

        // The scaled adjoint contribution: scale_expr * adj_ref
        scaled_adj := ad_expr::make_binary(ad_op_kind::mul, scale_expr, adj_ref, "double");

        // Priority 1: Check registry for user-defined rules FIRST
        // User rules from the registry take priority
        if registry != nullptr && !call_expr.args.empty() {
            // Build substitution context for IR-based parsing
            sub_ctx: ad_substitution_context = ();

            // For res_val: build function call expression with argument values
            call_args: std::vector<ad_expr> = ();
            for call_expr.args do (arg) {
                if arg.kind == ad_expr_kind::identifier {
                    call_args.push_back(ad_expr::make_identifier(ctx*.make_value_name(arg.name), "double"));
                } else {
                    call_args.push_back(arg);
                }
            }
            res_val_call := ad_expr::make_call(func_name, ad_op_kind::call, call_args, "double");
            sub_ctx.add("res_val", res_val_call);

            // For res_adj: use the scaled adjoint (scale_expr * adj_ref)
            sub_ctx.add("res_adj", scaled_adj);

            // Add argument value and adjoint substitutions
            param_names: std::array<std::string, 4> = ("x", "y", "z", "w");
            i := 0;
            for call_expr.args do (arg) {
                if i < param_names.ssize() {
                    val_param := param_names[i] + "_val";
                    adj_param := param_names[i] + "_adj";

                    if arg.kind == ad_expr_kind::identifier {
                        sub_ctx.add(val_param, ad_expr::make_identifier(ctx*.make_value_name(arg.name), "double"));
                        sub_ctx.add(adj_param, ad_expr::make_identifier(ctx*.make_adj_name(arg.name), "double"));
                    } else {
                        // For non-identifier args (literals), use expression directly
                        sub_ctx.add(val_param, arg);
                        // Can't accumulate to non-identifier - use dummy
                        sub_ctx.add(adj_param, ad_expr::make_identifier("__unused_adj__", "double"));
                    }
                    i++;
                }
            }

            // Apply the rule - registry handles IR parsing internally
            rule_result := registry*.apply_reverse_rule(func_name, n_args, false, sub_ctx);

            if rule_result.found {
                if rule_result.ir_success {
                    // Success - return the parsed IR
                    return ad_stmt::make_compound(rule_result.ir_stmts);
                }

                // Rule found but parsing failed - report the specific error
                report_error(
                    "Failed to parse rule for function '" + func_name + "'",
                    "",
                    rule_result.error_message
                );
            }  // end if rule_result.found
        }  // end if registry != nullptr

        // HARD FAIL: No rule found for this function
        // All differentiable functions must have an ad_rule_* definition
        report_error(
            "No differentiation rule found for function '" + func_name + "'",
            "",
            "To differentiate this function, define an ad_rule_" + func_name + " type with a reverse() function. "
            + "See include/cpp2ad_rules.h2 for examples."
        );
        ctx*.mf.error("@autodiff: No rule found for function '" + func_name + "'. "
                      + "Define ad_rule_" + func_name + " with a reverse() function.");
        return ad_stmt::make_compound(());  // Return empty compound (will never be reached due to error)
    }

    /**
     * @brief Generate reverse statement for a function call.
     * @param target Target variable name.
     * @param call_expr Call expression IR.
     * @return Reverse statement.
     */
    generate_reverse_for_call: (inout this, target: std::string, call_expr: ad_expr) -> ad_stmt = {
        compound: std::vector<ad_stmt> = ();
        target_adj := ctx*.make_adj_name(target);
        adj_ref := ad_expr::make_identifier(target_adj, "double");

        func_name := call_expr.name;
        n_args : int = cpp2::unchecked_narrow<int>(call_expr.args.ssize());

        // Priority 1: Check registry for user-defined rules FIRST
        // User rules from the registry take priority
        if registry != nullptr {
            target_val := ctx*.make_value_name(target);

            // Build substitution context for IR-based parsing
            sub_ctx: ad_substitution_context = ();

            // Add result value and adjoint substitutions
            sub_ctx.add("res_val", ad_expr::make_identifier(target_val, "double"));
            sub_ctx.add("res_adj", ad_expr::make_identifier(target_adj, "double"));

            // Add argument value and adjoint substitutions
            param_names: std::array<std::string, 4> = ("x", "y", "z", "w");
            i := 0;
            for call_expr.args do (arg) {
                if i < param_names.ssize() {
                    val_param := param_names[i] + "_val";
                    adj_param := param_names[i] + "_adj";

                    if arg.kind == ad_expr_kind::identifier {
                        sub_ctx.add(val_param, ad_expr::make_identifier(ctx*.make_value_name(arg.name), "double"));
                        sub_ctx.add(adj_param, ad_expr::make_identifier(ctx*.make_adj_name(arg.name), "double"));
                    } else {
                        // For non-identifier args (literals), use expression directly
                        sub_ctx.add(val_param, arg);
                        // Can't accumulate to non-identifier - use dummy
                        sub_ctx.add(adj_param, ad_expr::make_identifier("__unused_adj__", "double"));
                    }
                    i++;
                }
            }

            // Apply the rule - registry handles IR parsing internally
            rule_result := registry*.apply_reverse_rule(func_name, n_args, false, sub_ctx);

            if rule_result.found {
                if rule_result.ir_success {
                    // Success - return the parsed IR
                    return ad_stmt::make_compound(rule_result.ir_stmts);
                }

                // Rule found but parsing failed - report the specific error
                report_error(
                    "Failed to parse rule for function '" + func_name + "'",
                    "",
                    rule_result.error_message
                );
            }
        }

        // No rule found for this function
        report_error(
            "No differentiation rule found for function '" + func_name + "'",
            "",
            "To differentiate this function, define an ad_rule_" + func_name + " type with a reverse() function. "
            + "See include/cpp2ad_rules.h2 for examples."
        );
        ctx*.mf.error("@autodiff: No rule found for function '" + func_name + "'. "
                      + "Define ad_rule_" + func_name + " with a reverse() function.");
        return ad_stmt::make_compound(());  // Return empty compound (will never be reached due to error)
    }

    //-----------------------------------------------------------------------
    // Task 10: Return statement lowering
    //-----------------------------------------------------------------------

    /**
     * @brief Build IR for a return statement and seed adjoint.
     * @param return_expr Expression being returned.
     * @param return_name Name of the return variable.
     * @param body_stmts Output vector for forward statements.
     * @param reverse_stmts Output vector for reverse statements.
     */
    build_return: (inout this, return_expr: ad_expr, return_name: std::string,
                   inout body_stmts: std::vector<ad_stmt>,
                   inout reverse_stmts: std::vector<ad_stmt>) = {
        // Forward: r_val = return_expr
        val_name := ctx*.make_value_name(return_name);
        assign_stmt := ad_stmt::make_assign(val_name, return_expr);
        body_stmts.push_back(assign_stmt);

        // Reverse: seed r_adj (done at beginning of reverse pass, handled by emitter)
        // Then propagate adjoint back through the return expression
        if is_active_ir_expr(return_expr) {
            reverse_stmt := generate_reverse_for_expr(return_name, return_expr);
            reverse_stmts.push_back(reverse_stmt);
        }
    }

    //-----------------------------------------------------------------------
    // Full function building
    //-----------------------------------------------------------------------

    /**
     * @brief Build complete IR for a function.
     * @param mf Function declaration.
     * @return Complete function IR.
     */
    build_function_ir: (inout this, mf: meta::function_declaration) -> ad_function_ir = {
        ir: ad_function_ir = ();
        ir.name = mf.name() as std::string;
        std::cout << "AD IR Builder: building function IR for '" << ir.name << "'\n";

        // Add parameters
        for mf.get_parameters() do (param) {
            decl := param.get_declaration();
            p := ad_param::make(
                decl.name() as std::string,
                decl.type() as std::string,
                param.get_passing_style(),
                true  // Assume active for now
            );
            ir.params.push_back(p);
            std::cout << "AD IR Builder:   param: " << p.name << ": " << p.type_name << "\n";
        }

        // Add returns
        for mf.get_returns() do (ret) {
            decl := ret.get_declaration();
            r := ad_param::make(
                decl.name() as std::string,
                decl.type() as std::string,
                ret.get_passing_style(),
                true
            );
            ir.returns.push_back(r);
            std::cout << "AD IR Builder:   return: " << r.name << ": " << r.type_name << "\n";
        }

        // Process function body (statements)
        if mf.has_compound_body() {
            body := mf.get_compound_body();
            statements := body.get_statements();
            std::cout << "AD IR Builder:   processing " << statements.ssize() << " statements\n";

            // Collect reverse statements in reverse order
            reverse_stmts: std::vector<ad_stmt> = ();

            for statements do (stmt) {
                process_statement(stmt, ir.forward, reverse_stmts);
            }

            // Reverse the reverse statements (they were collected in forward order)
            i := reverse_stmts.ssize() - 1;
            while i >= 0 {
                ir.reverse.push_back(reverse_stmts[i]);
                i--;
            }
        }

        return ir;
    }

    /**
     * @brief Process a single statement and add to forward/reverse lists.
     * @param stmt Statement to process.
     * @param forward_stmts Output vector for forward statements.
     * @param reverse_stmts Output vector for reverse statements (collected in forward order).
     */
    process_statement: (inout this, stmt: meta::statement,
                        inout forward_stmts: std::vector<ad_stmt>,
                        inout reverse_stmts: std::vector<ad_stmt>) = {
        str := stmt.to_string();
        std::cout << "AD IR Builder:     stmt: " << str << "\n";

        if stmt.is_declaration() {
            // Local variable declaration
            decl := stmt.as_declaration();
            build_object_decl(decl, forward_stmts, reverse_stmts);
        }
        else if stmt.is_expression_statement() {
            // Expression statement (typically an assignment)
            expr_stmt := stmt.as_expression_statement();
            expr := expr_stmt.get_expression();

            if expr.is_simple_assignment() {
                // Assignment: lhs = rhs
                lhs_rhs := expr.get_lhs_rhs_if_simple_assignment();
                lhs_str := lhs_rhs.lhs.to_string();
                std::cout << "AD IR Builder:       assignment to '" << lhs_str << "'\n";

                // Build the RHS expression
                rhs_ir := build_logical_or_expr(lhs_rhs.rhs);

                // Build assignment IR
                build_assignment(lhs_str as std::string, rhs_ir, forward_stmts, reverse_stmts);
            }
            else {
                std::cout << "AD IR Builder:       non-assignment expression (skipped)\n";
            }
        }
        else if stmt.is_return_statement() {
            // Return statement
            ret_stmt := stmt.as_return_statement();
            if ret_stmt.has_expression() {
                ret_expr := ret_stmt.get_expression();
                ret_ir := build_expression(ret_expr);

                // Use the first return variable name if available
                ret_name := "r";
                // Note: return statement handling would be more sophisticated
                std::cout << "AD IR Builder:       return statement\n";
            }
        }
        else {
            std::cout << "AD IR Builder:       unknown statement type (skipped)\n";
        }
    }
}

/**
 * @brief Result of applying a rule or default for a function call.
 */
ad_rule_application_result: type = {
    public has_rule : bool = false;
    public forward  : ad_expr = ();

    operator=: (out this) = {}
    operator=: (out this, that) = {}
}

//-----------------------------------------------------------------------
// Task 11 & 12: IR Emitter for forward and reverse passes
//-----------------------------------------------------------------------

/**
 * @brief Map ad_op_kind to its binary operator string representation.
 * @param op Operation kind.
 * @return Operator string with spaces (e.g., " + "), or empty if not a binary op.
 */
ad_op_kind_to_binary_str: (op: ad_op_kind) -> std::string = {
    // Arithmetic
    if op == ad_op_kind::add { return " + "; }
    if op == ad_op_kind::sub { return " - "; }
    if op == ad_op_kind::mul { return " * "; }
    if op == ad_op_kind::div { return " / "; }
    if op == ad_op_kind::mod { return " % "; }
    // Comparison
    if op == ad_op_kind::eq { return " == "; }
    if op == ad_op_kind::ne { return " != "; }
    if op == ad_op_kind::lt { return " < "; }
    if op == ad_op_kind::gt { return " > "; }
    if op == ad_op_kind::le { return " <= "; }
    if op == ad_op_kind::ge { return " >= "; }
    if op == ad_op_kind::spaceship { return " <=> "; }
    // Logical
    if op == ad_op_kind::land { return " && "; }
    if op == ad_op_kind::lor { return " || "; }
    // Bitwise
    if op == ad_op_kind::band { return " & "; }
    if op == ad_op_kind::bor { return " | "; }
    if op == ad_op_kind::bxor { return " ^ "; }
    if op == ad_op_kind::shl { return " << "; }
    if op == ad_op_kind::shr { return " >> "; }
    // Assignment
    if op == ad_op_kind::assign { return " = "; }
    if op == ad_op_kind::assign_add { return " += "; }
    if op == ad_op_kind::assign_sub { return " -= "; }
    if op == ad_op_kind::assign_mul { return " *= "; }
    if op == ad_op_kind::assign_div { return " /= "; }
    if op == ad_op_kind::assign_mod { return " %= "; }
    if op == ad_op_kind::assign_band { return " &= "; }
    if op == ad_op_kind::assign_bor { return " |= "; }
    if op == ad_op_kind::assign_bxor { return " ^= "; }
    if op == ad_op_kind::assign_shl { return " <<= "; }
    if op == ad_op_kind::assign_shr { return " >>= "; }
    return "";
}

/**
 * @brief Emitter for converting AD IR to Cpp2 source code.
 */
ad_ir_emitter: type = {
    public ctx : *reverse_autodiff_context;

    operator=: (out this) = {
        ctx = nullptr;
    }

    operator=: (out this, ctx_: *reverse_autodiff_context) = {
        ctx = ctx_;
    }

    /**
     * @brief Emit Cpp2 code for an IR expression.
     * @param expr Expression IR.
     * @return Cpp2 source string.
     */
    emit_expr: (this, expr: ad_expr) -> std::string = {
        if expr.kind == ad_expr_kind::literal {
            return expr.name;
        }
        else if expr.kind == ad_expr_kind::identifier {
            return expr.name;
        }
        else if expr.kind == ad_expr_kind::unary {
            if !expr.args.empty() {
                operand := emit_expr(expr.args[0]);
                // Handle different unary operators
                if expr.op == ad_op_kind::neg { return "(-" + operand + ")"; }
                if expr.op == ad_op_kind::pos { return "(+" + operand + ")"; }
                if expr.op == ad_op_kind::lnot { return "(!" + operand + ")"; }
                if expr.op == ad_op_kind::bnot { return "(~" + operand + ")"; }
                if expr.op == ad_op_kind::deref { return "(*" + operand + ")"; }
                if expr.op == ad_op_kind::addr_of { return "(&" + operand + ")"; }
                if expr.op == ad_op_kind::pre_inc { return "(++" + operand + ")"; }
                if expr.op == ad_op_kind::pre_dec { return "(--" + operand + ")"; }
                if expr.op == ad_op_kind::post_inc { return "(" + operand + "++)"; }
                if expr.op == ad_op_kind::post_dec { return "(" + operand + "--)"; }
            }
            return "(unary " + ad_op_kind_to_string(expr.op) + ")";
        }
        else if expr.kind == ad_expr_kind::binary {
            if expr.args.ssize() >= 2 {
                lhs := emit_expr(expr.args[0]);
                rhs := emit_expr(expr.args[1]);
                op_str := ad_op_kind_to_binary_str(expr.op);
                if op_str.empty() { op_str = " ?? "; }
                return "(" + lhs + op_str + rhs + ")";
            }
            return "(binary)";
        }
        else if expr.kind == ad_expr_kind::ternary {
            if expr.args.ssize() >= 3 {
                cond := emit_expr(expr.args[0]);
                then_expr := emit_expr(expr.args[1]);
                else_expr := emit_expr(expr.args[2]);
                return "(" + cond + " ? " + then_expr + " : " + else_expr + ")";
            }
            return "(ternary)";
        }
        else if expr.kind == ad_expr_kind::member {
            if !expr.args.empty() {
                obj := emit_expr(expr.args[0]);
                op_str := "->";
                if expr.op != ad_op_kind::arrow { op_str = "."; }
                return obj + op_str + expr.member_name;
            }
            return "(member)";
        }
        else if expr.kind == ad_expr_kind::subscript {
            if expr.args.ssize() >= 2 {
                arr := emit_expr(expr.args[0]);
                idx := emit_expr(expr.args[1]);
                return arr + "[" + idx + "]";
            }
            return "(subscript)";
        }
        else if expr.kind == ad_expr_kind::call {
            result := expr.name;
            // Add template args if present
            if !expr.type_args.empty() {
                result += "<";
                (copy first := true)
                for expr.type_args do (targ) {
                    if !first { result += ", "; }
                    first = false;
                    result += ad_type_to_string(targ);
                }
                result += ">";
            }
            result += "(";
            (copy first := true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += ")";
            return result;
        }
        else if expr.kind == ad_expr_kind::method_call {
            if !expr.args.empty() {
                obj := emit_expr(expr.args[0]);
                result := obj + "." + expr.name + "(";
                // Skip first arg (the object), emit remaining args
                if expr.args.ssize() > 1 {
                    result += emit_expr(expr.args[1]);
                    i := 2;
                    while i < expr.args.ssize() {
                        result += ", ";
                        result += emit_expr(expr.args[i]);
                        i++;
                    }
                }
                result += ")";
                return result;
            }
            return "(method_call)";
        }
        else if expr.kind == ad_expr_kind::cast {
            if !expr.args.empty() {
                target_type: std::string = "";
                if expr.cast_type != nullptr {
                    target_type = ad_type_to_string(expr.cast_type*);
                } else {
                    target_type = expr.type_name;
                }
                inner := emit_expr(expr.args[0]);
                if expr.name != "" {
                    return expr.name + "<" + target_type + ">(" + inner + ")";
                }
                return "(" + target_type + ")" + inner;
            }
            return "(cast)";
        }
        else if expr.kind == ad_expr_kind::construct {
            result := expr.name + "(";
            (copy first := true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += ")";
            return result;
        }
        else if expr.kind == ad_expr_kind::paren {
            if !expr.args.empty() {
                return "(" + emit_expr(expr.args[0]) + ")";
            }
            return "()";
        }
        else if expr.kind == ad_expr_kind::initializer_list {
            result: std::string = "{";
            (copy first := true)
            for expr.args do (arg) {
                if !first { result += ", "; }
                first = false;
                result += emit_expr(arg);
            }
            result += "}";
            return result;
        }
        return "(unknown)";
    }

    /**
     * @brief Emit Cpp2 code for a single IR statement.
     * @param stmt Statement IR.
     * @param indent Indentation level.
     * @return Cpp2 source string.
     */
    emit_stmt: (this, stmt: ad_stmt, indent: int = 0) -> std::string = {
        ind := std::string(indent * 4, ' ');

        if stmt.kind == ad_stmt_kind::decl {
            // Declaration: name : type = expr;
            return ind + stmt.target + " : " + stmt.type_name + " = " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::assign {
            // Assignment: name = expr;
            return ind + stmt.target + " = " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::compound_assign {
            // Compound assignment: name op= expr;
            op_str := ad_op_kind_to_binary_str(stmt.op);
            if op_str.empty() { op_str = " ??= "; }
            return ind + stmt.target + op_str + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::assign_add {
            // Add-assignment: name += expr;
            return ind + stmt.target + " += " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::expr || stmt.kind == ad_stmt_kind::expr_stmt {
            // Expression statement
            return ind + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::return_ {
            // Return statement
            return ind + "return " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::break_stmt {
            return ind + "break;\n";
        }
        else if stmt.kind == ad_stmt_kind::continue_stmt {
            return ind + "continue;\n";
        }
        else if stmt.kind == ad_stmt_kind::compound {
            // Compound statement
            result: std::string = "";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent);
            }
            return result;
        }
        else if stmt.kind == ad_stmt_kind::if_stmt {
            // If statement
            result := ind + "if " + emit_expr(stmt.expr) + " {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            if !stmt.else_stmts.empty() {
                result += ind + "} else {\n";
                for stmt.else_stmts do (s) {
                    result += emit_stmt(s, indent + 1);
                }
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::for_stmt {
            // For loop - emit as Cpp2 style
            result := ind + "for ";
            // Init statement
            if stmt.init_stmt != nullptr {
                init_code := emit_stmt(stmt.init_stmt*, 0);
                // Remove trailing newline and semicolon for init
                if init_code.ends_with(";\n") {
                    init_code = init_code.substr(0, init_code.size() - 2);
                }
                result += init_code;
            }
            result += "; " + emit_expr(stmt.expr) + " next ";
            // Increment - emit without semicolon
            incr_code := emit_expr(stmt.incr_expr);
            result += incr_code + " {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::foreach_stmt {
            // Range-based for loop
            result := ind + "for " + stmt.target;
            if stmt.type_name != "" && stmt.type_name != "auto" {
                result += " : " + stmt.type_name;
            }
            result += " in " + emit_expr(stmt.range_expr) + " {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::while_stmt {
            // While loop
            result := ind + "while " + emit_expr(stmt.expr) + " {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::do_while_stmt {
            // Do-while loop
            result := ind + "do {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "} while " + emit_expr(stmt.expr) + ";\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::try_catch {
            // Try-catch block
            result := ind + "try {\n";
            for stmt.stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "} catch (" + stmt.catch_type;
            if stmt.catch_var != "" {
                result += " " + stmt.catch_var;
            }
            result += ") {\n";
            for stmt.catch_stmts do (s) {
                result += emit_stmt(s, indent + 1);
            }
            result += ind + "}\n";
            return result;
        }
        else if stmt.kind == ad_stmt_kind::throw_stmt {
            return ind + "throw " + emit_expr(stmt.expr) + ";\n";
        }
        else if stmt.kind == ad_stmt_kind::raw_code {
            // Raw code - emit directly (already substituted)
            // The code is stored in stmt.target and may contain multiple lines
            // DEPRECATED: Will be removed after IR-based rule substitution is complete
            return ind + stmt.target + "\n";
        }
        return ind + "// unknown statement\n";
    }

    /**
     * @brief Emit the forward pass Cpp2 code.
     * @param ir Function IR.
     * @return Cpp2 source for forward pass.
     */
    emit_forward: (this, ir: ad_function_ir) -> std::string = {
        result: std::string = "// Forward pass\n";
        for ir.forward do (stmt) {
            result += emit_stmt(stmt, 1);
        }
        return result;
    }

    /**
     * @brief Emit the reverse pass Cpp2 code in reverse order.
     * @param ir Function IR.
     * @return Cpp2 source for reverse pass.
     */
    emit_reverse: (this, ir: ad_function_ir) -> std::string = {
        result: std::string = "// Reverse pass\n";

        // Seed the output adjoint(s)
        for ir.returns do (ret) {
            adj_name := ctx*.make_adj_name(ret.name);
            // Don't emit seed here - it's passed in as parameter
        }

        // Emit statements (already in correct reverse order from build_function_ir)
        for ir.reverse do (stmt) {
            result += emit_stmt(stmt, 1);
        }

        // Reset adjoints to zero after use
        for ir.returns do (ret) {
            adj_name := ctx*.make_adj_name(ret.name);
            result += std::string("    ") + adj_name + " = 0.0;\n";
        }

        return result;
    }

    /**
     * @brief Emit the complete reverse-mode function.
     * @param ir Function IR.
     * @return Cpp2 source for the _b function.
     */
    emit_function: (this, ir: ad_function_ir) -> std::string = {
        // Build signature
        result := ir.name + "_d: (\n";

        // Input parameters with adjoints
        for ir.params do (p) {
            pass_str: std::string = "in";
            if p.pass == passing_style::in { pass_str = "in"; }
            else if p.pass == passing_style::inout { pass_str = "inout"; }
            else if p.pass == passing_style::out { pass_str = "out"; }
            else if p.pass == passing_style::copy { pass_str = "copy"; }
            else if p.pass == passing_style::move { pass_str = "move"; }
            else if p.pass == passing_style::forward { pass_str = "forward"; }

            result += std::string("    ") + pass_str + " " + p.name + ": " + p.type_name + ",\n";
            // Add adjoint parameter
            adj_name := ctx*.make_adj_name(p.name);
            result += std::string("    inout ") + adj_name + ": " + p.type_name + ",\n";
        }

        // Return adjoint parameter
        for ir.returns do (r) {
            adj_name := ctx*.make_adj_name(r.name);
            result += std::string("    inout ") + adj_name + ": " + r.type_name + ",\n";
        }

        // Return type
        result += ") -> (";
        (copy first := true)
        for ir.returns do (r) {
            if !first { result += ", "; }
            first = false;
            result += std::string("out ") + r.name + ": " + r.type_name + " = 0.0";
        }
        result += ") = {\n";

        // Create _val variables for input parameters
        result += "// Setup value variables\n";
        for ir.params do (p) {
            val_name := ctx*.make_value_name(p.name);
            result += std::string("    ") + val_name + " := " + p.name + ";\n";
        }

        // Emit forward pass
        result += emit_forward(ir);

        // Emit reverse pass
        result += emit_reverse(ir);

        // Return
        result += "    return;\n";
        result += "}\n";

        return result;
    }
}

/**
 * @brief Debug dump for ad_ir_builder state.
 * @param builder Builder to dump.
 */
ad_ir_builder_debug_dump: (builder: ad_ir_builder) = {
    std::cout << "=== AD IR Builder State ===\n";
    std::cout << "  temp_counter: " << builder.temp_counter << "\n";
    std::cout << "  temp_names: [";
    (copy first := true)
    for builder.temp_names do (name) {
        if !first { std::cout << ", "; }
        first = false;
        std::cout << name;
    }
    std::cout << "]\n";
    std::cout << "=== End AD IR Builder State ===\n";
}

/**
 * @brief Internal reverse-mode AD processing - transforms a type using IR pipeline.
 *
 * 
 *                      REVERSE-MODE IR PROCESSING PIPELINE
 * 
 *
 * This function implements the core reverse-mode AD transformation:
 *
 *   
 *                            PROCESSING FLOW                                 
 *   
 *
 *   Input: @autodiff<"reverse"> annotated type
 *          
 *          
 *   
 *     STAGE 1: RULE DISCOVERY                                                 
 *      
 *     - Scan type for nested ad_rule_* types                                  
 *     - Extract: name, n_args, is_member, reverse() body                      
 *     - Store AST nodes of reverse() body for IR parsing                      
 *     - Build ad_rule_registry with all discovered rules                      
 *   
 *          
 *          
 *   
 *     STAGE 2: FOR EACH MEMBER FUNCTION                                       
 *      
 *                                                                             
 *       
 *       2a. CREATE CONTEXTS                                                 
 *       - reverse_autodiff_context: naming conventions, suffixes            
 *       - ad_ir_builder: IR construction with registry access               
 *       
 *                                                                            
 *                                                                            
 *       
 *       2b. BUILD FUNCTION IR (ad_ir_builder::build_function_ir)            
 *       - Walk function's reflection AST                                    
 *       - Build ad_expr nodes for each expression                           
 *       - Build ad_stmt nodes for each statement                            
 *       - Generate forward pass: x_val = x, compute intermediates           
 *       - Generate reverse pass: apply chain rule, accumulate adjoints      
 *       - Result: ad_func_ir with body_stmts and reverse_stmts              
 *       
 *                                                                            
 *                                                                            
 *       
 *       2c. EMIT CODE (ad_ir_emitter)                                       
 *       - emit_forward(): Convert body_stmts to Cpp1 string                 
 *       - emit_reverse(): Convert reverse_stmts to Cpp1 string              
 *       - emit_function(): Combine into complete backward function          
 *       
 *                                                                            
 *                                                                            
 *       
 *       2d. INJECT CODE                                                     
 *       - t.add_member(func_code): Add backward function to type            
 *       
 *   
 *          
 *          
 *   Output: Type with generated f_backward functions for each f
 *
 *   
 *                            KEY COMPONENTS                                  
 *   
 *
 *   ad_rule_registry
 *    rules: vector<ad_rule_meta>     All discovered rules
 *    has_rule(name, n_args, is_member) -> bool
 *    get_rule_type(name, ...) -> string
 *    apply_reverse_rule(name, ..., ctx) -> ad_reverse_rule_result
 *                                              ir_stmts: vector<ad_stmt>
 *
 *   ad_ir_builder
 *    ctx: *reverse_autodiff_context  Naming conventions
 *    registry: *ad_rule_registry     Rule lookup
 *    build_function_ir(mf) -> ad_func_ir
 *    build_expression(expr) -> ad_expr
 *    generate_reverse_for_expr(target, expr) -> ad_stmt
 *    report_error(msg, loc, context)  Hard failure on errors
 *
 *   ad_ir_emitter
 *    ctx: *reverse_autodiff_context  Naming conventions
 *    emit_expr(expr) -> string       Expression to code
 *    emit_stmt(stmt) -> string       Statement to code
 *    emit_forward(func_ir) -> string Forward pass code
 *    emit_reverse(func_ir) -> string Reverse pass code
 *
 *   
 *                         REVERSE PASS GENERATION                            
 *   
 *
 *   For each statement in the forward pass, generate corresponding adjoint code:
 *
 *   Forward Statement              Reverse Statement(s)
 *                 
 *   t = x + y                      x_adj += t_adj; y_adj += t_adj
 *   t = x - y                      x_adj += t_adj; y_adj -= t_adj
 *   t = x * y                      x_adj += y_val * t_adj; y_adj += x_val * t_adj
 *   t = x / y                      x_adj += t_adj / y_val; y_adj -= x_val * t_adj / (y_val * y_val)
 *   t = sin(x)                     x_adj += cos(x_val) * t_adj
 *   t = f(x, y)                    [lookup ad_rule_f::reverse and apply]
 *
 *   Statements are collected during forward pass, then reversed for backward pass.
 *
 * @param t Type declaration to transform (modified in place).
 * @param ctx Autodiff context with configuration (suffixes, order, mode).
 *
 * @see autodiff                 Main entry point (parses arguments)
 * @see ad_rule_registry         Rule storage and application
 * @see ad_ir_builder           IR construction from reflection AST
 * @see ad_ir_emitter           Code generation from IR
 */
autodiff_reverse_ir: (inout t: meta::type_declaration, ctx: *autodiff_context) = {
    std::cout << "\n";
    std::cout << "\n";
    std::cout << "  AD REVERSE IR STAGE: " << t.name() << "\n";
    std::cout << "\n";

    // Global error list for this processing run
    global_errors: ad_ir_error_list = ();

    // Print the original AST
    std::cout << "\n Original AST \n";
    print(t);
    std::cout << "\n";

    //-------------------------------------------------------------------
    // SUBTASK 3: Discover ad_rules in the type
    //-------------------------------------------------------------------
    std::cout << "\n Subtask 3: Rule Discovery \n";
    rule_registry: ad_rule_registry = ();
    discover_ad_rules(t, rule_registry);
    ad_rule_registry_debug_dump(rule_registry);
    std::cout << "\n";

    //-------------------------------------------------------------------
    // SUBTASK 4: Test expression builder on each function
    //-------------------------------------------------------------------
    (copy processing_failed := false)
    for t.get_member_functions() do (mf) {
        // Skip rule types (they have special structure)
        if mf.name().starts_with("ad_rule") {
            continue;
        }

        // Skip if we've already encountered errors
        if processing_failed {
            std::cout << "\n[SKIPPED] " << mf.name() << " (previous errors)\n";
            continue;
        }

        std::cout << "\n Subtask 5: Expression Builder for " << mf.name() << " \n";

        rc: reverse_autodiff_context = (ctx, mf);
        std::cout << "Function: " << mf.get_signature() << "\n";
        std::cout << "Suffixes: value=" << rc.value_suffix << " adj=" << rc.adj_suffix << "\n";

        // Create builder with context and registry
        builder: ad_ir_builder = (rc&, rule_registry&);

        // Test manual IR construction
        std::cout << "\n--- Manual IR Construction Tests ---\n";

        std::cout << "\nTest: build_identifier_expr('x')\n";
        x_ir := builder.build_identifier_expr("x", "double");
        ad_ir_debug_dump_expr(x_ir, 1);

        std::cout << "\nTest: build_literal_expr('3.14')\n";
        lit_ir := builder.build_literal_expr("3.14", "double");
        ad_ir_debug_dump_expr(lit_ir, 1);

        std::cout << "\nTest: build_member_access_expr(x, 'adj')\n";
        member_ir := builder.build_member_access_expr(x_ir, "adj", "double");
        ad_ir_debug_dump_expr(member_ir, 1);

        std::cout << "\nTest: derive_op_name for mul(x, y)\n";
        y_ir := builder.build_identifier_expr("y", "double");
        mul_args: std::vector<ad_expr> = ();
        mul_args.push_back(x_ir);
        mul_args.push_back(y_ir);
        op_name := builder.derive_op_name(ad_op_kind::mul, mul_args);
        std::cout << "  Derived name: " << op_name << "\n";

        std::cout << "\nTest: gen_temp_name('tmp')\n";
        tmp1 := builder.gen_temp_name("tmp");
        tmp2 := builder.gen_temp_name("tmp");
        std::cout << "  Generated: " << tmp1 << ", " << tmp2 << "\n";

        // Dump builder state
        ad_ir_builder_debug_dump(builder);

        // Build the complete function IR using the builder
        std::cout << "\n--- Building Function IR (using build_function_ir) ---\n";
        func_ir := builder.build_function_ir(mf);

        // Dump the function IR
        ad_ir_debug_dump(func_ir);

        //-------------------------------------------------------------------
        // Task 11 & 12: Test emitter
        //-------------------------------------------------------------------
        std::cout << "\n--- IR Emitter Test ---\n";
        emitter: ad_ir_emitter = (rc&);

        // Emit forward pass
        std::cout << "Forward pass emission:\n";
        fwd_code := emitter.emit_forward(func_ir);
        std::cout << fwd_code;

        // Emit reverse pass
        std::cout << "\nReverse pass emission:\n";
        rev_code := emitter.emit_reverse(func_ir);
        std::cout << rev_code;

        // Emit complete function
        std::cout << "\nComplete function emission:\n";
        func_code := emitter.emit_function(func_ir);
        std::cout << func_code;

        // Add the backward function to the type
        if !func_code.empty() {
            t.add_member(func_code);
            std::cout << "  -> Added backward function to type\n";
        }

        // Test rule lookup
        std::cout << "\n--- Rule Lookup Tests ---\n";
        has_softplus := rule_registry.has_rule("softplus", 1, false);
        std::cout << "  has_rule('softplus', 1, false): " << has_softplus << "\n";
        if has_softplus {
            std::cout << "    rule_type: " << rule_registry.get_rule_type("softplus", 1, false) << "\n";
        }

        has_sin := rule_registry.has_rule("sin", 1, false);
        std::cout << "  has_rule('sin', 1, false): " << has_sin << "\n";

        // Check for errors from the builder
        if builder.has_errors() {
            std::cout << "\n";
            std::cout << "\n";
            std::cout << "  AD IR BUILDER ERRORS in " << mf.name() << "\n";
            std::cout << "\n";
            builder.print_errors();
            // Merge errors into global list
            for builder.errors.errors do (err) {
                global_errors.add_error(err.message, err.location, err.context);
            }
            processing_failed = true;
        }

        std::cout << "\n";
    }

    // Print final status
    if global_errors.has_errors() {
        std::cout << "\n\n";
        std::cout << "  AD REVERSE IR STAGE FAILED - " << global_errors.count() << " error(s)\n";
        std::cout << "\n";
        std::cout << "\nError Summary:\n";
        global_errors.print_all();
        std::cout << "\n";
    }
    else {
        std::cout << "\n\n";
        std::cout << "  AD REVERSE IR STAGE COMPLETE - No errors\n";
        std::cout << "\n\n";
    }
}

/**
 * @brief Accumulates generated code for forward and reverse passes.
 *
 * `rws_backprop` is built in reverse order by prepending snippets.
 */
autodiff_diff_code: type = {
    /// Owning context with mode/order information.
    public ctx: *autodiff_context;

    /// Forward-mode code.
    public fwd         : std::string = "";
    /// Reverse-mode primal pass code.
    public rws_primal  : std::string = "";
    /// Reverse-mode backprop pass code (prepended).
    public rws_backprop: std::string = "";

    /**
     * @brief Initialize with an autodiff context.
     * @param ctx_ Context to associate with this buffer.
     * @return No return value.
     */
    operator=:(out this, ctx_: *autodiff_context) = {
        ctx = ctx_;
    }
    /**
     * @brief Copy another diff buffer.
     * @param that Buffer to copy from.
     * @return No return value.
     */
    operator=:(out this, that) = {}

    /**
     * @brief Append forward code if forward mode is enabled.
     * @param v Code snippet to append.
     * @return No return value.
     */
    add_forward         : (inout this, v: std::string) = { if ctx*.is_forward() { fwd          += v; }}
    /**
     * @brief Append reverse primal code if reverse mode is enabled.
     * @param v Code snippet to append.
     * @return No return value.
     */
    add_reverse_primal  : (inout this, v: std::string) = { if ctx*.is_reverse() { rws_primal   += v; }}
    /**
     * @brief Prepend reverse backprop code if reverse mode is enabled.
     * @param v Code snippet to prepend.
     * @return No return value.
     */
    add_reverse_backprop: (inout this, v: std::string) = { if ctx*.is_reverse() { rws_backprop = v + rws_backprop; }}

    /**
     * @brief Clear all generated buffers.
     * @return No return value.
     */
    reset: (inout this) = {
        fwd          = "";
        rws_primal   = "";
        rws_backprop = "";
    }

    /**
     * @brief Temporary assignment into the forward buffer.
     * @param v Forward code string.
     * @return No return value.
     */
    operator=:(inout this, v: std::string) = {
        ctx = ctx*.get_self();
        fwd = v;
    }

    /**
     * @brief Temporary forward buffer append.
     * @param v Forward code string to append.
     * @return No return value.
     */
    operator+=: (inout this, v: std::string) = {
        fwd += v;
    }

    /**
     * @brief Temporary forward buffer append from another diff buffer.
     * @param v Buffer to append from.
     * @return No return value.
     */
    operator+=: (inout this, v: autodiff_diff_code) = {
        fwd += v.fwd;
    }

    /**
     * @brief Check if the forward buffer is empty.
     * @return True if forward code buffer is empty.
     */
    empty: (this) -> bool = {
        return fwd.empty();
    }
}

// // Temporary: TODO: remove when everything has been adapted to primal, fwd, rws pushes.
// to_string: (v: autodiff_diff_code) -> std::string = {
//     return v.fwd;
// }

/**
 * @brief Traverser that detects whether a declaration/expression is active.
 */
autodiff_activity_check: type = {
    this: simple_traverser = ();

    /// AD context used for lookups.
    public ctx   : *autodiff_context;
    /// True if an active term is found.
    public active: bool              = false;

    /**
     * @brief Initialize with an autodiff context.
     * @param ctx_ Context used for activity queries.
     * @return No return value.
     */
    operator=: (out this, ctx_: *autodiff_context) = {
        ctx = ctx_;
    }

    /**
     * @brief Visit type members to determine activity of contained objects.
     * @param t Type declaration to inspect.
     * @return No return value.
     */
    traverse: (override inout this, t: meta::type_declaration) = {
        for t.get_members()
        do  (m)
        {
            if m.is_object() || m.is_member_object() {
                pre_traverse(m);
            }

            // TODO: Maybe also add functions.
        }
    }

    /**
     * @brief Visit object declarations and infer activity from type or initializer.
     * @param o Object declaration to inspect.
     * @return No return value.
     */
    traverse: (override inout this, o: meta::object_declaration) = {

        type := o.type();

        if "_" == type {
            if o.has_initializer() {
                pre_traverse(o.get_initializer());
            }
            else {
                // Assume active
                active = true;
            }
        }
        else {
            active |= ctx*.is_type_active(type);
        }
    }

    /**
     * @brief Visit primary expressions and track active identifiers/literals.
     * @param primary Primary expression to inspect.
     * @return No return value.
     */
    traverse: (override inout this, primary: meta::primary_expression) =
    {
        if primary.is_identifier() {
            active |= ctx*.is_variable_active(primary.to_string());
        }
        else if primary.is_expression_list() {
            for primary.as_expression_list().get_expressions() do (cur) {
                pre_traverse(cur);
            }
        }
        else if primary.is_literal() {
            // TODO: Improve check
            if primary.to_string().contains(".") {
                active = true;
            }
        }
        else if primary.is_declaration() {
            pre_traverse(primary.as_declaration());
        }
        else {
            primary.error("AD: Unknown primary expression kind: (primary.to_string())$");
        }
    }

    /**
     * @brief Visit postfix expressions and check function call arguments.
     * @param postfix Postfix expression to inspect.
     * @return No return value.
     */
    traverse: (override inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        is_func  := false;

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                continue;
            }
            if term.get_op() == "(" && i + 1 == terms.ssize() { // Function operator has to be the last
                is_func = true;
                continue;
            }
            else {
                postfix.error("AD: Unknown operator for postfix expression. op: (term.get_op())$ expr: (postfix)$");
            }
        }

        // TODO: Really check for members
        if !is_func || terms.ssize() != 1 {
            active |= ctx*.is_variable_active(postfix.get_primary_expression().to_string());
        }

        if is_func {
            // Check arguments of function
            for terms.back().get_expression_list().get_expressions() do (cur) {
                pre_traverse(cur);
            }
        }
    }
}

/**
 * @brief Base class for AD handlers with shared context and diff buffer.
 */
autodiff_handler_base: type = {
    /// Current autodiff context.
    public ctx: *autodiff_context;

    /// Accumulated output code for this handler.
    public diff : autodiff_diff_code;

    /**
     * @brief Initialize with context and a fresh diff buffer.
     * @param ctx_ Context to associate.
     * @return No return value.
     */
    operator=: (out this, ctx_: *autodiff_context) = {
        ctx = ctx_;
        diff = (ctx);
    }

    /**
     * @brief Append another handler's diff buffers.
     * @param o Handler to append from.
     * @return No return value.
     */
    append: (inout this, in_ref o: autodiff_handler_base) = {
        diff.fwd          += o.diff.fwd;
        diff.rws_primal   += o.diff.rws_primal;
        diff.rws_backprop  = o.diff.rws_backprop + diff.rws_backprop;
    }
}

/**
 * @brief Builds primal/forward/reverse expressions for a single expression.
 */
autodiff_expression_handler: type = {
    this: simple_traverser = ();
    this: autodiff_handler_base;

    /// Alias to base traverser type.
    base: type == simple_traverser;

    /// Latest primal expression string.
    public primal_expr: std::string = "";
    /// Latest forward-mode expression string.
    public fwd_expr   : std::string = "";
    /// Latest reverse-mode backprop code snippet.
    public rws_expr   : std::string = "";

    /**
     * @brief Initialize with context.
     * @param ctx_ Autodiff context to use.
     * @return No return value.
     */
    operator=: (out this, ctx_: *autodiff_context) = {
        autodiff_handler_base = (ctx_);
    }

    /**
     * @brief Append suffix unless using wildcard `_`.
     * @param lhs Base name.
     * @param suffix Suffix to append.
     * @return Name with suffix unless lhs is `_`.
     */
    add_suffix_if_not_wildcard: (this, lhs: std::string, suffix: std::string) -> std::string = {
        if "_" == lhs {
            return lhs;
        }
        else {
            return lhs + suffix;
        }
    }

    /**
     * @brief Replace `_r_`, `_rd_`, `_rb_` placeholders in backprop templates.
     * @param rhs_b Backprop template code.
     * @param lhs Primal variable name.
     * @param lhs_d Forward variable name.
     * @param lhs_b Reverse adjoint name.
     * @return Backprop code with placeholders substituted.
     */
    prepare_backprop: (this, rhs_b: std::string, lhs: std::string, lhs_d: std::string, lhs_b: std::string) -> std::string = {
        r := rhs_b;
        r  = string_util::replace_all(r, "_r_", lhs);
        r  = string_util::replace_all(r, "_rd_", lhs_d);
        r  = string_util::replace_all(r, "_rb_", lhs_b);

        return r;
    }
    /**
     * @brief Replace placeholders using suffix-based names.
     * @param rhs_b Backprop template code.
     * @param lhs Primal variable name.
     * @return Backprop code with placeholders substituted.
     */
    prepare_backprop: (this, rhs_b: std::string, lhs: std::string) -> std::string = prepare_backprop(rhs_b, lhs, lhs + ctx*.fwd_suffix, lhs + ctx*.rws_suffix);

    /**
     * @brief Emit assignment for primal, forward, and reverse paths.
     * @param lhs Primal LHS name.
     * @param lhs_d Forward LHS name.
     * @param lhs_b Reverse adjoint LHS name.
     * @param rhs Primal RHS expression.
     * @param rhs_d Forward RHS expression.
     * @param rhs_b Reverse backprop template.
     * @return No return value.
     */
    gen_assignment: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string, rhs: std::string, rhs_d: std::string, rhs_b: std::string) = {
        diff.add_forward("(lhs_d)$ = (rhs_d)$;\n");
        diff.add_forward("(lhs)$   = (rhs)$;\n");

        if ctx*.is_taylor() {
            diff.add_reverse_primal("(lhs_d)$ = (rhs_d)$;\n");
        }
        diff.add_reverse_primal("(lhs)$   = (rhs)$;\n");
        diff.add_reverse_backprop("(lhs_b)$ = 0.0;\n");
        diff.add_reverse_backprop(prepare_backprop(rhs_b, lhs, lhs_d, lhs_b));
    }
    /**
     * @brief Emit assignment for the current expression strings.
     * @param lhs Primal LHS name.
     * @param lhs_d Forward LHS name.
     * @param lhs_b Reverse adjoint LHS name.
     * @return No return value.
     */
    gen_assignment: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string)
        = gen_assignment(lhs, lhs_d, lhs_b, primal_expr, fwd_expr, rws_expr);
    /**
     * @brief Emit assignment using suffix defaults.
     * @param lhs Primal LHS name.
     * @return No return value.
     */
    gen_assignment: (inout this, lhs: std::string)
        = gen_assignment(lhs, add_suffix_if_not_wildcard(lhs, ctx*.fwd_suffix), add_suffix_if_not_wildcard(lhs, ctx*.rws_suffix), primal_expr, fwd_expr, rws_expr);


    /**
     * @brief Emit declaration for primal, forward, and reverse paths.
     * @param lhs Primal LHS name.
     * @param lhs_d Forward LHS name.
     * @param lhs_b Reverse adjoint LHS name.
     * @param rhs Primal RHS expression.
     * @param rhs_d Forward RHS expression.
     * @param rhs_b Reverse backprop template.
     * @param type Primal type name.
     * @param type_d Forward type name.
     * @param type_b Reverse type name.
     * @return No return value.
     */
    gen_declaration: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string, rhs: std::string, rhs_d: std::string, rhs_b: std::string, type: std::string, type_d: std::string, type_b: std::string) = {
        diff.add_forward("(lhs_d)$: (type_d)$ = (rhs_d)$;\n");
        diff.add_forward("(lhs)$  : (type)$ = (rhs)$;\n");

        if ctx*.is_taylor() {
            diff.add_reverse_primal("(lhs_d)$: (type_d)$ = (rhs_d)$;\n");
        }
        diff.add_reverse_primal("(lhs_b)$ : (type_b)$ = 0.0;\n");
        diff.add_reverse_primal("(lhs)$  : (type)$ = (rhs)$;\n");
        diff.add_reverse_backprop("(lhs_b)$ = 0.0;\n");
        diff.add_reverse_backprop(prepare_backprop(rhs_b, lhs, lhs_d, lhs_b));
    }
    /**
     * @brief Emit declaration using context-derived AD types.
     * @param lhs Primal LHS name.
     * @param lhs_d Forward LHS name.
     * @param lhs_b Reverse adjoint LHS name.
     * @param rhs Primal RHS expression.
     * @param rhs_d Forward RHS expression.
     * @param rhs_b Reverse backprop template.
     * @param type Primal type name.
     * @return No return value.
     */
    gen_declaration: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string, rhs: std::string, rhs_d: std::string, rhs_b: std::string, type: std::string)
        = gen_declaration(lhs, lhs_d, lhs_b, rhs, rhs_d, rhs_b, type, ctx*.get_fwd_ad_type(type) , ctx*.get_rws_ad_type(type));
    /**
     * @brief Emit declaration using current expression strings.
     * @param lhs Primal LHS name.
     * @param lhs_d Forward LHS name.
     * @param lhs_b Reverse adjoint LHS name.
     * @param type Primal type name.
     * @return No return value.
     */
    gen_declaration: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string, type: std::string)
        = gen_declaration(lhs, lhs_d, lhs_b, primal_expr, fwd_expr, rws_expr, type);
    /**
     * @brief Emit declaration using suffix defaults.
     * @param lhs Primal LHS name.
     * @param type Primal type name.
     * @return No return value.
     */
    gen_declaration: (inout this, lhs: std::string, type: std::string)
        = gen_declaration(lhs, lhs + ctx*.fwd_suffix, lhs + ctx*.rws_suffix, type);



    /// Bundle of primal/forward/reverse names for an expression.
    primal_fwd_rws_name: @struct<noforward> type = {
        /// Primal value name or expression.
        primal: std::string = "";
        /// Forward value name or expression.
        fwd   : std::string = "";
        /// Reverse adjoint name or expression.
        rws   : std::string = "";
        /// True if expression is active.
        active: bool        = false;
    }

    /**
     * @brief Evaluate a list of expression arguments.
     * @param list Expression list to evaluate.
     * @return List of primal/forward/reverse names for each argument.
     */
    handle_expression_list: (inout this, list: meta::expression_list) -> std::vector<primal_fwd_rws_name> = {
        args : std::vector<primal_fwd_rws_name> = ();
        for list.get_expressions() do (expr) {
            args.push_back(handle_expression_term(expr));
        }

        return args;
    }

    /**
     * @brief Evaluate a single expression term and map to primal/fwd/rws names.
     * @param term Expression term to evaluate.
     * @return Name bundle describing the term.
     */
    handle_expression_term :(inout this, term) -> primal_fwd_rws_name = {
        if term.is_identifier() {
            primal := term.to_string();
            fwd    := primal + ctx*.fwd_suffix;
            rws    := primal + ctx*.rws_suffix;

            decl := ctx*.lookup_variable_declaration(primal);
            if decl.is_member {
                fwd = "this(ctx*.fwd_suffix)$." + fwd;
                rws = "this(ctx*.rws_suffix)$." + rws;
            }

            if decl.is_active {
                return (primal, fwd, rws, true);
            }
            else {
                return (primal, "", "", false);
            }

        }
        else if term.is_expression_list() {
            exprs := term..as_expression_list()..get_expressions();
            if exprs.ssize() != 1 {
                term.error("Can not handle multiple expressions. (term.to_string())");
                return ("error", "", "", false);
            }
            expr := exprs[0];
            bin_expr := expr..as_assignment_expression();

            if bin_expr.terms_size() != 0 {
                term.error("Can not handle assign expr inside of expression. (expr.to_string())$");
                return ("error", "", "", false);
            }

            return handle_expression_term(bin_expr.get_terms().front().get_term());
        }
        else {
            // Nothing special. A regular expression.
            expr := term;

            ada: autodiff_activity_check = (ctx);
            ada.pre_traverse(expr);

            if ada.active {

                ad : autodiff_expression_handler = (ctx);
                ad..pre_traverse(expr);
                t := ctx*.gen_temporary();
                ad.gen_declaration(t, "double"); // TODO: get type of expression
                append(ad);

                r : primal_fwd_rws_name = (t, t + ctx*.fwd_suffix, t + ctx*.rws_suffix, true); // TODO: Check why on return (t, t + ctx*.fwd_suffix) the primal is initialized empty. Probably because of the move(t)
                _ = t;
                return r;
            }
            else {
                return (expr.to_string(), "", "", false);
            }
        }
    }

    /**
     * @brief Handle function or member-function calls, producing primal/fwd/rws code.
     * @param postfix Postfix expression describing the call.
     * @param has_return True if the call has a return value.
     * @return No return value.
     */
    handle_function_call: (inout this, postfix: meta::postfix_expression, has_return: bool) = {
        terms := postfix.get_terms();

        is_func  := true;

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                continue;
            }
            if term.get_op() == "(" && i + 1 == terms.ssize() { // Function operator has to be the last
                continue;
            }

            is_func = false;
        }

        // Check for function call, everything else is not handled.
        if !(is_func) {
            postfix.error( "AD: Postfix expressions are only handled for function calls, or member function calls. Do not know how to handle: (postfix.to_string())$" );
            return;
        }

        object         : std::string = "";
        object_d       : std::string = "";
        object_b       : std::string = "";
        function_name : std::string = "";
        args          : std::vector<primal_fwd_rws_name> = ();

        primary := postfix.get_primary_expression();

        if 1 != terms.ssize() {
            object   = primary.to_string();
            object_d = primary.to_string() + ctx*.fwd_suffix;
            object_b = primary.to_string() + ctx*.rws_suffix;
        }
        else {
            function_name = primary.to_string();
        }

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                assert(term.is_id_expression());
                name := term.get_id_expression().to_string();

                if i + 2 == terms.ssize() { // Second last term is function name, last term is function argument list
                    function_name = name;
                }
                else {
                    object   += "." + name;
                    object_d += "." + name + ctx*.fwd_suffix;
                }
            }
            else if term.get_op() == "(" {
                assert(term.is_expression_list());

                args = handle_expression_list(term.get_expression_list());
            }
            else {
                postfix.error("AD: Do not know how to handle postfix term: (term.to_string())$");
            }
        }

        if handle_special_function(object, object_d, object_b, function_name, args) {
            return;
        }

        if object.contains(".") {
            postfix.error("AD: can not handle nested member function calls: (postfix.to_string())$");
            return;
        }

        call_primal: std::string = "";
        call_fwd   : std::string = "";
        call_rws   : std::string = "";

        // All arguments have now been handled. Form the function call
        ret_temp : std::string = "";
        if has_return {
            ret_temp = ctx*.gen_temporary();
            call_fwd += "(ret_temp)$ := ";
        }

        // TODO: This is untested for functions with no return value. Requires handling of out and inout parameters in functions.
        if !object.empty() { // Prepend object call
            call_primal += "(object)$.";
            call_fwd    += "(object)$.";
            call_rws    += "(object)$.";
        }
        call_primal += "(function_name)$(";
        call_fwd    += "(function_name)$(ctx*.fwd_suffix)$(";
        call_rws    += "(function_name)$(ctx*.rws_suffix)$(";
        if !object.empty() { // Add this_d argument.
            call_fwd += "(object_d)$, ";
            call_rws += "(object_b)$, ";
        }
        for args do (arg) {
            // TODO: Add taylor reverse handling.
            call_primal += "(arg.primal)$, ";
            call_fwd    += "(arg.primal)$, ";
            call_rws    += "(arg.primal)$, ";
            if arg.active {
                call_fwd += "(arg.fwd)$, ";
                call_rws += "(arg.rws)$, ";
            }
        }

        if has_return {
            functions : std::vector<meta::function_declaration> = ();
            if !object.empty() {
                obj_decl := ctx*.lookup_variable_declaration(object);
                obj_decl_types := ctx*.lookup_type_declaration(obj_decl.decl);

                if obj_decl_types.empty() {
                    postfix.error("AD: Could not find type declaration for `(object)$ with type (obj_decl.decl)$`.\n"
                              "    If cpp2 object: this is an alpha limitation, please declare it befor the current declaration.\n"
                              "    If cpp function: please add a special handling for this member function.");
                    return;
                }
                functions = ctx*.lookup_member_function_declaration(obj_decl_types[0], function_name);

                ctx*.add_for_differentiation(obj_decl_types[0]); // TODO: Add more fine grained differentiation.
            }
            else {
                functions = ctx*.lookup_function_declaration(function_name);
                if functions.ssize() == 0 {
                    postfix.error("AD: Could not find function declaration for `(function_name)$`.\n"
                                "    If cpp2 function: this is an alpha limitation, please declare it befor the current declaration.\n"
                                "    If cpp function: please add a special handling for this function.");
                    return;
                }
                else if functions.ssize() != 1 {
                    postfix.error("AD: No handling for overload resultion is currently implemented.");
                    return;
                }

                ctx*.add_for_differentiation(functions[0]);
            }

            ret_name : std::string = "r"; // Default for regular return.
            returns := functions[0].get_returns();
            if !returns.empty() {
                if returns.ssize() != 1 {
                    postfix.error("AD: Expecting single return.");
                }

                for returns do (cur) {
                    ret_name = cur.get_declaration().name();
                }
            }

            ret_name_d : std::string = ret_name + ctx*.fwd_suffix;
            ret_name_b : std::string = ret_name + ctx*.rws_suffix;

            call_rws += "_rb_, ";

            call_primal += ")";
            call_fwd    += ");\n";
            call_rws    += ");\n";

            diff.add_forward(call_fwd);

            primal_expr = call_primal;
            fwd_expr    = "(ret_temp)$.(ret_name_d)$";
            rws_expr    = "_ = (call_rws)$";
        }
        else {
            call_primal += ");\n";
            call_fwd    += ");\n";
            call_rws    += ");\n";

            diff.add_forward(call_fwd);
            diff.add_reverse_primal(call_primal);
            diff.add_reverse_backprop(call_rws);
        }

        // TODO: Add function to list of functions/objects for differentiation for the no return case.
    }

    /**
     * @brief Try special-case handling for known functions (sin, cos, etc).
     * @param object Object name for member calls (empty for free functions).
     * @param object_d Object forward name.
     * @param object_b Object reverse name.
     * @param function_name Function name to match.
     * @param args Argument bundles.
     * @return True if a special-case handler matched.
     */
    handle_special_function: (inout this, object: std::string, object_d: std::string, object_b: std::string, function_name: std::string, args: std::vector<primal_fwd_rws_name>) -> bool = {

        r := ctx*.lookup_special_function_handling(function_name, unchecked_narrow<int>(args.ssize()), !object.empty());

        if !r.m {
            return false; // No match
        }

        // Have a match, do the replacement
        code_primal: std::string = r.code_primal;
        code_fwd   : std::string = r.code_fwd;
        code_rws   : std::string = r.code_rws;

        if !object.empty() {
            code_primal = string_util::replace_all(code_primal, "_o_", object);
            code_primal = string_util::replace_all(code_primal, "_od_", object_d);

            code_fwd = string_util::replace_all(code_fwd, "_o_", object);
            code_fwd = string_util::replace_all(code_fwd, "_od_", object_d);

            code_rws = string_util::replace_all(code_rws, "_o_", object);
            code_rws = string_util::replace_all(code_rws, "_od_", object_d);
            code_rws = string_util::replace_all(code_rws, "_ob_", object_b);
        }

        (copy i := 1)
        for args do (arg) {
            code_primal = string_util::replace_all(code_primal, "_a(i)$_", arg.primal);
            code_primal = string_util::replace_all(code_primal, "_ad(i)$_", arg.fwd);

            code_fwd = string_util::replace_all(code_fwd, "_a(i)$_", arg.primal);
            code_fwd = string_util::replace_all(code_fwd, "_ad(i)$_", arg.fwd);

            code_rws = string_util::replace_all(code_rws, "_a(i)$_", arg.primal);
            code_rws = string_util::replace_all(code_rws, "_ad(i)$_", arg.fwd);
            code_rws = string_util::replace_all(code_rws, "_ab(i)$_", arg.rws);
        }

        primal_expr = code_primal;
        fwd_expr    = code_fwd;
        rws_expr    = code_rws;

        return true;
    }

    /**
     * @brief Dispatch expression traversal.
     * @param expr Expression node to traverse.
     * @return No return value.
     */
    traverse: (override inout this, expr: meta::expression) = {
        base::traverse(expr);
    }

    /**
     * @brief Report unsupported assignment expressions.
     * @param binexpr Assignment expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::assignment_expression) = {
        binexpr.error( "AD: Assign expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported logical-or expressions.
     * @param binexpr Logical-or expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::logical_or_expression) = {
        binexpr.error( "AD: Logical or expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported logical-and expressions.
     * @param binexpr Logical-and expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::logical_and_expression) = {
        binexpr.error( "AD: Logical and expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported bitwise-or expressions.
     * @param binexpr Bitwise-or expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::bit_or_expression) = {
        binexpr.error( "AD: Bit or expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported bitwise-xor expressions.
     * @param binexpr Bitwise-xor expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::bit_xor_expression) = {
        binexpr.error( "AD: Bit xor expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported bitwise-and expressions.
     * @param binexpr Bitwise-and expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::bit_and_expression) = {
        binexpr.error( "AD: Bit and expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported equality expressions.
     * @param binexpr Equality expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::equality_expression) = {
        binexpr.error( "AD: Equality or expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported relational expressions.
     * @param binexpr Relational expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::relational_expression) = {
        binexpr.error( "AD: Relational expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported compare expressions.
     * @param binexpr Compare expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::compare_expression) = {
        binexpr.error( "AD: Compare or expressions are not yet handled." );
    }

    /**
     * @brief Report unsupported shift expressions.
     * @param binexpr Shift expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::shift_expression) = {
        binexpr.error( "AD: Shift or expressions are not yet handled." );
    }

    /**
     * @brief Handle additive expressions and emit sum/adjoint accumulation.
     * @param binexpr Additive expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::additive_expression) = {
        terms := binexpr.get_terms();

        first     := true;
        first_fwd := true;
        op  :   std::string = "+";
        fwd :   std::string = "";
        rws :   std::string = "";
        primal: std::string = "";
        for terms do (term) {
            if !first {
                op      = term.get_op().to_string();
                primal += " (op)$ ";
            }

            var   := handle_expression_term(term.get_term());
            if var.active {
                if first_fwd {
                    if op == "-" {// Special handling for first fwd termn with minus
                        fwd += "-(var.fwd)$";
                    }
                    else { // Special handling for first fwd term with plus
                        fwd += var.fwd;
                    }
                }
                else {
                    fwd += "(op)$ (var.fwd)$";
                }
                rws    += "(var.rws)$ (op)$= _rb_;\n";

                first_fwd = false;
            }
            primal += var.primal;

            first = false;
        }

        primal_expr = primal;
        fwd_expr    = fwd;
        rws_expr    = rws;
    }

    /**
     * @brief Handle multiplicative expressions and emit product/quotient derivatives.
     * @param binexpr Multiplicative expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::multiplicative_expression) = {
        terms := binexpr.get_terms();

        var_a := handle_expression_term(terms[0].get_term());

        i : int = 1;
        while i < terms.ssize() next i += 1 {
            var_b := handle_expression_term(terms[i].get_term());

            op := terms[i].get_op().to_string();

            fwd    : std::string = "";
            rws    : std::string = "";
            primal : std::string = "";

            if "*" == op {
                if ctx*.is_taylor() {
                    // TODO: Add taylor overloads
                    fwd = "(var_a.fwd)$..mul((var_b.fwd)$, (var_a.primal)$, (var_b.primal)$)";
                    if var_a.active {
                        //fwd += "(var_b.primal)$ * (var_a.fwd)$";
                        rws += "(var_a.rws)$ += (var_b.fwd)$..mul(_rb_, (var_b.primal)$, _r_);\n";
                    }
                    if var_b.active {
                        //if !fwd.empty() { fwd += " + "; }
                        //fwd += "(var_a.primal)$ * (var_b.fwd)$";
                        rws += "(var_b.rws)$ += (var_a.fwd)$..mul(_rb_, (var_a.primal)$, _r_);\n";
                    }
                }
                else {
                    if var_a.active {
                        fwd += "(var_b.primal)$ * (var_a.fwd)$";
                        rws += "(var_a.rws)$ += (var_b.primal)$ * _rb_;\n";
                    }
                    if var_b.active {
                        if !fwd.empty() { fwd += " + "; }
                        fwd += "(var_a.primal)$ * (var_b.fwd)$";
                        rws += "(var_b.rws)$ += (var_a.primal)$ * _rb_;\n";
                    }
                }
                primal = "(var_a.primal)$ * (var_b.primal)$";
            }
            else if "/" == op {
                if ctx*.is_taylor() {
                    // TODO: Add taylor overloads
                    fwd = "(var_a.fwd)$.div((var_b.fwd)$, (var_a.primal)$, (var_b.primal)$)";
                    if var_a.active {
                        rws += "(var_a.rws)$ += _rb_.div((var_b.fwd)$, _r_, (var_b.primal)$);\n";
                    }
                    if var_b.active {
                        rws += "(var_b.rws)$ -= (var_a.fwd)$.mul(_rb_, (var_a.primal)$, _r_).div((var_b.fwd)$.mul((var_b.fwd)$, (var_b.primal)$, (var_b.primal)$), (var_a.primal)$ * _r_, (var_b.primal)$ * (var_b.primal)$);\n";
                    }
                }
                else {
                    if var_a.active {
                        fwd += "(var_a.fwd)$ / (var_b.primal)$";
                        rws = "(var_a.rws)$ += _rb_ / (var_b.primal)$;\n";
                    }
                    if var_b.active {
                        if !fwd.empty() { fwd += " + "; }
                        fwd += "-(var_a.primal)$ * (var_b.fwd)$ / ((var_b.primal)$ * (var_b.primal)$)";
                        rws += "(var_b.rws)$ -= (var_a.primal)$ * _rb_ / ((var_b.primal)$ * (var_b.primal)$);\n";
                    }
                }
                primal = "(var_a.primal)$ / (var_b.primal)$";
            }
            else {
                binexpr.error( "unkown multiplicative operator '(op)$'");
            }


            if i + 1 == terms.ssize() {
                primal_expr = primal;
                fwd_expr    = fwd;
                rws_expr    = rws;
            }
            else {
                // Temporary
                var_a.primal = ctx*.gen_temporary();
                var_a.fwd    = var_a.primal + ctx*.fwd_suffix;
                var_a.rws    = var_a.primal + ctx*.rws_suffix;
                var_a.active = var_a.active | var_b.active;
                gen_declaration(var_a.primal, var_a.fwd, var_a.rws, primal, fwd, rws, "", "", "");
            }
        }
    }

    /**
     * @brief Report unsupported is/as expressions.
     * @param isas is/as expression node.
     * @return No return value.
     */
    traverse: (override inout this, isas: meta::is_as_expression) = {
        isas.error( "AD: Is as expressions are not yet handled." );
    }

    /**
     * @brief Handle prefix operations as unary transforms.
     * @param prefix Prefix expression node.
     * @return No return value.
     */
    traverse: (override inout this, prefix: meta::prefix_expression) =
    {
        ops := prefix.get_ops();

        if ops.ssize() != 1 {
            prefix.error( "AD: Can only handle one prefix operation. Expression is: (prefix.to_string())$" );
        }

        ad: autodiff_expression_handler = (ctx);
        ad.pre_traverse(prefix.get_postfix_expression());
        append(ad);

        primal_expr = ops[0] + ad.primal_expr;
        fwd_expr    = ops[0] + ad.fwd_expr;
    }

    /**
     * @brief Handle postfix expressions for calls or member access.
     * @param postfix Postfix expression node.
     * @return No return value.
     */
    traverse: (override inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        is_func  := false;

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                continue;
            }
            if term.get_op() == "(" && i + 1 == terms.ssize() { // Function operator has to be the last
                is_func = true;
                continue;
            }
            else {
                postfix.error("AD: Unknown operator for postfix expression. op: (term.get_op())$ expr: (postfix)$");
            }
        }

        if is_func {
            handle_function_call(postfix, true);
        }
        else {
            // Member access

            primary      :             = postfix.get_primary_expression();
            obj_access   : std::string = primary.to_string();
            obj_access_d : std::string = obj_access + ctx*.fwd_suffix;

            for terms do (term)  {
                obj_access   += term.get_op() + term.get_id_expression().to_string();
                obj_access_d += term.get_op() + term.get_id_expression().to_string() + ctx*.fwd_suffix;
            }

            primal_expr = obj_access;
            fwd_expr    = obj_access_d;
        }
    }

    /**
     * @brief Handle primary expressions (identifiers, literals, empty tuple).
     * @param primary Primary expression node.
     * @return No return value.
     */
    traverse: (override inout this, primary: meta::primary_expression) =
    {
        if primary.is_identifier() {
            primal_expr = primary.to_string();
            fwd_expr    = add_suffix_if_not_wildcard(primal_expr, ctx*.fwd_suffix);
            rws_expr    = add_suffix_if_not_wildcard(primal_expr, ctx*.rws_suffix);

            decl := ctx*.lookup_variable_declaration(primal_expr);
            if decl.is_member {
                fwd_expr = "this(ctx*.fwd_suffix)$." + fwd_expr;
                rws_expr = "this(ctx*.rws_suffix)$." + rws_expr;
            }
        }
        else if primary.is_expression_list() {
            if primary.as_expression_list().is_empty() {
                primal_expr = "()";
                fwd_expr    = "()";
                rws_expr    = "()";   // TODO: Check for reverse
            }
            else {
                primary.error("AD: Do not know how to handle non empty expression list inside of primary_expression: (primary.to_string())$");
            }
        }
        else if primary.is_literal() {
            primal_expr = primary.to_string();
            fwd_expr    = "()";
            rws_expr    = "()";  // TODO: Check for reverse
        }
        else if primary.is_declaration() {
            primary.error("AD: Do not know how to handle declaration inside of primary_expression: (primary.to_string())$");
        }
        else {
            primary.error("AD: Unknown primary expression kind: (primary.to_string())$");
        }
    }
}

/**
 * @brief Builds differentiated code for statements inside a function body.
 */
autodiff_stmt_handler: type = {
    this: simple_traverser      = ();
    this: autodiff_handler_base;

    /// Alias to base traverser type.
    base: type == simple_traverser;

    /// Function being differentiated.
    mf: meta::function_declaration;

    /// Cached statement parameters (used for loops).
    last_params: std::vector<meta::parameter_declaration> = ();
    /// Variables overwritten in this block (used for save/restore).
    overwritten: std::vector<std::string> = ();

    /// When true, emit push/pop around overwrites (used in reverse mode).
    overwrite_push_pop: bool = false;

    /**
     * @brief Initialize with context and function.
     * @param ctx_ Autodiff context.
     * @param mf_ Function being differentiated.
     * @return No return value.
     */
    operator=: (out this, ctx_: *autodiff_context, mf_: meta::function_declaration) = {
        autodiff_handler_base = (ctx_);
        mf = mf_;
    }

    /**
     * @brief Emit parameter declarations for loop/statement parameter scopes.
     * @param params Parameter declarations for the current statement scope.
     * @return Diff buffer containing parameter declarations.
     */
    handle_stmt_parameters: (inout this, params: std::vector<parameter_declaration>) -> autodiff_diff_code = {
        r : autodiff_diff_code = (ctx);
        if params.empty() {
            return r;
        }

        for params do (param) {
            name: std::string = param.get_declaration().name();
            type: std::string = param.get_declaration().type();

            fwd_pass_style := to_string_view(param.get_passing_style());

            ada: autodiff_activity_check = (ctx);
            ada.pre_traverse(param);

            init  : std::string = "";
            init_d: std::string = "";
            // TODO: Add handling for reverse expressions

            if param.get_declaration().has_initializer() {
                ad: autodiff_expression_handler = (ctx);
                ad.pre_traverse(param.get_declaration().get_initializer());
                init = " = (ad.primal_expr)$";

                if ada.active {
                    init_d = " = (ad.fwd_expr)$";
                }
            }


            r.add_forward("(fwd_pass_style)$ (name)$ : (type)$(init)$, ");
            r.add_reverse_primal("(fwd_pass_style)$ (name)$ : (type)$(init)$, ");
            if ada.active {
                r.add_forward("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$(init_d)$, ");
            }

            ctx*.add_variable_declaration(name, type, ada.active);
        }

        return r;
    }

    /**
     * @brief Dispatch declaration traversal.
     * @param decl Declaration node to traverse.
     * @return No return value.
     */
    traverse: (override inout this, decl: meta::declaration) = {
        base::traverse(decl);
    }


    /**
     * @brief Report unsupported function declarations in statement context.
     * @param f Function declaration node.
     * @return No return value.
     */
    traverse: (override inout this, f: meta::function_declaration) = {
        f.error("AD: Do not know how to handle function_declaration: (f.to_string())$");
    }


    /**
     * @brief Handle local variable declarations and initialize AD variables.
     * @param o Object declaration node.
     * @return No return value.
     */
    traverse: (override inout this, o: meta::object_declaration) = {
        lhs  : std::string = o.name();
        type :             = o.type();

        active := false;
        if "_" != type {
            active = ctx*.is_type_active(type);
        }
        else {
            assert(o.has_initializer());

            ada: autodiff_activity_check = (ctx);
            ada.pre_traverse(o.get_initializer());
            active = ada.active;
        }

        if active {

            fwd_ad_type : = ctx*.get_fwd_ad_type(type);
            rws_ad_type : = ctx*.get_rws_ad_type(type);

            prim_init: std::string = "";
            fwd_init : std::string = "";
            rws_init : std::string = "";

            if o.has_initializer() {
                ad: autodiff_expression_handler = (ctx);
                ad.pre_traverse(o.get_initializer());
                append(ad);

                prim_init = " = " + ad.primal_expr;
                fwd_init  = " = " + ad.fwd_expr;
                rws_init  = " = ()"; // TODO: Proper initialization.

                if ad.rws_expr != "()" {
                    diff.add_reverse_backprop(ad.prepare_backprop(ad.rws_expr, lhs));
                }

                if type == "_" && ad.fwd_expr == "()" {
                    // Special handling for auto initialization from a literal.
                    fwd_init = " = " + ctx*.get_fwd_ad_type("double") + "()";
                }
            }

            diff.add_forward("(lhs)$(ctx*.fwd_suffix)$ : (fwd_ad_type)$(fwd_init)$;\n");
            diff.add_forward("(lhs)$   : (type)$(prim_init)$;\n");

            diff.add_reverse_primal("(lhs)$(ctx*.rws_suffix)$ : (rws_ad_type)$(rws_init)$;\n");
            diff.add_reverse_primal("(lhs)$   : (type)$(prim_init)$;\n");
        }
        else {
            diff += "(lhs)$: (type)$";
            if o.has_initializer() {
                diff += " = (o.get_initializer().to_string())$";
            }
            diff += ";\n";
        }

        ctx*.add_variable_declaration(lhs, type, active);
    }


    /**
     * @brief Report unsupported type declarations in statement context.
     * @param t Type declaration node.
     * @return No return value.
     */
    traverse: (override inout this, t: meta::type_declaration) = {
        t.error("AD: Do not know how to handle type_declaration: (t.to_string())$");
    }


    /**
     * @brief Report unsupported parameter declarations in statement context.
     * @param t Parameter declaration node.
     * @return No return value.
     */
    traverse: (override inout this, t: meta::parameter_declaration) = {
        t.error("AD: Do not know how to handle parameter_declaration: (t.to_string())$");
    }


    /**
     * @brief Cache statement parameters and traverse sub-statements.
     * @param stmt Statement node.
     * @return No return value.
     */
    traverse: (override inout this, stmt: meta::statement) = {
        // TODO: Remove this hack when statements like compound_statement can access their root statement.
        last_params = stmt.get_parameters();
        base::traverse(stmt);
    }


    /**
     * @brief Handle compound statements with save/restore for overwritten variables.
     * @param stmt Compound statement node.
     * @return No return value.
     */
    traverse: (override inout this, stmt: meta::compound_statement) = {
        ad         : autodiff_stmt_handler = (ctx, mf);
        ad_push_pop: autodiff_stmt_handler = (ctx, mf);
        ad_push_pop.overwrite_push_pop = true;

        diff.add_forward("{\n");
        diff.add_reverse_primal("{\n");
        diff.add_reverse_backprop("}\n");

        for stmt.get_statements() do (cur) {
            ad.pre_traverse(cur);
            ad_push_pop.pre_traverse(cur);
        }

        for ad.overwritten do (cur) {
            r := ctx*.lookup_variable_declaration(cur);
            diff.add_reverse_primal("cpp2::ad_stack::push<(r.decl)$>((cur)$);");
        }

        diff.add_forward(ad.diff.fwd);
        diff.add_reverse_primal(ad.diff.rws_primal);
        diff.add_reverse_backprop(ad_push_pop.diff.rws_backprop);
        diff.add_reverse_backprop(ad_push_pop.diff.rws_primal);

        for ad.overwritten do (cur) {
            r := ctx*.lookup_variable_declaration(cur);
            diff.add_reverse_backprop("(cur)$ = cpp2::ad_stack::pop<(r.decl)$>();");
        }

        diff.add_forward("}\n");
        diff.add_reverse_primal("}\n");
        diff.add_reverse_backprop("{\n");
    }


    /**
     * @brief Handle return statements and assign into AD return storage.
     * @param stmt Return statement node.
     * @return No return value.
     */
    traverse: (override inout this, stmt: meta::return_statement) = {
        if stmt.has_expression() {
            // Return with expression.
            // TODO: Remove assumptions
            //     - Return expression is always active. (Look this up in mf or so.)
            //     - Return was converted to a two parameter return with the name r.
            ad: autodiff_expression_handler = (ctx);
            ad..pre_traverse(stmt.get_expression());
            ad.gen_assignment("r",);
            append(ad);
        }
        else {
            diff += "return;\n";
        }
    }

    /**
     * @brief Reverse the sign of `+=` and `-=` for reverse-mode loop rewrites.
     * @param expr Increment/decrement expression to reverse.
     * @return Rewritten expression string.
     */
    reverse_next: (this, expr: std::string) -> std::string = {
        if expr.contains("+=") {
            return string_util::replace_all(expr, "+=", "-=");
        }
        else if expr.contains("-=") {
            return string_util::replace_all(expr, "-=", "+=");
        }

        mf.error("AD: Do not know how to reverse: (expr)$");

        return "Error";

    }


    /**
     * @brief Handle `while`, `do`, and `for` loops, including reverse-mode rewrites.
     * @param stmt Iteration statement node.
     * @return No return value.
     */
    traverse: (override inout this, stmt: meta::iteration_statement) = {
        diff_params := handle_stmt_parameters(last_params);

        if ctx*.is_reverse() && (stmt.is_while() || stmt.is_do()) {
            stmt.error("AD: Alpha limitiation now reverse mode for while or do while.");
        }

        if stmt.is_while() {
            if !last_params.empty() {
                diff.add_forward("(" + diff_params.fwd + ")");
            }
            // TODO: Assumption is here that nothing is in the condition
            diff += "while (stmt.get_do_while_condition().to_string())$ ";
            if stmt.has_next() {
                // TODO: Assumption is here that nothing is in the next expression
                diff += "next (stmt.get_next_expression().to_string())$ ";
            }

            pre_traverse(stmt.get_do_while_body());
        }
        else if stmt.is_do() {
            if !last_params.empty() {
                diff.add_forward("(" + diff_params.fwd + ")");
            }

            // TODO: Assumption is here that nothing is in the condition
            diff += "do ";
            pre_traverse(stmt.get_do_while_body());

            if stmt.has_next() {
                // TODO: Assumption is here that nothing is in the next expression
                diff += "next (stmt.get_next_expression().to_string())$ ";
            }
            diff += "while (stmt.get_do_while_condition().to_string())$;";
        }
        else {
            assert(stmt.is_for());
            // No zip view available in cpp 20 do a piggy back for range

            // TODO: Assumption that this is just an id expression.
            range := stmt.get_for_range().to_string();

            param := stmt.get_for_parameter();
            param_style := to_string_view(param.get_passing_style());
            param_decl := param.get_declaration();

            rws        : std::string = "(";
            rws_restore: std::string = "";
            diff.add_forward("("); // Open statment parameter scope. If the loop has parameters, they are alrady handled and the brace is left open.
            diff.add_reverse_primal("{\n");
            if !last_params.empty() {
                for last_params do (cur) {
                    if cur.get_declaration().has_initializer() {
                        // TODO: Handle no type and no initializer. Handle passing style.
                        diff.add_reverse_primal("(cur.get_declaration().name())$: (cur.get_declaration().type())$ = (cur.get_declaration().get_initializer().to_string())$;\n");
                        rws_restore += "cpp2::ad_stack::push<(cur.get_declaration().type())$>((cur.get_declaration().name())$);\n";
                        rws += "(to_string_view(cur.get_passing_style()))$ (cur.get_declaration().name())$: (cur.get_declaration().type())$ = cpp2::ad_stack::pop<(cur.get_declaration().type())$>(), ";
                    }
                }
                diff.add_forward(diff_params.fwd);
            }
            diff.add_forward("copy (param_decl.name())$(ctx*.fwd_suffix)$_iter := (range)$(ctx*.fwd_suffix)$.begin())\n");
            diff.add_forward("for (range)$ next (");

            rws += "copy (param_decl.name())$(ctx*.rws_suffix)$_iter := (range)$(ctx*.rws_suffix)$.rbegin())\n";
            rws += "for std::ranges::reverse_view((range)$) next (";
            diff.add_reverse_primal("for (range)$ next (");
            if stmt.has_next() {
                // TODO: Assumption is here that nothing is in the next expression
                diff.add_forward("(stmt.get_next_expression().to_string())$, ");
                diff.add_reverse_primal("(stmt.get_next_expression().to_string())$, ");
                rws += "(reverse_next(stmt.get_next_expression().to_string()))$, ";
            }
            diff.add_forward("(param_decl.name())$(ctx*.fwd_suffix)$_iter++");
            diff.add_forward(") do ((param_style)$ (param_decl.name())$: (param_decl.type())$) {\n");
            rws += "(param_decl.name())$(ctx*.rws_suffix)$_iter++";
            rws += ") do ((param_style)$ (param_decl.name())$: (param_decl.type())$) {\n";
            rws +=  "(inout (param_decl.name())$(ctx*.rws_suffix)$ := (param_decl.name())$(ctx*.rws_suffix)$_iter*)\n";

            diff.add_reverse_primal(") do ((param_style)$ (param_decl.name())$: (param_decl.type())$)");
            diff.add_forward("((param_style)$ (param_decl.name())$(ctx*.fwd_suffix)$: (param_decl.type())$ = (param_decl.name())$(ctx*.fwd_suffix)$_iter*)");

            ctx*.add_variable_declaration("(param_decl.name())$", "(param_decl.type())$", true); // TODO: Handle loop/compound context variable declarations.
            diff.add_reverse_backprop("}\n");

            pre_traverse(stmt.get_for_body());
            diff.add_forward("}\n");

            if stmt.has_next() {
                diff.add_reverse_primal("(reverse_next(stmt.get_next_expression().to_string()))$;\n");
            }
            diff.add_reverse_primal(rws_restore);
            diff.add_reverse_primal("}\n");
            diff.add_reverse_backprop(rws);
        }
    }


    /**
     * @brief Handle `if`/`else` statements (condition assumed passive).
     * @param stmt Selection statement node.
     * @return No return value.
     */
    traverse: (override inout this, stmt: meta::selection_statement) = {
        // TODO: Currently assuming that nothing bad happens in the condition
        diff += "if (stmt.get_expression().to_string())$";
        pre_traverse(stmt.get_true_branch());

        if stmt.has_false_branch() {
            diff += "else ";
            pre_traverse(stmt.get_false_branch());
        }
    }

    /**
     * @brief Dispatch expression traversal.
     * @param expr Expression node to traverse.
     * @return No return value.
     */
    traverse : (override inout this, expr: meta::expression) = {
        base::traverse(expr);
    }

    /**
     * @brief Handle assignments, including reverse-mode overwrite tracking.
     * @param binexpr Assignment expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::assignment_expression) = {
        ada: autodiff_activity_check = (ctx);
        ada.pre_traverse(binexpr.get_lhs_postfix_expression());
        if "_" == binexpr.get_lhs_postfix_expression().to_string() {
            ada.pre_traverse(binexpr.get_terms()[1].get_term());
        }

        if ada.active {
            h_lhs: autodiff_expression_handler = (ctx);
            h_lhs.pre_traverse(binexpr.get_lhs_postfix_expression());

            //  Cpp2 doesn't allow chained assignment, so rhs must be a single logical_or_expression
            assignment_terms := binexpr.get_terms();

            h: autodiff_expression_handler = (ctx);
            h.pre_traverse(assignment_terms[1].get_term());

            is_overwrite := h.primal_expr.contains(h_lhs.primal_expr);
            if overwrite_push_pop && is_overwrite {
                r := ctx*.lookup_variable_declaration(h_lhs.primal_expr);
                diff.add_reverse_primal("cpp2::ad_stack::push<(r.decl)$>((h_lhs.primal_expr)$);");
            }

            if is_overwrite && ctx*.is_reverse() {
                t_b := ctx*.gen_temporary() + ctx*.rws_suffix;
                h.gen_assignment(h_lhs.primal_expr, h_lhs.fwd_expr, t_b);
                append(h);
                diff.add_reverse_backprop("(h_lhs.rws_expr)$ = 0.0;\n");
                diff.add_reverse_backprop("(t_b)$ := (h_lhs.rws_expr)$;\n");
            }
            else {
                h.gen_assignment(h_lhs.primal_expr, h_lhs.fwd_expr, h_lhs.rws_expr);
                append(h);
            }

            if overwrite_push_pop && is_overwrite {
                r := ctx*.lookup_variable_declaration(h_lhs.primal_expr);
                diff.add_reverse_backprop("(h_lhs.primal_expr)$ = cpp2::ad_stack::pop<(r.decl)$>();");
            }

            // Simple overwrite check
            if is_overwrite {
                overwritten.push_back(h_lhs.primal_expr);
            }
        }
        else {
            diff.add_forward(binexpr.to_string() + ";\n");
            diff.add_reverse_primal(binexpr.to_string() + ";\n");
        }
    }

    /**
     * @brief Report unsupported logical-or as a standalone statement.
     * @param binexpr Logical-or expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::logical_or_expression) = {
        binexpr.error( "AD: Logical or expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported logical-and as a standalone statement.
     * @param binexpr Logical-and expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::logical_and_expression) = {
        binexpr.error( "AD: Logical and expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported bitwise-or as a standalone statement.
     * @param binexpr Bitwise-or expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::bit_or_expression) = {
        binexpr.error( "AD: Bit or expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported bitwise-xor as a standalone statement.
     * @param binexpr Bitwise-xor expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::bit_xor_expression) = {
        binexpr.error( "AD: Bit xor expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported bitwise-and as a standalone statement.
     * @param binexpr Bitwise-and expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::bit_and_expression) = {
        binexpr.error( "AD: Bit and expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported equality as a standalone statement.
     * @param binexpr Equality expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::equality_expression) = {
        binexpr.error( "AD: Equality or expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported relational expressions as a standalone statement.
     * @param binexpr Relational expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::relational_expression) = {
        binexpr.error( "AD: Relational expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported compare expressions as a standalone statement.
     * @param binexpr Compare expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::compare_expression) = {
        binexpr.error( "AD: Compare or expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported shift expressions as a standalone statement.
     * @param binexpr Shift expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::shift_expression) = {
        binexpr.error( "AD: Shift or expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported additive expressions as standalone statements.
     * @param binexpr Additive expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::additive_expression) = {
        binexpr.error( "AD: Additive expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported multiplicative expressions as standalone statements.
     * @param binexpr Multiplicative expression node.
     * @return No return value.
     */
    traverse: (override inout this, binexpr: meta::multiplicative_expression) = {
        binexpr.error( "AD: Multiplicative expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported is/as expressions as standalone statements.
     * @param isas is/as expression node.
     * @return No return value.
     */
    traverse: (override inout this, isas: meta::is_as_expression) = {
        isas.error( "AD: Is as expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Report unsupported prefix expressions as standalone statements.
     * @param prefix Prefix expression node.
     * @return No return value.
     */
    traverse: (override inout this, prefix: meta::prefix_expression) =
    {
        prefix.error( "AD: Prefix expressions are not yet handled as standalone statements." );
    }

    /**
     * @brief Handle postfix expressions only for function calls.
     * @param postfix Postfix expression node.
     * @return No return value.
     */
    traverse: (override inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        is_func  := false;

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                continue;
            }
            if term.get_op() == "(" && i + 1 == terms.ssize() { // Function operator has to be the last
                is_func = true;
                continue;
            } else {
                postfix.error("AD: Unknown operator for standalone postfix expression. op: (term.get_op())$ expr: (postfix)$");
            }
        }

        // Check for function call, everything else is not handled.
        if !(is_func) {
            postfix.error( "AD: Postfix expressions are only handled for function calls, or member function calls. Do not know how to handle: (postfix.to_string())$" );
            return;
        }

        ad: autodiff_expression_handler = (ctx);
        ad.handle_function_call(postfix, false);
        ad.diff += ad.fwd_expr + "\n";
        ad.diff += ad.primal_expr + "\n";
        append(ad);
    }

    /**
     * @brief Report unsupported primary expressions as standalone statements.
     * @param primary Primary expression node.
     * @return No return value.
     */
    traverse: (override inout this, primary: meta::primary_expression) =
    {
        primary.error( "AD: Primary expressions are not yet handled as standalone statements." );
    }
}

/**
 * @brief Traverses declarations and emits differentiated types and functions.
 */
autodiff_declaration_handler: type = {
    this: simple_traverser      = ();
    this: autodiff_handler_base;

    /// Alias to base traverser type.
    base: type == simple_traverser;

    /// Current declaration context.
    decl: meta::type_or_namespace_declaration;

    /// True when generating members of a derived AD type.
    is_type_context: bool        = false;
    /// Accumulated members for an AD type definition.
    diff_ad_type   : std::string = "";

    /**
     * @brief Initialize with context and declaration.
     * @param ctx_ Autodiff context.
     * @param decl_ Declaration context to operate on.
     * @return No return value.
     */
    operator=: (out this, ctx_: *autodiff_context, decl_: meta::type_or_namespace_declaration) = {
        autodiff_handler_base = (ctx_);
        decl = decl_;
    }

    /**
     * @brief Dispatch declaration traversal.
     * @param decl_ Declaration node to traverse.
     * @return No return value.
     */
    traverse: (override inout this, decl_: meta::declaration) = {
        base::traverse(decl_);
    }


    /**
     * @brief Generate forward and/or reverse differentiated function members.
     * @param f Function declaration node.
     * @return No return value.
     */
    traverse: (override inout this, f: meta::function_declaration) = {
        ctx*.enter_function();

        // TODO: Add activity for member functions

        diff.add_forward("    (f.name())$(ctx*.fwd_suffix)$: (");
        diff.add_reverse_primal("    (f.name())$(ctx*.rws_suffix)$: (");

        //  1. Generate the modified signature
        //  a) Parameters

        for f.get_parameters() do (param) {
            name: std::string = param.get_declaration().name();

            fwd_pass_style := to_string_view(param.get_passing_style());
            rws_pass_style := to_string_view(ctx*.get_reverse_passing_style(param.get_passing_style()));

            if "this" ==  name {
                fwd_ad_type := ctx*.get_fwd_ad_type(std::string(decl.name()));
                rws_ad_type := ctx*.get_rws_ad_type(std::string(decl.name()));

                diff.add_forward("(fwd_pass_style)$ (name)$, ");
                diff.add_forward("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$: (fwd_ad_type)$, ");

                diff.add_reverse_primal("(fwd_pass_style)$ (name)$, ");
                if ctx*.is_taylor() { // Add forward type for higher order
                    diff.add_reverse_primal("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$: (fwd_ad_type)$, ");
                }
                diff.add_reverse_primal("(rws_pass_style)$ (name)$(ctx*.rws_suffix)$: (rws_ad_type)$, ");
            }
            else {
                type := param.get_declaration().type();

                ada: autodiff_activity_check = (ctx);
                ada.pre_traverse(param);

                if ada.active {
                    diff.add_forward("(fwd_pass_style)$ (name)$ : (type)$, ");
                    diff.add_forward("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$, ");

                    diff.add_reverse_primal("(fwd_pass_style)$ (name)$ : (type)$, ");
                    if ctx*.is_taylor() {
                        diff.add_reverse_primal("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$, ");
                    }
                    diff.add_reverse_primal("(rws_pass_style)$ (name)$(ctx*.rws_suffix)$ : (ctx*.get_rws_ad_type(type))$, ");
                }
                else {
                    diff.add_forward("(fwd_pass_style)$ (name)$ : (type)$, ");
                    diff.add_reverse_primal("(fwd_pass_style)$ (name)$ : (type)$, ");
                }

                ctx*.add_variable_declaration(name, type, ada.active);
            }
        }

        //  b) Add arguments for returns that become inputs

        if f.has_non_void_return_type() && f.get_returns().empty() { // TODO: has_non_void_return_type is true for return lists: (r: double) bug/feature?
            // TODO: check if name "r" is available. (Also needs inspection of functions at call sides.)
            if f.has_deduced_return_type() {
                // TODO: Take care of initialization order error.
                diff.add_reverse_primal("inout r(ctx*.rws_suffix)$, ");
            }
            else {
                diff.add_reverse_primal("inout r(ctx*.rws_suffix)$: (ctx*.get_rws_ad_type(f.get_unnamed_return_type()))$, ");
            }
        }
        else {
            for f.get_returns() do (param) {
                name := param.get_declaration().name();
                type := param.get_declaration().type();

                rws_pass_style := to_string_view(ctx*.get_reverse_passing_style(param.get_passing_style()));
                diff.add_reverse_primal("(rws_pass_style)$ (name)$(ctx*.rws_suffix)$ : (ctx*.get_rws_ad_type(type))$ , ");
            }
        }

        diff.add_forward(") -> (");
        diff.add_reverse_primal(") -> (");

        //  c) Returns

        if f.has_non_void_return_type() && f.get_returns().empty() { // TODO: has_non_void_return_type is true for return lists: (r: double) bug/feature?
            // TODO: check if name "r" is available. (Also needs inspection of functions at call sides.)
            if f.has_deduced_return_type() {
                // TODO: Take care of initialization order error.
                diff.add_forward("r, r(ctx*.fwd_suffix)$, ");
                diff.add_reverse_primal("r, ");
                if ctx*.is_taylor() {
                    diff.add_reverse_primal("r(ctx*.fwd_suffix)$,");
                }
            }
            else {
                diff.add_forward("r: (f.get_unnamed_return_type())$ = (), r(ctx*.fwd_suffix)$: (ctx*.get_fwd_ad_type(f.get_unnamed_return_type()))$ = (), ");
                diff.add_reverse_primal("r: (f.get_unnamed_return_type())$ = (), ");
                if ctx*.is_taylor() {
                    diff.add_reverse_primal("r(ctx*.fwd_suffix)$: (ctx*.get_fwd_ad_type(f.get_unnamed_return_type()))$ = (), ");
                }
            }
        }
        else {
            for f.get_returns() do (param) {
                name := param.get_declaration().name();
                type := param.get_declaration().type();

                fwd_pass_style := to_string_view(param.get_passing_style());
                //rws_pass_style := to_string_view(ctx*.get_reverse_passing_style(param.get_passing_style()));
                diff.add_forward("(fwd_pass_style)$ (name)$ : (param.get_declaration().type())$ = 0.0, ");
                diff.add_forward("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$ = 0.0, ");

                diff.add_reverse_primal("(fwd_pass_style)$ (name)$ : (param.get_declaration().type())$ = 0.0, ");
                if ctx*.is_taylor() {
                    diff.add_reverse_primal("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$ = 0.0, ");
                }

                ctx*.add_variable_declaration("(name)$", "(type)$", true); // TODO_a: Add acitivty check
            }
        }

        diff.add_forward(") = {");
        diff.add_reverse_primal(") = {");

        //  Generate the body

        if !f.has_compound_body() {
            f.error( "temporary alpha limitation: a differentiable function must have a {}-enclosed body" );
            return;
        }


        ad_impl : autodiff_stmt_handler = (ctx*&, f);


        for f.get_compound_body().get_statements() do (stmt)
        {
            ad_impl..pre_traverse(stmt);
        }
        diff.add_forward(ad_impl.diff.fwd);
        diff.add_reverse_primal(ad_impl.diff.rws_primal);
        diff.add_reverse_primal(ad_impl.diff.rws_backprop);

        diff.add_forward("}");
        diff.add_reverse_primal("}");

        ctx*.leave_function();

        if ctx*.is_forward() {
            decl.add_member( diff.fwd );
        }
        if ctx*.is_reverse() {
            decl.add_member( diff.rws_primal );
        }
        diff.reset();

        ctx*.add_as_differentiated(f);
    }


    /**
     * @brief Generate AD member fields for object declarations.
     * @param o Object declaration node.
     * @return No return value.
     */
    traverse: (override inout this, o: meta::object_declaration) = {
        ad_name : std::string = "(o.name())$(ctx*.fwd_suffix)$";
        fwd_ad_type : std::string = ctx*.get_fwd_ad_type(o.type());
        ad_init : std::string = "";

        if o.has_initializer() {
            ad: autodiff_expression_handler = (ctx);
            ad.pre_traverse(o.get_initializer());

            assert(ad.diff.empty());
            ad_init = " = " +ad.fwd_expr;
        }

        diff = "(ad_name)$ : (fwd_ad_type)$(ad_init)$;";

        if is_type_context {

            diff_ad_type += "public (diff.fwd)$\n";
        }
        else {
            decl.add_member(diff.fwd);
        }
        diff = "";

        ctx*.add_variable_declaration("(o.name())$", "(o.type())$", true, true); // TODO_a: Add acitivty check
    }


    /**
     * @brief Generate AD type wrappers for nested types.
     * @param t Type declaration node.
     * @return No return value.
     */
    traverse: (override inout this, t: meta::type_declaration) = {
        ctx*.push_stack(t);
        ad: autodiff_declaration_handler = (ctx, t);
        ad.is_type_context = true;

        for t.get_members()
        do  (m)
        {
            ad.pre_traverse(m);
        }

        ctx*.pop_stack();

        if !ad.diff_ad_type.empty() {
            diff = "(t.name())$(ctx*.fwd_suffix)$ : type = {\n";
            diff += "(ad.diff_ad_type)$";
            diff += "}";

            decl.add_member(diff.fwd);
            diff = "";
        }
    }


    /**
     * @brief Report unsupported parameter declarations in declaration context.
     * @param t Parameter declaration node.
     * @return No return value.
     */
    traverse: (override inout this, t: meta::parameter_declaration) = {
        t.error("AD: Do not know how to handle parameter_declaration: (t.to_string())$");
    }


    /**
     * @brief Report unsupported statements in declaration context.
     * @param stmt Statement node.
     * @return No return value.
     */
    traverse: (override inout this, stmt: meta::statement) = {
        stmt.error("AD: Do not know how to handle statement in declaration context: (stmt.to_string())$");
    }
}


/**
 * @brief Entry point for `@autodiff` metafunction - Automatic Differentiation for Cpp2.
 *
 * 
 *                         REVERSE-MODE AUTOMATIC DIFFERENTIATION
 * 
 *
 * This metafunction transforms a Cpp2 type to support automatic differentiation.
 * For reverse mode (`@autodiff<"reverse">`), it generates backward (adjoint) functions
 * that compute gradients via the chain rule.
 *
 * 
 *                               PIPELINE OVERVIEW                              
 * 
 *
 *   User Code (Cpp2)                      Generated Code (Cpp1)
 *                          
 *
 *   @autodiff<"reverse">                  // Original function
 *   my_math: type = {                     f: (x: double) -> double = { ... }
 *       f: (x: double) -> double = {
 *           return sin(x) * x;            // Generated backward function
 *       }                              f_backward: (x_val: double, r_adj: double,
 *   }                                                  inout x_adj: double) = {
 *                                             // Adjoint accumulation via chain rule
 *                                             x_adj += cos(x_val) * x_val * r_adj;
 *                                             x_adj += sin(x_val) * r_adj;
 *                                         }
 *
 * 
 *                            DETAILED PIPELINE STAGES                          
 * 
 *
 *               
 *     1. PARSE          2. RULE           3. IR             4. ACTIVITY 
 *     ARGUMENTS     DISCOVERY     BUILDING      ANALYSIS    
 *               
 *                                                                   
 *                                                                   
 *   Parse metafunction   Scan nested         Walk reflection     Mark variables
 *   args: suffix,        ad_rule_* types     AST, build typed    as active if
 *   order, reverse       into registry       IR expressions      they depend on
 *                                            and statements      inputs
 *
 *               
 *     5. FORWARD        6. REVERSE        7. CODE           8. CODE     
 *     PASS GEN      PASS GEN      EMISSION      INJECTION   
 *               
 *                                                                   
 *                                                                   
 *   Generate IR for      Apply chain rule    Convert IR to       Add generated
 *   value computation    to generate         Cpp1 code           functions to
 *   (x_val = x, etc.)    adjoint stmts       strings             the type
 *
 * 
 *                          DIFFERENTIATION RULES (ad_rule_*)                   
 * 
 *
 * Rules define how to differentiate specific functions. Each rule is a type with:
 *
 *   ad_rule_<function_name>: type = {
 *       name      : std::string = "<function_name>";   // Function to match
 *       n_args    : int = <N>;                         // Number of arguments
 *       is_member : bool = false;                      // Member function?
 *
 *       // Forward pass: compute the primal value (optional, for documentation)
 *       forward: (<args>) -> <return_type> = { ... }
 *
 *       // Reverse pass: accumulate adjoints using chain rule (REQUIRED)
 *       reverse: (res_val: T, res_adj: T,              // Result value & adjoint
 *                 x_val: T, inout x_adj: T,            // Arg 1 value & adjoint
 *                 [y_val: T, inout y_adj: T, ...]) = { // Additional args...
 *           // Accumulate: arg_adj += d(f)/d(arg) * res_adj
 *           x_adj += <partial_derivative_wrt_x> * res_adj;
 *       }
 *   }
 *
 * Rule Discovery Priority:
 *   1. Nested types inside the @autodiff type (highest priority)
 *   2. Types in std::reverse_ad namespace (from cpp2ad_rules.h2)
 *
 * Example - Custom Rule for GELU:
 *
 *   my_nn: @autodiff<"reverse"> type = {
 *       ad_rule_gelu: type = {
 *           name: std::string = "gelu";
 *           n_args: int = 1;
 *           is_member: bool = false;
 *
 *           reverse: (res_val: double, res_adj: double,
 *                     x_val: double, inout x_adj: double) = {
 *               // GELU: 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))
 *               // Derivative approximation
 *               cdf := 0.5 * (1.0 + std::tanh(0.797885 * (x_val + 0.044715 * x_val * x_val * x_val)));
 *               x_adj += cdf * res_adj;  // Simplified
 *           }
 *       }
 *
 *       f: (x: double) -> double = { return gelu(x); }
 *   }
 *
 * 
 *                               IR TYPE HIERARCHY                              
 * 
 *
 *   ad_func_ir                           Top-level function IR
 *       
 *        name: string                 Function name
 *        params: vector<ad_param>     Parameter list (with value/adjoint names)
 *        return_type: string          Return type
 *        body_stmts: vector<ad_stmt>  Forward pass statements
 *        reverse_stmts: vector<ad_stmt>  Reverse pass statements
 *
 *   ad_stmt (Statement IR)               Represents a single statement
 *       
 *        ad_stmt_kind::decl           Variable declaration: "x_val: double = expr"
 *        ad_stmt_kind::assign         Assignment: "x_val = expr"
 *        ad_stmt_kind::assign_add     Adjoint accumulation: "x_adj += expr"
 *        ad_stmt_kind::expr           Expression statement
 *        ad_stmt_kind::return_        Return statement
 *        ad_stmt_kind::compound       Block of statements { ... }
 *        ad_stmt_kind::if_stmt        Conditional statement
 *
 *   ad_expr (Expression IR)              Represents an expression
 *       
 *        ad_expr_kind::literal        Numeric literal: "3.14"
 *        ad_expr_kind::identifier     Variable reference: "x_val"
 *        ad_expr_kind::unary          Unary operation: "-x"
 *        ad_expr_kind::binary         Binary operation: "x + y"
 *        ad_expr_kind::call           Function call: "sin(x)"
 *
 *   ad_op_kind                           Operation types
 *       
 *        add, sub, mul, div           Arithmetic operators
 *        neg                          Unary negation
 *        call                         Function call (rule lookup by name)
 *
 * 
 *                            CHAIN RULE APPLICATION                            
 * 
 *
 * The reverse pass applies the chain rule to propagate adjoints backward:
 *
 *   Forward:  y = f(x)           Compute value
 *   Reverse:  x_adj += dy/dx * y_adj    Accumulate adjoint
 *
 * For composite expressions, the chain rule composes:
 *
 *   Forward:  t1 = sin(x)        Forward pass stores intermediate values
 *             t2 = x * t1
 *             r  = t2
 *
 *   Reverse:  t2_adj = r_adj     Seed with output adjoint (typically 1.0)
 *             x_adj  += t1 * t2_adj     d(x*t1)/dx = t1
 *             t1_adj += x * t2_adj      d(x*t1)/dt1 = x
 *             x_adj  += cos(x) * t1_adj d(sin(x))/dx = cos(x)
 *
 * The reverse statements are executed in reverse order of the forward statements.
 *
 * 
 *                               ERROR HANDLING                                 
 * 
 *
 * The pipeline uses HARD FAILURES - no guessing or fallback recovery:
 *
 *   - If no rule exists for a function  Compilation error with message:
 *     "@autodiff: No rule found for function 'foo'. Define ad_rule_foo with reverse()."
 *
 *   - If an expression can't be parsed  Compilation error with context
 *
 *   - If a rule exists but has no reverse() body  Compilation error
 *
 * This ensures generated code is always correct - no silent wrong gradients.
 *
 * 
 *                            NAMING CONVENTIONS                                
 * 
 *
 *   Original variable: x
 *   Value storage:     x_val    (stores primal value for reverse pass)
 *   Adjoint storage:   x_adj    (accumulates gradient contribution)
 *
 *   Original function: f
 *   Backward function: f_backward
 *
 *   Suffixes are configurable via metafunction arguments.
 *
 * 
 *                              METAFUNCTION ARGUMENTS
 * 
 *
 * @param t Type declaration to differentiate (modified in place).
 *
 * Arguments (passed as strings in angle brackets):
 *   - "reverse"           Enable reverse-mode AD (required for backward functions)
 *   - "suffix=<str>"      Override forward suffix (default: "_d")
 *   - "rws_suffix=<str>"  Override reverse suffix (default: "_b")
 *   - "order=<n>"         Set Taylor order (default: 1, for higher-order AD)
 *
 * Example usage:
 *   @autodiff<"reverse"> my_type: type = { ... }
 *   @autodiff<"reverse", "suffix=_fwd", "rws_suffix=_bwd"> my_type: type = { ... }
 *
 * @see ad_rule_registry      Rule storage and lookup
 * @see ad_ir_builder         IR construction from AST
 * @see ad_ir_emitter         Code generation from IR
 * @see discover_ad_rules     Rule discovery logic
 * @see std::reverse_ad       Standard library of differentiation rules
 */
autodiff: (inout t: meta::type_declaration) =
{

    suffix_token      : std::string_view == "suffix=";
    rws_suffix_token  : std::string_view == "rws_suffix=";
    order_token       : std::string_view == "order=";
    reverse_token     : std::string_view == "reverse";

    args := t.get_arguments();

    suffix    : std::string = "_d";
    rws_suffix: std::string = "_b";
    order     : int         = 1;
    reverse   : bool        = false;
    for args do (arg_str) {
        if arg_str.starts_with("\"") && arg_str.ends_with("\"") {
            arg := arg_str.substr(1, arg_str.ssize() - 2);

            if arg.starts_with(suffix_token) {
                suffix = arg.substr(suffix_token.size());
                continue;
            }
            else if arg.starts_with(rws_suffix_token) {
                suffix = arg.substr(rws_suffix_token.size());
                continue;
            }
            else if arg.starts_with(order_token) {
                if !string_util::string_to_int(arg.substr(order_token.size()), order) {
                    t.error("AD: Could not parse derivative order: (arg.substr(order_token.size()))$");
                    return;
                }
                continue;
            }
            else if arg == reverse_token {
                reverse = true;
                continue;
            }
        }

        t.error("AD: Unknown argument: (arg_str)$");
        return;
    }

    if reverse {
        std::cout << "AD: Warning - reverse mode differentiation is very experimental\n";
    }

    ad_ctx: autodiff_context = (order, reverse);
    ad_ctx.fwd_suffix = suffix;
    ad_ctx.rws_suffix = rws_suffix;

    if reverse {
        autodiff_reverse_ir(t, ad_ctx&);
    }

    // Skip old string-based code generation for types starting with "test_"
    // This allows IR-only debugging during development
    type_name := t.name() as std::string;
    if type_name.starts_with("test_") {
        std::cout << "AD: Skipping old code generation for test type '" << type_name << "'\n";
        return;
    }

    if t.parent_is_nonglobal_namespace() {
        p := t.get_parent().as_nonglobal_namespace();
        ad_ctx.create_namespace_stack(p);
        ad: autodiff_declaration_handler = (ad_ctx&, p);
        ad.pre_traverse(t);

    }
    else if t.parent_is_type() {
        p := t.get_parent().as_type();
        ad_ctx.create_namespace_stack(p);
        ad: autodiff_declaration_handler = (ad_ctx&, p);
        ad.pre_traverse(t);
    }
    else {
        // TODO: Remove when global namespace is available.
        // Traverse without parent context
        ad_ctx.push_stack(t);
        ad: autodiff_declaration_handler = (ad_ctx&, t);

        for t.get_members()
        do  (m)
        if  m.is_function()
        {
            ad.pre_traverse(m);
        }
        ad_ctx.pop_stack();
    }

    if 1 != order {
        t.add_runtime_support_include( "cpp2taylor.h" );
    }
    if reverse {
        t.add_runtime_support_include( "cpp2ad_stack.h" );
    }

    ad_ctx.finish();

    _ = ad_ctx;
}


//-----------------------------------------------------------------------
//
//  regex - creates regular expressions from members
//
//  Each member that starts with `regex` is replaced by a regular expression
//  of the initializer string. E.g.:
//  ```
//    regex := "ab";
//  ```
//  is replaced with
//  ```
//    regex := ::cpp2::regex::regular_expression<...>;
//  ```
//
error_func: type == std::function< (x: std::string) -> void >;

//  Possible modifiers for a regular expression.
//
expression_flags: @flag_enum<u8> type =
{
    case_insensitive;             // mod: i
    multiple_lines;               // mod: m
    single_line;                  // mod: s
    no_group_captures;            // mod: n
    perl_code_syntax;             // mod: x
    perl_code_syntax_in_classes;  // mod: xx
}


//  Tokens for regular expressions.
//

// Basic class for a regex token.
//
regex_token: @polymorphic_base type =
{
    public string_rep: std::string;

    operator=:(out this, str: std::string) = {
        string_rep = str;
    }

    operator=:(out this) = {
        string_rep = "";
    }

    //parse: (inout ctx: parse_context) -> token_ptr;
    generate_code: (virtual this, inout _: generation_context);        // Generate the matching code.
    reverse:       (virtual this) -> std::shared_ptr<regex_token>;     // Create a reverse token for look behind expressions.

    add_groups: (virtual this, inout _: std::set<int>) = {}            // Adds all group indices to the set.
    to_string: (this) -> std::string         = { return string_rep; }  // Create a string representation.
    set_string: (inout this, s: std::string) = { string_rep = s; }     // Set the string representation.
}

token_ptr : type == std::shared_ptr<regex_token>;
token_vec: type == std::vector<token_ptr>;


//  Adds a check in code generation.
//
regex_token_check: @polymorphic_base type =
{
    this: regex_token;

    check: std::string;

    operator=:(out this, str: std::string, check_: std::string) = {
        regex_token = (str);
        check = check_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add_check(check + "(" + ctx..match_parameters() + ")");
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_check>(this.to_string(), this.check);
}


//  Adds code in code generation.
//
regex_token_code: @polymorphic_base type =
{
    this: regex_token;

    code: std::string;

    operator=:(out this, str: std::string, code_: std::string) = {
        regex_token = (str);
        code = code_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add(code);
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_code>(this.to_string(), this.code);
}


//  Token that does not influence the matching. E.g. comment.
//
regex_token_empty: @polymorphic_base type =
{
    this: regex_token;

    operator=:(out this, str: std::string) = {
        regex_token = (str);
    }

    generate_code: (override this, inout _: generation_context) = {
        // Nothing.
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_empty>(this.to_string());
}


//  Represents a list of regex tokens as one token.
//
regex_token_list: @polymorphic_base type =
{
    this: regex_token;

    public tokens: token_vec;

    operator=:(out this, t: token_vec) = {
        regex_token = (gen_string(t));
        tokens = t;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        for tokens do (token) {
            token*..generate_code(ctx);
        }
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        for tokens do (token) {
            token*..add_groups(groups);
        }
    }

    gen_string: (vec: token_vec) -> std::string = {
        r : std::string = "";
        for vec do (token) {
            r += token*..to_string();
        }
        return r;
    }

    reverse: (override this) -> token_ptr = {
        s : int = cpp2::unchecked_narrow<int>(tokens..size());

        reverse_vec: token_vec = ();
        reverse_vec..resize(s);

        i: int = 0;
        while i < tokens.ssize() next (i += 1) {
            reverse_vec[s - 1 -i] = tokens[i]*.reverse();
        }
        return shared.new<regex_token_list>(reverse_vec);
    }
}


//
//  Parse and generation context.
//

//  State of the current capturing group. See '(<pattern>)'
//
parse_context_group_state: @struct<noforward> type =
{
    cur_match_list:        token_vec = ();         // Current list of matchers.
    alternate_match_lists: token_vec = ();         // List of alternate matcher lists. E.g. ab|cd|xy.
    modifiers :            expression_flags = ();  // Current modifiers for the group/regular expression.

    //  Start a new alternative.
    next_alternative: (inout this) = {
        new_list: token_vec = ();
        std::swap(new_list, cur_match_list);
        post_process_list(new_list);
        _ = alternate_match_lists..insert(alternate_match_lists..end(), shared.new<regex_token_list>(new_list));
    }

    //  Swap this state with the other one. NOLINTNEXTLINE(performance-noexcept-swap)
    swap: (inout this, inout t: parse_context_group_state) = { // NOLINT(performance-noexcept-swap)
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
        std::swap(modifiers, t.modifiers);
    }

    //  Convert this state into a regex token.
    get_as_token: (inout this) -> token_ptr = {
        if alternate_match_lists..empty() {
            post_process_list(cur_match_list);
            return shared.new<regex_token_list>(cur_match_list);
        }
        else {
            next_alternative();
            return shared.new<alternative_token_gen>(alternate_match_lists);
        }
    }

    //  Add a token to the current matcher list.
    add: (inout this, token: token_ptr) = {
        cur_match_list..push_back(token);
    }

    //  True if current matcher list is empty.
    empty: (this) -> bool = cur_match_list..empty();


    //  Apply optimizations to the matcher list.
    post_process_list: (inout list: token_vec) = {
        // Merge all characters
        merge_pos := list..begin();
        while merge_pos != list..end() next (merge_pos++) {
            if merge_pos** is char_token {
                combine_pos := merge_pos + 1;
                while combine_pos != list..end() && combine_pos** is char_token { // The erase advances combine_pos
                    (merge_pos** as char_token)..append(combine_pos** as char_token);
                    combine_pos = list..erase(combine_pos);
                }
            }
        }
    }
}


//  State for the branch reset. Takes care of the group numbering. See '(|<pattern>)'.
//
parse_context_branch_reset_state: @struct<noforward> type =
{
    is_active : bool = false; // If we have a branch reset group.
    cur_group : int  = 1;     // Next group identifier. 0 == global capture group.
    max_group : int  = 1;     // Maximum group identifier generated.
    from      : int  = 1;     // Starting identifier on new alternative branch.

    //  Next group identifier.
    next: (inout this) -> int = {
        g := cur_group;
        cur_group += 1;
        max_group = max(max_group, cur_group);

        return g;
    }

    //  Set next group identifier.
    set_next: (inout this, g: int) = {
        cur_group = g;
        max_group = max(max_group, g);
    }

    //  Start a new alternative branch.
    next_alternative: (inout this) = {
        if is_active {
            cur_group = from;
        }
    }

    //  Initialize for a branch reset group.
    set_active_reset: (inout this, restart: int) = {
        is_active = true;
        cur_group = restart;
        from      = restart;
        max_group = restart;
    }
}


//  Context during parsing of the regular expressions.
//
//  Keeps track of the distributed group identifiers, current parsed group and branch resets.
//
parse_context: type =
{
    regex: std::string_view;   // Regular expression string.
    pos:   size_t = 0;         // Current parsing position.
    root:  token_ptr;          // Token representing the regular expression.

    public is_start_match: bool = false;  // If the regex contains \G at the beginning.

    cur_group_state:        parse_context_group_state = ();
    cur_branch_reset_state: parse_context_branch_reset_state = ();


    public named_groups:  std::map<std::string, int> = ();

    error_out: error_func; // TODO: Declaring std::function<void(std::string)> fails for cpp2.
    has_error: bool      = false;

    operator=:(out this, r: std::string_view, e) = {
        regex = r;
        root = shared.new<regex_token_empty>("");
        error_out = e;
    }

    //  State management functions
    //

    //  Returned group state needs to be stored and provided in `end_group`.
    start_group: (inout this) -> parse_context_group_state =
    {
        old_state: parse_context_group_state = ();
        old_state..swap(cur_group_state);
        cur_group_state.modifiers = old_state.modifiers;

        return old_state;
    }

    //  `old_state` argument needs to be from start group.
    end_group: (inout this, old_state: parse_context_group_state) -> token_ptr =
    {
        inner := cur_group_state..get_as_token();
        cur_group_state = old_state;
        return inner;
    }

    get_modifiers: (this) -> expression_flags = {
        return cur_group_state.modifiers;
    }

    set_modifiers: (inout this, mod: expression_flags) = {
        cur_group_state.modifiers = mod;
    }

    //  Branch reset management functions
    //

    branch_reset_new_state: (inout this) -> parse_context_branch_reset_state =
    {
        old_state: parse_context_branch_reset_state = ();
        std::swap(old_state, cur_branch_reset_state);

        cur_branch_reset_state..set_active_reset(old_state.cur_group);
        return old_state;
    }

    branch_reset_restore_state: (inout this, old_state: parse_context_branch_reset_state) =
    {
        max_group := cur_branch_reset_state.max_group;
        cur_branch_reset_state = old_state;
        cur_branch_reset_state..set_next(max_group);
    }

    next_alternative: (inout this) =
    {
        cur_group_state..next_alternative();
        cur_branch_reset_state..next_alternative();
    }

    //  Regex token management
    //
    add_token: (inout this, token: token_ptr) = {
        cur_group_state..add(token);
    }

    has_token: (this) -> bool = {
        return !cur_group_state..empty();
    }

    pop_token: (inout this) -> token_ptr =
    {
        r : token_ptr = nullptr;
        if has_token() {
            r = cur_group_state.cur_match_list..back();
            cur_group_state.cur_match_list..pop_back();
        }

        return r;
    }

    get_as_token: (inout this) -> token_ptr = {
        return root;
    }

    //  Group management
    //
    get_cur_group: (this) -> int = {
        return cur_branch_reset_state.cur_group;
    }

    next_group: (inout this) -> int = {
        return cur_branch_reset_state..next();
    }

    set_named_group: (inout this, name: std::string, id: int) =
    {
        if !named_groups..contains(name) { // Redefinition of group name is not an error. The left most one is retained.
            named_groups[name] = id;
        }
    }

    get_named_group: (this, name: std::string) -> int =
    {
        iter := named_groups..find(name);
        if iter == named_groups..end() {
             return -1;
        }
        else {
            return iter*.second;
        }
    }

    //  Position management functions
    //
    current: (this) -> char = { return regex[pos]; }

    //  Get the next token in the regex, skipping spaces according to the parameters. See `x` and `xx` modifiers.
    private get_next_position: (in this, in_class: bool, no_skip: bool) -> size_t =
    {
        perl_syntax := false;
        if !no_skip {
            if in_class {
                perl_syntax = get_modifiers()..has(expression_flags::perl_code_syntax) && get_modifiers()..has(expression_flags::perl_code_syntax_in_classes);
            }
            else {
                perl_syntax = get_modifiers()..has(expression_flags::perl_code_syntax);
            }
        }
        cur := pos + 1;
        if perl_syntax {
            while cur < regex..size() next (cur += 1) {
                n: = regex[cur];

                if space_class<char>::includes(n) {
                    continue;
                }
                else if !in_class && '#' == n {
                    cur = regex..find('\n', cur);
                    if std::string::npos == cur {
                        // No new line, comment runs until the end of the pattern
                        cur = regex..size();
                    }
                }
                else { // None space none comment char
                    break;
                }
            }
        }

        //  Check for end of file.
        if cur > regex..size() {
            cur = regex..size();
        }
        return cur;
    }

    //  Return true if next token is available.
    private next_impl: (inout this, in_class: bool, no_skip: bool) -> bool =
    {
        pos = get_next_position(in_class, no_skip);
        if pos != regex..size() {
            return true;
        }
        else {
            return false;
        }
    }

    next         : (inout this) = next_impl(false, false);
    next_in_class: (inout this) = next_impl( true, false);
    next_no_skip : (inout this) = next_impl(false,  true);

    next_n: (inout this, n: int) -> bool = {
        r := true;
        cur := 0;
        while r && cur < n next (r = next()) {
            cur += 1;
        }
        return r;
    }

    has_next: (this) -> bool = { return pos < regex..size(); }

    private grab_until_impl: (inout this, in e: std::string, out r: std::string, any: bool) -> bool =
    {
        end:= pos; // NOLINT(clang-analyzer-deadcode.DeadStores)
        if any {
            end = regex..find_first_of(e, pos);
        }
        else {
            end = regex..find(e, pos);
        }

        if end != std::string_view::npos {
            r = regex..substr(pos, end - pos);
            pos = end;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_until: (inout this, in e: std::string, out r: std::string)        = grab_until_impl(e, out r, false);
    grab_until: (inout this, in e: char, out r: std::string)               = grab_until_impl(std::string(1, e), out r, false);
    grab_until_one_of: (inout this, in e: std::string, out r: std::string) = grab_until_impl(e, out r, true);

    grab_n: (inout this, in n: int, out r: std::string) -> bool =
    {
        if pos + n as size_t <= regex..size() {
            r = regex..substr(pos, n as size_t);
            pos += (n as size_t) - 1;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_number: (inout this) -> std::string =
    {
        start := pos;
        start_search := pos;
        if regex[start_search] == '-' {
            start_search += 1;
        }
        end := regex..find_first_not_of("1234567890", start_search);

        r : std::string;
        if end != std::string::npos {
            r = regex..substr(start, end - start);
            pos = end - 1;
        }
        else {
            r = regex..substr(start);
            pos = regex..size() - 1;
        }
        return r;
    }

    private peek_impl: (in this, in_class: bool) -> char = {
        next_pos := get_next_position(in_class, false);
        if next_pos < regex..size() {
            return regex[next_pos];
        }
        else {
            return '\0';
        }
    }

    peek         : (in this) = peek_impl(false);
    peek_in_class: (in this) = peek_impl( true);


    //  Parsing functions
    //
    parser_group_modifiers: (inout this, change_str: std::string, inout parser_modifiers: expression_flags) -> bool =
    {
        is_negative := false;
        is_reset    := false;

        apply := :(flag: expression_flags) = {
            if is_negative&$* {
                parser_modifiers&$*..clear(flag);
            }
            else {
                parser_modifiers&$*..set(flag);
            }
        };

        iter := change_str..begin();
        while iter != change_str..end() next (iter++)
        {
            cur := iter*;
            if cur == '^' {
                is_reset = true;
                parser_modifiers = expression_flags::none;
            }
            else if cur == '-' {
                if is_reset { _= error("No negative modifier allowed."); return false; }
                is_negative = true;
            }
            else if cur == 'i' { apply(expression_flags::case_insensitive); }
            else if cur == 'm' { apply(expression_flags::multiple_lines); }
            else if cur == 's' { apply(expression_flags::single_line); }
            else if cur == 'n' { apply(expression_flags::no_group_captures); }
            else if cur == 'x' {
                if (iter + 1) == change_str..end() || (iter + 1)* != 'x' {
                    // x modifier
                    apply(expression_flags::perl_code_syntax);

                    // Just x unsets xx and remove x also removes xx
                    parser_modifiers..clear(expression_flags::perl_code_syntax_in_classes);
                }
                else { // xx modifier
                    // xx also sets or unsets x
                    apply(expression_flags::perl_code_syntax);
                    apply(expression_flags::perl_code_syntax_in_classes);

                    iter++; // Skip the second x
                }
            }
            else {
                _= error("Unknown modifier: (cur)$"); return false;
            }
        }

        return true;
    }

    parse_until: (inout this, term: char) -> bool = {
        cur_token: token_ptr = ();

        while valid() next _ = next()
        {
            if term == current() { break; }

            cur_token = nullptr;

            if !cur_token && valid() { cur_token = alternative_token::parse(this); }
            if !cur_token && valid() { cur_token = any_token::parse(this); }
            if !cur_token && valid() { cur_token = class_token::parse(this); }
            if !cur_token && valid() { cur_token = escape_token_parse(this); }
            if !cur_token && valid() { cur_token = global_group_reset_token_parse(this); }
            if !cur_token && valid() { cur_token = group_ref_token::parse(this); }
            if !cur_token && valid() { cur_token = group_token::parse(this); }
            if !cur_token && valid() { cur_token = hexadecimal_token_parse(this); }
            if !cur_token && valid() { cur_token = line_end_token_parse(this); }
            if !cur_token && valid() { cur_token = line_start_token_parse(this); }
            if !cur_token && valid() { cur_token = named_class_token_parse(this); }
            if !cur_token && valid() { cur_token = octal_token_parse(this); }
            if !cur_token && valid() { cur_token = range_token::parse(this); }
            if !cur_token && valid() { cur_token = special_range_token::parse(this); }
            if !cur_token && valid() { cur_token = start_match_parse(this); }
            if !cur_token && valid() { cur_token = word_boundary_token_parse(this); }

            // Everything else is matched as it is.
            if !cur_token && valid() { cur_token = char_token::parse(this); }

            if cur_token && valid() {
                add_token(cur_token);
            } else {
                return false;
            }
        }

        return true;
    }

    parse: (inout this, modifiers: std::string) -> bool =
    {

        flags : expression_flags = ();
        if !parser_group_modifiers(modifiers, flags) { return false; }
        set_modifiers(flags);

        r := parse_until('\0');
        if r {
            root = cur_group_state..get_as_token();
        }

        return r;
    }

    //  Misc functions

    get_pos:   (this)                             = pos;
    get_range: (this, start: size_t, end: size_t) = std::string(regex..substr(start, end - start + 1));
    valid:     (this) -> bool                     = { return has_next() && !has_error; }

    error: (inout this, err: std::string) -> token_ptr = {
        has_error = true;
        error_out("Error during parsing of regex '(regex)$' at position '(pos)$': (err)$");
        return nullptr;
    }
}


//  Context for one function generation. Generation of functions can be interleaved,
//  therefore we buffer the code for one function here.
//
generation_function_context: @struct<noforward> type = {
    code: std::string = "";
    tabs: std::string = "";

    add_tabs: (inout this, c: int) = {
        i: int = 0;
        while i < c next i += 1 {
            tabs += "  ";
        }
    }

    remove_tabs: (inout this, c: int) = {
        tabs = tabs..substr(0, (c as size_t) * 2);
    }
}


//  Context for generating the state machine.
generation_context: type =
{
    gen_stack: std::vector<generation_function_context> = (1); // Element 0 contains all the code.

    matcher_func: int         = 0;
    reset_func:   int         = 0;
    temp_name:    int         = 0;
    entry_func:   std::string = "";

    //  Generation helpers
    //
    match_parameters: (this) -> std::string = { return "r.pos, ctx"; }

    //  Code generation.

    //  Add code line.
    add: (inout this, s: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$(s)$\n";
    }

    //  Add check for token. The check needs to be a function call that returns a boolean.
    add_check: (inout this, check: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$if !cpp2::regex::(check)$ { r.matched = false; break; }\n";
    }

    //  Add a stateful check. The check needs to return a `match_return`.
    add_statefull: (inout this, next_func: std::string, check: std::string) =
    {
        end_func_statefull(check);

        name := next_func..substr(0, next_func..size() - 2);
        start_func_named(name);
    }

    protected start_func_named: (inout this, name: std::string) =
    {
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct<noforward> type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): <Iter> (this, cur: Iter, forward ctx, other) -> cpp2::regex::match_return<Iter> = {\n";
        cur*.code += "(cur*.tabs)$    r := ctx..pass(cur);\n";
        cur*.code += "(cur*.tabs)$    do {\n";
        cur*..add_tabs(3);
    }

    protected start_func: (inout this) -> std::string =
    {
        name := gen_func_name();
        start_func_named(name);
        return name + "()";
    }

    protected end_func_statefull: (inout this, s: std::string) =
    {
        cur := get_current();
        cur*..remove_tabs(3);
        cur*.code += "\n";
        cur*.code += "(cur*.tabs)$    } while false;\n";
        cur*.code += "(cur*.tabs)$    if r.matched {\n";
        cur*.code += "(cur*.tabs)$      r = (s)$;\n";
        cur*.code += "(cur*.tabs)$    }\n";
        cur*.code += "(cur*.tabs)$    else {\n";
        cur*.code += "(cur*.tabs)$      r.pos = ctx.end;\n";
        cur*.code += "(cur*.tabs)$    }\n";
        cur*.code += "(cur*.tabs)$    _ = ctx;\n";
        cur*.code += "(cur*.tabs)$    return r;\n";
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();
    }

    //  Generate the function for a token.
    generate_func: (inout this, token: token_ptr) -> std::string =
    {
        name := start_func();
        token*..generate_code(this);
        end_func_statefull("other((match_parameters())$)");

        return name;
    }

    //  Generate the reset for a list of group identifiers.
    generate_reset: (inout this, groups: std::set<int>) -> std::string =
    {
        if groups..empty() {
            return "cpp2::regex::no_reset()";
        }

        name := gen_reset_func_name();
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct<noforward> type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): (this, inout ctx) = {\n";
        for groups do (g) {
            cur*.code += "(cur*.tabs)$  ctx..set_group_invalid((g)$);\n";
        }
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();

        return name + "()";
    }

    //  Name generation
    //
    protected gen_func_name: (inout this) -> std::string = {
        cur_id : = matcher_func;
        matcher_func += 1;
        return "func_(cur_id)$";
    }

    next_func_name: (inout this) -> std::string = {
        return gen_func_name() + "()";
    }

    protected gen_reset_func_name: (inout this) -> std::string = {
        cur_id : = reset_func;
        reset_func += 1;
        return "reset_(cur_id)$";
    }

    gen_temp: (inout this) -> std::string = {
        cur_id := temp_name;
        temp_name += 1;
        return "tmp_(cur_id)$";
    }

    //  Context management
    //
    new_context: (inout this) -> *generation_function_context = {
        gen_stack..push_back(generation_function_context());
        cur := get_current();
        cur*.tabs = "    ";

        return cur;
    }

    finish_context: (inout this) = {
        cur := get_current();
        base := get_base();
        base*.code += cur*.code;

        gen_stack..pop_back();
    }

    //  Misc functions
    //
    private get_current: (inout this) -> *generation_function_context = {
        return gen_stack..back()&;
    }

    private get_base: (inout this) -> *generation_function_context = {
        return gen_stack[0]&;
    }

    get_entry_func: (this) -> std::string = {
        return entry_func;
    }

    create_named_group_lookup: (this, named_groups: std::map<std::string, int>) -> std::string =
    {
        res: std::string = "get_named_group_index: (name) -> int = {\n";

        //  Generate if selection.
        sep: std::string = "";
        for named_groups do (cur) {
            res += "(sep)$if name == \"(cur.first)$\" { return (cur.second)$; }";
            sep = "else ";
        }

        //  Generate else branch or return if list is empty.
        if named_groups..empty() {
            res += "  _ = name;\n";
            res += "  return -1;\n";
        }
        else {
            res += "  else { return -1; }\n";
        }
        res += "}\n";
        return res;
    }


    //  Run the generation for the token.
    run: (inout this, token: token_ptr) -> std::string = {
        entry_func = generate_func(token);

        return get_base()*.code;
    }
}

//  Regex syntax: |  Example: ab|ba
//
//  Non greedy implementation. First alternative that matches is chosen.
//
alternative_token: @polymorphic_base type =
{
    this: regex_token_empty = ("");  // No code gen here. alternative_token_gen is created in the parse_context

    operator=:(out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx..current() != '|' { return nullptr; }

        if !ctx..has_token() { return ctx..error("Alternative with no content."); }
        ctx..next_alternative();
        return shared.new<alternative_token>();
    }
}

alternative_token_gen: @polymorphic_base type =
{
    this: regex_token;

    alternatives: token_vec;

    operator=: (out this, a: token_vec) = {
        regex_token = gen_string(a);
        alternatives = a;
    }

    generate_code: (override this, inout ctx: generation_context) =
    {
        functions: std::string = "";

        for alternatives do (cur) {
            groups: std::set<int> = ();
            cur*..add_groups(groups);

            functions += ", " + ctx..generate_func(cur);
            functions += ", " + ctx..generate_reset(groups);
        }

        next_name := ctx..next_func_name();

        ctx..add_statefull(next_name, "cpp2::regex::alternative_token_matcher<char>::match((ctx..match_parameters())$, other, (next_name)$ (functions)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) =
    {
        for alternatives do (cur) {
            cur*..add_groups(groups);
        }
    }

    gen_string: (a: token_vec) -> std::string =
    {
        r: std::string = "";
        sep: std::string = "";

        for a do (cur) {
            r += sep + cur*..to_string();
            sep = "|";
        }

        return r;
    }

    reverse: (override this) -> token_ptr = {
        s : int = cpp2::unchecked_narrow<int>(alternatives..size());

        reverse_vec: token_vec = ();
        reverse_vec..resize(s);

        i: int = 0;
        while i < s next (i += 1) {
            reverse_vec[i] = alternatives[i]*.reverse(); // We only reverse the alternatives, not the order in which they are checked.
        }
        return shared.new<alternative_token_gen>(reverse_vec);
    }
}


//  Regex syntax: .
//
any_token: @polymorphic_base type =
{
    this: regex_token_check = (".");

    operator=:(out this, single_line: bool) = {
        regex_token_check = (".", "any_token_matcher<char, (single_line)$>");
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        if '.' != ctx..current() { return nullptr;}

        return shared.new<any_token>(ctx..get_modifiers()..has(expression_flags::single_line));
    }
}

//  Regex syntax: (?><matcher>)  Example: a(?>bc|c)c
//
atomic_group_token: @polymorphic_base type =
{
    this                 : regex_token = ("");

    public  inner_token : token_ptr   = nullptr;

    operator=: (out this) = {}

    reverse: (override this) -> token_ptr = {
        r := shared.new<atomic_group_token>();
        r*.inner_token = inner_token*.reverse();

        return r;
    }

    generate_code: (override this, inout ctx: generation_context) =
    {
        inner_name := ctx..generate_func(inner_token);

        next_name := ctx..next_func_name();
        ctx..add_statefull(next_name, "cpp2::regex::atomic_group_matcher<char>((ctx..match_parameters())$, (inner_name)$, other, (next_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner_token*..add_groups(groups);
    }
}

//  Regex syntax: a
//
char_token: @polymorphic_base type =
{
    this: regex_token;

    token      : std::string;
    ignore_case: bool;

    operator=: (out this, t: char, ignore_case_: bool) = {
        regex_token = (std::string(1, t));
        token = t;
        ignore_case = ignore_case_;
    }

    operator=: (out this, t: std::string, ignore_case_: bool) = {
        regex_token = (t);
        token = t;
        ignore_case = ignore_case_;
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        return shared.new<char_token>(ctx..current(), ctx..get_modifiers()..has(expression_flags::case_insensitive));
    }

    generate_code: (override this, inout ctx: generation_context) =
    {
        if ignore_case {
            upper: std::string = token;
            lower: std::string = token;

            (copy i: size_t = 0) while i < token..size() next i += 1 {
                lower[i] = string_util::safe_tolower(token[i]);
                upper[i] = string_util::safe_toupper(token[i]);
            }

            if upper != lower {
                gen_case_insensitive(lower, upper, ctx);
            }
            else {
                gen_case_sensitive(ctx);
            }
        }
        else {
            gen_case_sensitive(ctx);
        }
    }

    gen_case_insensitive: (this, lower: std::string, upper: std::string, inout ctx: generation_context) =
    {
        name: std::string = "str_(ctx..gen_temp())$";
        lower_name: std::string = "lower_(name)$";
        upper_name: std::string = "upper_(name)$";
        size := token..size();
        ctx..add("(lower_name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(lower))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("(upper_name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(upper))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("if std::distance(r.pos, ctx.end) < (size)$ {");
        ctx..add("    r.matched = false;");
        ctx..add("    break;");
        ctx..add("}");
        ctx..add("");
        ctx..add("(copy i : int = 0) while i < (size)$ next (i += 1) {");
        ctx..add("    if !((lower_name)$[i] == r.pos[i] || (upper_name)$[i] == r.pos[i]) { r.matched = false; }");
        ctx..add("}");
        ctx..add("");
        ctx..add("if r.matched { r.pos += (size)$; }");
        ctx..add("else { break; }");
    }

    gen_case_sensitive: (this, inout ctx: generation_context) =
    {
        name: std::string = "str_(ctx..gen_temp())$";
        size := token..size();
        ctx..add("(name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(token))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("if std::distance(r.pos, ctx.end) < (size)$ {");
        ctx..add("    r.matched = false;");
        ctx..add("    break;");
        ctx..add("}");
        ctx..add("");
        ctx..add("(copy i : int = 0) while i < (size)$ next (i += 1) {");
        ctx..add("    if (name)$[i] != r.pos[i] { r.matched = false; }");
        ctx..add("}");
        ctx..add("");
        ctx..add("if r.matched { r.pos += (size)$; }");
        ctx..add("else { break; }");
    }

    add_escapes: (this, copy str: std::string) -> std::string =
    {
        str = string_util::replace_all(str, "\\", "\\\\");
        str = string_util::replace_all(str, "\a", "\\a");
        str = string_util::replace_all(str, "\f", "\\f");
        str = string_util::replace_all(str, "\x1b", "\" \"\\x1b\" \""); // Generate a separated string. This prevents
                                                                        // situations like `\x1bblub` from generating
                                                                        // wrong hex characters.
        str = string_util::replace_all(str, "\n", "\\n");
        str = string_util::replace_all(str, "\r", "\\r");
        str = string_util::replace_all(str, "\t", "\\t");

        return str;
    }

    reverse: (override this) -> token_ptr = {
        reverse_str: std::string = token;
        std::reverse(reverse_str..begin(), reverse_str..end());
        return shared.new<char_token>(reverse_str, ignore_case);
    }

    append: (inout this, that) = {
        this.token += that.token;
        this.string_rep += that.string_rep;
    }
}


//  Regex syntax: [<character classes>]  Example: [abcx-y[:digits:]]
//
class_token: @polymorphic_base type =
{
    this            : regex_token = ();

    negate          : bool;
    case_insensitive: bool;
    class_str       : std::string;

    operator=: (out this, negate_: bool, case_insensitive_: bool, class_str_: std::string, str: std::string) =
    {
        regex_token = str;
        negate = negate_;
        case_insensitive = case_insensitive_;
        class_str = class_str_;
    }

    //  TODO: Rework class generation: Generate check functions for classes.
    parse: (inout ctx: parse_context) -> token_ptr =
    {
        if ctx..current() != '[' { return nullptr; }

        start_pos := ctx..get_pos();

        supported_classes: std::vector<std::string> = ("alnum", "alpha", "ascii", "blank", "cntrl", "digits", "graph",
                                                       "lower", "print", "punct", "space", "upper", "word", "xdigit");

        classes: std::vector<std::string> = ();

        //  First step: parse until the end bracket and push single chars, ranges or groups on the class stack.
        is_negate := false;
        first     := true;
        range     := false;
        while ctx..next_in_class() && (ctx..current() != ']' || first)
        {
            if ctx..current() == '^'
            {
                is_negate = true;
                continue; // Skip rest of the loop. Also the first update.
            }

            if ctx..current() == '[' && ctx..peek_in_class() == ':'
            {
                //  We have a character class.
                _ = ctx..next_n(2);  // Skip [:

                name: std::string = "";
                if !ctx..grab_until(":]", out name) { return ctx..error("Could not find end of character class."); }
                if supported_classes..end() == std::find(supported_classes..begin(), supported_classes..end(), name) {
                    return ctx..error("Unsupported character class. Supported ones are: (string_util::join(supported_classes))$");
                }

                classes..push_back("[:(name)$:]");

                _ = ctx..next(); // Skip ':' pointing to the ending ']'.
            }
            else if ctx..current() == '\\'
            {
                if ctx..next_no_skip()  && (ctx..current() != ']')
                {
                    if  ' ' == ctx..current()
                        && ctx..get_modifiers()..has(expression_flags::perl_code_syntax)
                        && ctx..get_modifiers()..has(expression_flags::perl_code_syntax_in_classes)
                    {
                        classes..push_back(std::string(1, ctx..current()));
                    }
                    else {
                        name := "";
                        if      'd' == ctx..current() { name = "short_digits"; }
                        else if 'D' == ctx..current() { name = "short_not_digits"; }
                        else if 'h' == ctx..current() { name = "short_hor_space"; }
                        else if 'H' == ctx..current() { name = "short_not_hor_space"; }
                        else if 's' == ctx..current() { name = "short_space"; }
                        else if 'S' == ctx..current() { name = "short_not_space"; }
                        else if 'v' == ctx..current() { name = "short_ver_space"; }
                        else if 'V' == ctx..current() { name = "short_not_ver_space"; }
                        else if 'w' == ctx..current() { name = "short_word"; }
                        else if 'W' == ctx..current() { name = "short_not_word"; }
                        else {
                            return ctx..error("Unknown group escape.");
                        }
                        classes..push_back("[:(name)$:]");
                    }
                } else {
                    return ctx..error("Escape without a following character.");
                }
            }
            else if ctx..current() == '-'
            {
                if first { // Literal if first entry.
                    classes..push_back("(ctx..current())$");
                } else {
                    range = true;
                }
            }
            else
            {
                if range { // Modify last element to be a range.
                    classes..back() += "-(ctx..current())$";
                    range = false;
                }
                else {
                    classes..push_back("(ctx..current())$");
                }
            }

            first = false;
        }

        if ctx..current() != ']' {
            return ctx..error("Error end of character class definition before terminating ']'.");
        }
        end_pos := ctx..get_pos();

        if range { // If '-' is last entry treat it as a literal char.
            classes..push_back("-");
        }

        // Second step: Wrap the item on the class stack with corresponding class implementation.
        for classes do (inout cur)
        {
            if cur..starts_with("[:") {
                name := cur..substr(2, cur..size() - 4);
                cur = create_matcher("(name)$_class", "");
            }
            else if 1 != cur..size() {
                cur = create_matcher("range_class_entry", "'(cur[0])$', '(cur[2])$'");
            }
            else {
                cur = create_matcher("single_class_entry", "'(cur)$'");
            }
        }

        inner      := string_util::join(classes);
        string_rep := ctx..get_range(start_pos, end_pos);
        return shared.new<class_token>(
            is_negate,
            ctx..get_modifiers()..has(expression_flags::case_insensitive),
            inner,
            string_rep
            );
    }

    reverse: (override this) -> token_ptr = {
        return shared.new<class_token>(
            negate,
            case_insensitive,
            class_str,
            to_string()
            );
    }

    generate_code: (override this, inout ctx: generation_context) =
    {
        ctx..add_check("class_token_matcher<char, (negate)$, (case_insensitive)$, (class_str)$>::match((ctx..match_parameters())$)");
    }

    private create_matcher: (name: std::string, template_arguments: std::string) -> std::string =
    {
        sep := ", ";
        if template_arguments..empty() { sep = ""; }

        return "::cpp2::regex::(name)$<char(sep)$(template_arguments)$>";
    }
}


//  Regex syntax: \a or \n or \[
//
escape_token_parse: (inout ctx: parse_context) -> token_ptr =
{
    if ctx..current() != '\\' { return nullptr; }


    if std::string::npos == std::string("afenrt^.[]()*{}?+|\\")..find(ctx..peek()) {
        return nullptr;
    }

    _ = ctx..next(); // Skip escape

    if std::string::npos != std::string("afenrt\\")..find(ctx..current())
    {
        // Escape of string special char
        t : char = '\0';
        if      'a' == ctx..current() { t = '\a'; }
        else if 'f' == ctx..current() { t = '\f'; }
        else if 'e' == ctx..current() { t = '\x1b'; }
        else if 'n' == ctx..current() { t = '\n'; }
        else if 'r' == ctx..current() { t = '\r'; }
        else if 't' == ctx..current() { t = '\t'; }
        else if '\\' == ctx..current() { t = '\\'; }
        else { return ctx..error("Internal: missing switch case for special escape."); }

        r: = shared.new<char_token>(t, false);
        r*..set_string("\\(ctx..current())$");
        return r;
    }
    else
    {
        // Escape of regex special char
        r := shared.new<char_token>(ctx..current(), false);
        r*..set_string("\\(ctx..current())$");
        return r;
    }

}


//  Regex syntax: \K Example: ab\Kcd
//
global_group_reset_token_parse: (inout ctx: parse_context) -> token_ptr =
{
    if !(ctx..current() == '\\' && ctx..peek() == 'K') { return nullptr; }

    _ = ctx..next(); // Skip escape.
    return shared.new<regex_token_code>("\\K", "ctx..set_group_start(0, r.pos);");
}


//  Regex syntax: \<number>  Example: \1
//                \g{name_or_number}
//                \k{name_or_number}
//                \k<name_or_number>
//                \k'name_or_number'
//
group_ref_token: @polymorphic_base type =
{
    this            : regex_token = ();

    id              : int;
    case_insensitive: bool;
    reverse_eval    : bool;

    operator=:(out this, id_: int, case_insensitive_: bool, reverse_: bool, str: std::string) =
    {
        regex_token      = str;
        id               = id_;
        case_insensitive = case_insensitive_;
        reverse_eval     = reverse_;
    }

    parse: (inout ctx: parse_context) -> token_ptr =
    {
        if ctx..current() != '\\' { return nullptr; }

        str : std::string = "\\";
        group : std::string = "";

        if '0' <= ctx..peek() <= '9'
        {
            _ = ctx..next(); // Skip escape
            group = ctx..grab_number();

            if group..size() >= 3 as size_t
            {
                // Octal syntax (\000) not a group ref matcher.
                number := 0;
                if !string_util::string_to_int(group, number, 8) { return ctx..error("Could not convert octal to int."); }

                number_as_char : char = unchecked_narrow<char>(number);

                token := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
                token*..set_string("\\(string_util::int_to_string<8>(number_as_char as int))$");

                return token;
            }

            str += group;
            // Regular group ref
        }
        else if 'g' == ctx..peek()
        {
            _ = ctx..next(); // Skip escape
            if !ctx..next() { return ctx..error("Group escape without a following char."); } // Skip g

            str += "g";

            if ctx..current() == '{' {
                str += "{";
                if !(ctx..next() && ctx..grab_until('}', out group)) { return ctx..error("No ending bracket."); }

                str += group + "}";
            }
            else {
                group = ctx..grab_number();
                str += group;
            }
        }
        else if 'k' == ctx..peek()
        {
            _ = ctx..next(); // Skip escape
            if !ctx..next() { return ctx..error("Group escape without a following char."); } // Skip k

            str += "k";

            term_char := '\0';
            if ctx..current() == '{' { term_char = '}'; }
            else if ctx..current() == '<' { term_char = '>'; }
            else if ctx..current() == '\'' { term_char = '\''; }
            else {
                return ctx..error("Group escape has wrong operator.");
            }

            str += ctx..current();

            if !(ctx..next() && ctx..grab_until(term_char, out group)) { return ctx..error("No ending bracket."); }

            str += group + term_char;
        }
        else
        {
            // No group ref matcher
            return nullptr;
        }

        // Parse the group
        group = string_util::trim_copy(group);
        group_id : int = 0;
        if string_util::string_to_int(group, group_id)
        {
            if group_id < 0 {
                group_id = ctx..get_cur_group() + group_id;

                if group_id < 1 { // Negative and zero are no valid groups.
                    return ctx..error("Relative group reference does not reference a valid group. (Would be (group_id)$.)");
                }
            }

            if group_id >= ctx..get_cur_group() {
                return ctx..error("Group reference is used before the group is declared.");
            }
        }
        else
        {
            // Named group
            group_id = ctx..get_named_group(group);
            if -1 == group_id { return ctx..error("Group names does not exist. (Name is: (group)$)");}
        }

        return shared.new<group_ref_token>(group_id, ctx..get_modifiers()..has(expression_flags::case_insensitive), false, str);
    }

    reverse: (override this) -> token_ptr = {
        return shared.new<group_ref_token>(id, case_insensitive, !reverse_eval, to_string());
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add_check("group_ref_token_matcher<char, (id)$, (case_insensitive)$, (reverse_eval)$>((ctx..match_parameters())$)");
    }
}


//  Regex syntax: (<tokens>)      Example: (abc)
//                (?<modifiers)            (?i)
//                (?<modifiers>:<tokens>)  (?i:abc)
//                (?<<name>>:<tokens>)     (?<start>:abc)
//                (?#<comment>)            (#Step 1 finished)
//                (?|<tokens>)             (?|(abc)|(cde))
//                (?=<tokens>)             (?=abc)
//                (?!<tokens>)             (?!abc)
//                (*<name>:<tokens)        (*pla:abc)
//
group_token: @polymorphic_base type =
{
    this: regex_token = ();

    number:       int       = -1;
    reverse_eval: bool      = false;
    inner:        token_ptr = nullptr;

    parse_lookahead_lookbehind: (inout ctx: parse_context, syntax: std::string, lookahead: bool, positive: bool) -> token_ptr =
    {
        _ = ctx..next(); // Skip last token defining the syntax

        r := shared.new<lookahead_lookbehind_token>(lookahead, positive);

        old_state := ctx..start_group();
        if !ctx..parse_until(')') { return ctx..error("Group without a closing bracket."); }
        r*.inner = ctx..end_group(old_state);
        r*..set_string("((syntax)$(r*.inner*..to_string())$)");

        if !lookahead {
            r*.inner = r*.inner*..reverse();
        }

        return r;
    }

    parse_atomic_pattern: (inout ctx: parse_context, syntax: std::string) -> token_ptr =
    {
        _ = ctx..next(); // Skip last token defining the syntax

        r := shared.new<atomic_group_token>();

        old_state := ctx..start_group();
        if !ctx..parse_until(')') { return ctx..error("Group without a closing bracket."); }
        r*.inner_token = ctx..end_group(old_state);
        r*..set_string("((syntax)$(r*.inner_token*..to_string())$)");

        return r;
    }

    parse: (inout ctx: parse_context) -> token_ptr =
    {
        if ctx..current() != '(' { return nullptr; }

        has_id              :=  !ctx..get_modifiers()..has(expression_flags::no_group_captures);
        has_pattern         := true;
        group_name          : std::string = "";
        group_name_brackets := true;
        modifiers           : std::string = "";
        modifiers_change_to : =  ctx..get_modifiers();

        //  Skip the '('
        if !ctx..next() { return ctx..error("Group without closing bracket."); }

        if ctx..current() == '?'
        {
            //  Special group
            if !ctx..next_no_skip() { return ctx..error("Missing character after group opening.");  }

            if  ctx.current() == '<' && (ctx.peek() == '=' || ctx.peek() == '!')
            {
                // Lookbehind
                _ = ctx.next(); // Skip the '<'

                return parse_lookahead_lookbehind(ctx, "?<(ctx..current())$", false, ctx..current() == '=');
            }
            else if ctx..current() == '<' || ctx..current() == '\''
            {
                //  Named group
                end_char := ctx..current();
                if end_char == '<' {
                    end_char = '>';
                } else {
                    group_name_brackets = false;
                }
                has_id = true; // Force id for named groups.
                if !ctx..next() /* skip '<' */ { return ctx..error("Missing ending bracket for named group.");  }
                if !ctx..grab_until(end_char, out group_name) { return ctx..error("Missing ending bracket for named group.");  }
                if !ctx..next() { return ctx..error("Group without closing bracket."); }
            }
            else if ctx..current() == '#'
            {
                //  Comment
                comment_str : std::string = "";
                _ = ctx..next(); // Skip #
                if !ctx..grab_until(")", out comment_str) { return ctx..error("Group without closing bracket."); }
                //  Do not add comment. Has problems with ranges.

                //  Pop token and add a list. This fixes comments between a token and a range
                if ctx..has_token() {
                    list : token_vec = ();
                    list..push_back(ctx..pop_token());
                    list..push_back(shared.new<regex_token_empty>("(?#(comment_str)$)"));

                    return shared.new<regex_token_list>(list);
                }
                else {
                    return shared.new<regex_token_empty>("(?#(comment_str)$)");
                }
            }
            else if ctx..current() == '|'
            {
                //  Branch reset group

                if !ctx..next() /* skip '|' */ { return ctx..error("Missing ending bracket for named group.");  }

                old_parser_state := ctx..start_group();
                old_branch_state  := ctx..branch_reset_new_state();
                if !ctx..parse_until(')') { return nullptr; }
                ctx..branch_reset_restore_state(old_branch_state);
                inner_ := ctx..end_group(old_parser_state);

                list: token_vec = (shared.new<regex_token_empty>("(?|"), inner_, shared.new<regex_token_empty>(")"));
                return shared.new<regex_token_list>(list);
            }
            else if ctx..current() == '=' || ctx..current() == '!'
            {
                // Lookahead
                return parse_lookahead_lookbehind(ctx, "?(ctx..current())$", true, ctx..current() == '=');
            }
            else if ctx..current() == '>'
            {
                // Atomic pattern
                return parse_atomic_pattern(ctx, "?(ctx..current())$");
            }
            else
            {
                //  Simple modifier
                has_id = false;
                if !ctx..grab_until_one_of("):", out modifiers) { return ctx..error("Missing ending bracket for group."); }
                if !ctx..parser_group_modifiers(modifiers, modifiers_change_to) {
                     return nullptr;
                }

                if ')' == ctx..current() {
                    has_pattern = false;
                }
                else {
                    if !ctx..next() /* skip ':' */ { return ctx..error("Missing ending bracket for group.");  }
                }
            }
        }
        else if ctx..current() == '*'
        {
            //  Named pattern
            _ = ctx..next(); // Skip *.
            name: std::string = "";
            if !ctx..grab_until(':', out name) { return ctx..error("Missing colon for named pattern.");  }

            if name == "pla" || name == "positive_lookahead" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", true, true);
            }
            else if name == "nla" || name == "negative_lookahead" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", true, false);
            }
            else if name == "plb" || name == "positive_lookbehind" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", false, true);
            }
            else if name == "nlb" || name == "negative_lookbehind" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", false, false);
            }
            else if name == "atomic" {
                return parse_atomic_pattern(ctx, "*(name)$:");
            }
            else {
                return ctx..error("Unknown named group pattern: '(name)$'");
            }
        }

        if has_pattern
        {
            //  Regular group

            r := shared.new<group_token>();
            if has_id {
                r*.number = ctx..next_group();

                if 0 != group_name..size() {
                    ctx..set_named_group(group_name, r*.number);
                }
            }

            old_state := ctx..start_group();
            ctx..set_modifiers(modifiers_change_to);
            if !ctx..parse_until(')') { return nullptr; }
            r*.inner = ctx..end_group(old_state);
            r*..set_string(gen_string(group_name, group_name_brackets, !has_id, modifiers, r*.inner));

            return r;
        }
        else
        {
            //  Only a modifier
            ctx..set_modifiers(modifiers_change_to);

            return shared.new<regex_token_empty>("(?(modifiers)$)");
        }
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<group_token>();
        r*.number = number;
        r*.reverse_eval = !reverse_eval;
        r*.inner = inner*.reverse();
        return r;
    }

    gen_string: (name: std::string, name_brackets: bool, has_modifier: bool, modifiers: std::string, inner_: token_ptr) -> std::string =
    {
        start : std::string = "(";
        if 0 != name..size() {
            if name_brackets {
                start += "?<(name..data())$>";
            }
            else {
                start += "?'(name..data())$'";
            }
        }
        else if has_modifier {
            start += "?" + modifiers + ":";
        }

        return start + inner_*..to_string() + ")";
    }

    generate_code: (override this, inout ctx: generation_context) =
    {
        if -1 != number {
            if reverse_eval {
                ctx..add("ctx..set_group_end((number)$, r.pos);");
            }
            else {
                ctx..add("ctx..set_group_start((number)$, r.pos);");
            }
        }

        inner*..generate_code(ctx);
        if -1 != number {
            if reverse_eval {
                ctx..add("ctx..set_group_start((number)$, r.pos);");
            }
            else {
                ctx..add("ctx..set_group_end((number)$, r.pos);");
            }

            tmp_name := ctx..gen_temp();
            ctx..add("(tmp_name)$_func :=  :() = {");
            ctx..add("  if !r&$*.matched {");
            ctx..add("    ctx&$*..set_group_invalid((number)$);");
            ctx..add("  }");
            ctx..add("};");
            ctx..add("(tmp_name)$ :=  cpp2::regex::make_on_return((tmp_name)$_func);");
            ctx..add("_ = (tmp_name)$;"); // Logic is done in the destructor. Same behavior as for guard objects.
        }
    }

    add_groups: (override this, inout groups: std::set<int>) =
    {
        inner*..add_groups(groups);
        if -1 != number {
            _ = groups..insert(number);
        }
    }
}


//  Regex syntax: \x<number> or \x{<number>}  Example: \x{62}
//
hexadecimal_token_parse: (inout ctx: parse_context) -> token_ptr =
{
    if !(ctx..current() == '\\' && ctx..peek() == 'x') { return nullptr; }

    _ = ctx..next(); // Skip escape.

    if !ctx..next() { return ctx..error("x escape without number.");}

    has_brackets := false;
    number_str: std::string = "";
    if '{' == ctx..current() {
        //  Bracketed
        has_brackets = true;
        _  = ctx..next(); // Skip '{'
        if !ctx..grab_until('}', out number_str) { return ctx..error("No ending bracket for \\x"); }
    }
    else {
        //  Grab two chars
        if !ctx..grab_n(2, out number_str) { return ctx..error("Missing hexadecimal digits after \\x."); }
    }

    number := 0;
    if !string_util::string_to_int(number_str, number, 16) { return ctx..error("Could not convert hexadecimal to int."); }

    // TODO: Change for unicode.
    number_as_char : char = unchecked_narrow<char>(number);

    syntax: std::string = string_util::int_to_string<16>(number_as_char as int);
    if has_brackets {
        syntax = "{(syntax)$}";
    }
    syntax = "\\x(syntax)$";

    r := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
    r*..set_string(syntax);
    return r;
}


//  Regex syntax: $  Example: aa$
//
line_end_token_parse: (inout ctx: parse_context) -> token_ptr =
{
    if ctx..current() == '$' || (ctx..current() == '\\' && ctx..peek() == '$') {
        if (ctx..current() == '\\') { _ = ctx..next(); } // Skip escape
        return shared.new<regex_token_check>("$", "line_end_token_matcher<char, (ctx..get_modifiers()..has(expression_flags::multiple_lines))$, true>");
    }
    else if ctx..current() == '\\' && (ctx..peek() == 'z' || ctx..peek() == 'Z') {
        _ = ctx..next(); // Skip escape

        negate := ctx..current() == 'Z';
        return shared.new<regex_token_check>("\\(ctx..current())$", "line_end_token_matcher<char, false, (negate)$>");
    }
    else {
        return nullptr;
    }
}


//  Regex syntax: ^  Example: ^aa
//
line_start_token_parse: (inout ctx: parse_context) -> token_ptr =
{
    if ctx..current() != '^' && !(ctx..current() == '\\' && ctx..peek() == 'A') { return nullptr; }

    if ctx..current() == '\\' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\A", "line_start_token_matcher<char, false>");
    }
    else {
        return shared.new<regex_token_check>("^", "line_start_token_matcher<char, (ctx..get_modifiers()..has(expression_flags::multiple_lines))$>");
    }
}


//  Regex syntax: (?=) or (?!) or (*pla), etc.  Example: (?=AA)
//
//  Parsed in group_token.
//
lookahead_lookbehind_token: @polymorphic_base type =
{
    this: regex_token = ("");

    protected lookahead: bool;
    protected positive:  bool;
    public    inner   :  token_ptr = nullptr;

    operator=: (out this, lookahead_: bool, positive_: bool) = {
        lookahead = lookahead_;
        positive  = positive_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        inner_name := ctx..generate_func(inner);

        if lookahead {
            ctx..add_check("lookahead_token_matcher<char, (positive)$>((ctx..match_parameters())$, (inner_name)$)");
        }
        else {
            ctx..add_check("lookbehind_token_matcher<char, (positive)$>((ctx..match_parameters())$, (inner_name)$)");
        }
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<lookahead_lookbehind_token>(lookahead, positive);
        r*.inner = inner; // We do not reverse here. Nested lookahead and lookbehind stay as they are.

        return r;
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner*..add_groups(groups);
    }
}


// Named character classes
//
named_class_token_parse: (inout ctx: parse_context) -> token_ptr =
{
    if ctx..current() != '\\' { return nullptr; }

    name := "";
    c_next := ctx..peek();

    if      'd' == c_next { name = "named_class_digits"; }
    else if 'D' == c_next { name = "named_class_not_digits"; }
    else if 'h' == c_next { name = "named_class_hor_space"; }
    else if 'H' == c_next { name = "named_class_not_hor_space"; }
    else if 'N' == c_next { name = "named_class_no_new_line"; }
    else if 's' == c_next { name = "named_class_space"; }
    else if 'S' == c_next { name = "named_class_not_space"; }
    else if 'v' == c_next { name = "named_class_ver_space"; }
    else if 'V' == c_next { name = "named_class_not_ver_space"; }
    else if 'w' == c_next { name = "named_class_word"; }
    else if 'W' == c_next { name = "named_class_not_word"; }
    else                  { return nullptr; }

    _ = ctx..next(); // Skip escape

    return shared.new<regex_token_check>("\\(ctx..current())$", "(name)$<char, (ctx..get_modifiers()..has(expression_flags::case_insensitive))$>::match");
}


//  Regex syntax: \o{<number>}  Example: \o{142}
//
octal_token_parse: (inout ctx: parse_context) -> token_ptr =
{
    if !(ctx..current() == '\\' && ctx..peek() == 'o') { return nullptr; }

    _ = ctx..next(); // Skip escape.

    if !ctx..next()          { return ctx..error("o escape without number.");}
    if ctx..current() != '{' { return ctx..error("Missing opening bracket for \\o."); }

    number_str: std::string = "";
    _  = ctx..next(); // Skip '{'
    if !ctx..grab_until('}', out number_str) { return ctx..error("No ending bracket for \\o"); }

    number := 0;
    if !string_util::string_to_int(number_str, number, 8) { return ctx..error("Could not convert octal to int."); }

    // TODO: Change for unicode.
    number_as_char : char = unchecked_narrow<char>(number);

    syntax: std::string = "\\o{(string_util::int_to_string<8>(number_as_char as int))$}";
    r := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
    r*..set_string(syntax);
    return r;
}


//  Regex syntax: <matcher>{min, max}  Example: a{2,4}
//
range_token: @polymorphic_base type =
{
    this                 : regex_token = ("");

    protected min_count  : int         = -1;
    protected max_count  : int         = -1;
    protected kind       : int         = range_flags::greedy;
    protected inner_token: token_ptr   = nullptr;

    operator=: (out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr =
    {
        r := shared.new<range_token>();
        if ctx..current() == '{'
        {
            if !ctx..has_token() { return ctx..error("'{' without previous element."); }

            inner: std::string = "";
            if !ctx..grab_until('}', out inner) { return ctx..error("Missing closing bracket '}'."); }

            inner = string_util::trim_copy(inner..substr(1)); // Remove '{' and white spaces.
            if inner..empty() { return ctx..error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'"); }

            // Non-greedy or possessive
            r*..parse_modifier(ctx);

            // Get range arguments
            min_count_str: std::string = "-1";
            max_count_str: std::string = "-1";

            sep: size_t = inner..find(',');
            if sep == std::string::npos
            {
                min_count_str = inner;
                max_count_str = inner;
                if !string_util::string_to_int(inner, r*.min_count) { return ctx..error("Could not convert range to number."); }
                r*.max_count = r*.min_count;
            }
            else
            {
                inner_first: std::string = string_util::trim_copy(inner..substr(0, sep));
                inner_last: std::string = string_util::trim_copy(inner..substr(sep + 1));

                if (inner_first..empty() && inner_last..empty()) {
                    return ctx..error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'");
                }

                if !inner_first..empty() {
                    min_count_str = inner_first;
                    if !string_util::string_to_int(inner_first, r*.min_count) { return ctx..error("Could not convert range to number."); }
                }
                if !inner_last..empty() {
                    max_count_str = inner_last;
                    if !string_util::string_to_int(inner_last, r*.max_count) { return ctx..error("Could not convert range to number."); }
                }
            }

            // Check validity of the range.
            if -1 != r*.min_count {
                if !(0 <= r*.min_count) {
                    return ctx..error("Min value in range is negative. Have (r*.min_count)$)");
                }
            }
            if -1 != r*.max_count {
                if !(0 <= r*.max_count) {
                    return ctx..error("Max value in range is negative. Have (r*.max_count)$)");
                }
                if -1 != r*.min_count {
                    if !(r*.min_count <= r*.max_count) {
                        return ctx..error("Min and max values in range are wrong it should hold 0 <= min <= max. Have 0 <= (r*.min_count)$ <= (r*.max_count)$");
                    }
                }
            }

            r*.inner_token = ctx..pop_token();
            r*.string_rep = r*.inner_token*..to_string() + r*..gen_range_string() + r*..gen_mod_string();

            return r;
        }

        return nullptr;
    }

    parse_modifier: (inout this, inout ctx: parse_context) =
    {
        if ctx..peek() == '?' {
            kind = range_flags::not_greedy;
            _ = ctx..next();
        }
        else if ctx..peek() == '+' {
            kind = range_flags::possessive;
            _ = ctx..next();
        }
    }

    gen_mod_string: (this) -> std::string =
    {
        if kind == range_flags::not_greedy {
            return "?";
        }
        else if kind == range_flags::possessive {
            return "+";
        }
        else {
            return "";
        }
    }

    gen_range_string: (this) -> std::string =
    {
        r : std::string = "";
        if min_count == max_count {
            r += "{(min_count)$}";
        }
        else if min_count == -1 {
            r += "{,(max_count)$}";
        }
        else if max_count == -1 {
            r += "{(min_count)$,}";
        }
        else {
            r += "{(min_count)$,(max_count)$}";
        }

        return r;
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<range_token>();
        r*.min_count   = min_count;
        r*.max_count   = max_count;
        r*.kind        = kind;
        r*.inner_token = inner_token*.reverse();

        return r;
    }

    generate_code: (override this, inout ctx: generation_context) =
    {
        inner_name := ctx..generate_func(inner_token);
        groups: std::set<int> = ();
        inner_token*..add_groups(groups);
        reset_name := ctx..generate_reset(groups);

        next_name := ctx..next_func_name();
        ctx..add_statefull(next_name, "cpp2::regex::range_token_matcher<char, (min_count)$, (max_count)$, (kind)$>::match((ctx..match_parameters())$, (inner_name)$, (reset_name)$, other, (next_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner_token*..add_groups(groups);
    }
}


//  Regex syntax: *, +, or ?  Example: aa*
//
special_range_token: @polymorphic_base type =
{
    this : range_token = ();

    parse: (inout ctx: parse_context) -> token_ptr =
    {
        r := shared.new<special_range_token>();
        symbol: char = '\0';
        if ctx..current() == '*' {
            r*.min_count = 0;
            r*.max_count = -1;
            symbol = '*';
        }
        else if ctx..current() == '+' {
            r*.min_count = 1;
            r*.max_count = -1;
            symbol = '+';
        } else if ctx..current() == '?' {
            r*.min_count = 0;
            r*.max_count = 1;
            symbol = '?';
        } else {
            return nullptr;
        }

        if !ctx..has_token() { return ctx..error("'(ctx..current())$' without previous element."); }


        r*..parse_modifier(ctx);

        r*.inner_token = ctx..pop_token();
        r*.string_rep = r*.inner_token*..to_string() + symbol + r*..gen_mod_string();
        return r;
    }
}

//  Regex syntax: \G  Example: \Gaa
//
//  Forces the match and/or consecutive matches to start at the position of the last match.
//
start_match_parse: (inout ctx: parse_context) -> token_ptr =
{
    if ctx..current() != '\\' { return nullptr; }

    if ctx..peek() == 'G' {
        if 0 != ctx..get_pos() { return ctx..error("\\G is only supported at the first position in the regex."); }
        _ = ctx..next();
        ctx.is_start_match = true;
        return shared.new<regex_token_empty>("\\G");
    }
    else {
        return nullptr;
    }
}


//  Regex syntax: \b or \B  Example: \bword\b
//
//  Matches the start end end of word boundaries.
//
word_boundary_token_parse: (inout ctx: parse_context) -> token_ptr =
{
    if ctx..current() != '\\' { return nullptr; }

    if ctx..peek() == 'b' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\b", "word_boundary_token_matcher<char, false>");
    }
    else if ctx..peek() == 'B' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\B", "word_boundary_token_matcher<char, true>");
    }
    else {
        return nullptr;
    }
}


//-----------------------------------------------------------------------
//
//  Parser for regular expression.
//
//-----------------------------------------------------------------------
//

//  Parser and generator for regular expressions.
regex_generator: <Error_out> type =
{
    regex:           std::string_view;
    modifier:        std::string = "";
    modifier_escape: std::string = "";

    error_out:       Error_out;

    source:          std::string = "";

    operator=: (out this, r: std::string_view, e: Error_out) = {
        regex = r;
        error_out = e;
    }

    parse:(inout this) -> std::string =
    {
        // Extract modifiers and adapt regex.
        extract_modifiers();

        parse_ctx: parse_context = (regex, error_out);
        if !parse_ctx..parse(modifier) {
            return "";
        }

        source += "{\n";
        source += "  context: <Iter> type == cpp2::regex::match_context<CharT, Iter, (parse_ctx..get_cur_group())$>;";

        gen_ctx: generation_context = ();
        source += gen_ctx..run(parse_ctx..get_as_token());
        source += "  entry: <Iter> (cur: Iter, inout ctx: context<Iter>) -> cpp2::regex::match_return<Iter> = {\n";
        source += "    ctx..set_group_start(0, cur);\n";
        source += "    r := (gen_ctx..get_entry_func())$(cur, ctx, cpp2::regex::true_end_func());\n";
        source += "    if r.matched { ctx..set_group_end(0, r.pos); }\n";
        source += "    return r;\n";
        source += "  }\n";

        source += gen_ctx..create_named_group_lookup(parse_ctx.named_groups);
        source += "  is_start_match: () -> bool == (parse_ctx.is_start_match)$;";

        string := parse_ctx..get_as_token()*..to_string();
        source += "  to_string: () -> std::string = { return R\"((modifier_escape)$(string)$(modifier_escape)$(modifier)$)\"; }\n";

        source += "}\n";

        _ = parse_ctx;

        return source;
    }

    private extract_modifiers: (inout this) =
    {
        if regex..find_first_of("'/") == 0 {
            mod_token: char = regex[0];

            end_pos := regex..rfind(mod_token);
            if end_pos != 0 {
                // Found valid start end escape
                modifier = regex..substr(end_pos + 1);
                modifier_escape = mod_token;
                regex = regex..substr(1, end_pos - 1);
            }
        }
    }
}

generate_regex: <Err> (regex: std::string_view, err: Err) -> std::string =
{
    parser: regex_generator<Err> = (regex, err);
    r := parser..parse();
    _ = parser;
    return r;
}



regex_gen: (inout t: meta::type_declaration) =
{
    has_default := false;
    exact_name  := "regex";
    prefix      := "regex_";
    expressions : std::map<std::string, std::string> = ();

    for t.get_member_objects() do (inout m)
    {
        name: std::string = m.name();

        if name.starts_with(prefix) || name == exact_name
        {
            if !m.has_initializer() {
                t.error("Regular expression must have an initializer.");
            }
            m.mark_for_removal_from_enclosing_type();

            if name == exact_name {
                if has_default {
                    t.error("Type can only contain one default named regular expression.");
                }
                has_default = true;
            }

            expr: std::string = m.initializer();
            if expr.starts_with("R\"(") && expr.ends_with(")\"") {
                expr = expr.substr(3, expr.size() - 5);
            }
            else if string_util::is_escaped(expr) {
                expr = expr.substr(1, expr.size() - 2);
            }
            else {
                t.error("Unknown string format '(expr)$'");
            }

            expressions[name] = expr;
        }
    }

    t.remove_marked_members();

    for expressions do (expr) {
        regular_expression := generate_regex(expr.second, :(message) = t$.error(message););

        if !regular_expression..empty() {
            t.add_member("public (expr.first)$_matcher: <CharT> type = (regular_expression)$");
            t.add_member("public (expr.first)$: cpp2::regex::regular_expression<char, (expr.first)$_matcher<char>> = ();\n");
        }
    }

    t.add_runtime_support_include( "cpp2regex.h" );
}


//-----------------------------------------------------------------------
//
//  apply_metafunctions
//
apply_metafunctions: (
    inout n     : declaration_node,
    inout rtype : type_declaration,
    error
    )
    -> bool
= {
    assert( n.is_type() );

    //  Check for _names reserved for the metafunction implementation
    if !n.metafunctions.empty()
    {
        for  rtype.get_members()
        do   (m)
        {
            m.require(
                !m.name().starts_with("_") || m.name().ssize() == 1,
                "a type that applies a metafunction cannot have a body that declares "
                "a name that starts with '_' - those names are reserved for the "
                "metafunction implementation"
            );
        }
    }

    //  For each metafunction, apply it
    for n.metafunctions
    do  (meta)
    {
        //  Convert the name and any template arguments to strings
        //  and record that in rtype
        name := meta*.to_string();
        name = name.substr(0, name.find('<'));

        args: std::vector<std::string> = ();
        for meta*.template_arguments()
        do  (arg)
            args.push_back( arg.to_string() );

        rtype.set_metafunction_name( name, args );

        //  Dispatch
        //
        if name == "interface" {
            interface( rtype );
        }
        else if name == "polymorphic_base" {
            polymorphic_base( rtype );
        }
        else if name == "ordered" {
            ordered( rtype );
        }
        else if name == "weakly_ordered" {
            weakly_ordered( rtype );
        }
        else if name == "partially_ordered" {
            partially_ordered( rtype );
        }
        else if name == "copyable" {
            copyable( rtype );
        }
        else if name == "copy_constructible" {
            copy_constructible( rtype );
        }
        else if name == "hashable" {
            hashable( rtype );
        }
        else if name == "basic_value" {
            basic_value( rtype );
        }
        else if name == "value" {
            value( rtype );
        }
        else if name == "weakly_ordered_value" {
            weakly_ordered_value( rtype );
        }
        else if name == "partially_ordered_value" {
            partially_ordered_value( rtype );
        }
        else if name == "cpp1_rule_of_zero" {
            cpp1_rule_of_zero( rtype );
        }
        else if name == "struct" {
            cpp2_struct( rtype );
        }
        else if name == "enum" {
            cpp2_enum( rtype );
        }
        else if name == "flag_enum" {
            flag_enum( rtype );
        }
        else if name == "union" {
            cpp2_union( rtype );
        }
        else if name == "encapsulated" {
            encapsulated( rtype );
        }
        else if name == "noncopyable" {
            noncopyable( rtype );
        }
        else if name == "singleton" {
            singleton( rtype );
        }
        else if name == "print" {
            print( rtype );
        }
        else if name == "noisy" {
            noisy( rtype );
        }
        else if name == "python" {
            python( rtype );
        }
        else if name == "javascript" {
            javascript( rtype );
        }
        else if name == "autodiff" {
            autodiff( rtype );
        }
        else if name == "regex" {
            regex_gen( rtype );
        }
        else if name == "sample_traverser" {
            sample_traverser( rtype );
        }
        else {
            error( "unrecognized metafunction name: " + name );
            error(
                "the current supported names are listed at "
                "https://hsutter.github.io/cppfront/cpp2/metafunctions/#built-in-metafunctions"
            );
            return false;
        }
    }

    return true;
}


}

}
