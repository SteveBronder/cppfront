// Test file for AD IR stages 3, 4, 5 debug output
// This file tests:
// - Subtask 3: ad_rule registry and discovery
// - Subtask 4: Operator token mapping
// - Subtask 5: Base expression builder
#include <iostream>
test_ns: namespace = {

// Test type with reverse-mode autodiff and a custom ad_rule
test_ad_stages: @autodiff<"reverse"> @print type = {
    // Custom ad_rule for log function
    ad_rule_log: type = {
        name: std::string = "log";
        n_args: int = 1;
        is_member: bool = false;

        forward: (x: double) -> double = { return log(x); }
        reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
            x_adj += res_adj / x_val;
        }
    }

    // Simple addition function
    add_xy: (x: double, y: double) -> (r: double) = {
        r = x + y;
    }

    // Multiplication function
    mul_xy: (x: double, y: double) -> (r: double) = {
        r = x * y;
    }

    // Combined operations
    combined: (x: double, y: double) -> (r: double) = {
        z := x * log(y);
        r = z + x;
    }

    // Simple log function (not scaled) to test user rule lookup
    simple_log: (x: double) -> (r: double) = {
        r = log(x);
    }
}

} // namespace test_ns

main: () = {
  x := 3.0;
  y := 4.0;
  x_adj := 0.0;
  y_adj := 0.0;
  res : double = test_ns::test_ad_stages::combined(x, y);
  r_adj := 1.0;  // Seed the output adjoint
  grad_res := test_ns::test_ad_stages::combined_d(x, x_adj, y, y_adj, r_adj);
  // Use r_adj to prevent move semantics
  _ = r_adj;
  std::cout << "x_adj = " << x_adj << ", y_adj = " << y_adj << "\n";
  if (((x_adj - 2.38629) < 1e-4) && ((y_adj - 0.75) < 1e-4)) {
      std::cout << "PASS\n";
  } else {
      std::cout << "FAIL\n";
  }

}
