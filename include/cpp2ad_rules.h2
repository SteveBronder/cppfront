// =============================================================================
// Standard Autodiff Rules for Reverse-Mode Automatic Differentiation
// =============================================================================
//
// Rules live in meta::ad namespace so that @autodiff<"reverse"> discovers them
// via get_tu_declarations() (path 3 in discover_ad_rules).
//
// Each rule uses @register_autodiff which validates name, n_args, forward(),
// and reverse() at metafunction application time.
//
// Parameter naming convention in reverse(): x, y, z, w for 1st-4th args.
// =============================================================================

meta: namespace = {
ad: namespace = {

// =============================================================================
// Basic Arithmetic Operators
// =============================================================================

// Rule for addition: d/dx (x + y) = 1, d/dy (x + y) = 1
ad_rule_add: @register_autodiff type = {
    name: std::string = "+";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = x + y;
    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += res_adj;
        y_adj += res_adj;
    }
}

// Rule for subtraction: d/dx (x - y) = 1, d/dy (x - y) = -1
ad_rule_sub: @register_autodiff type = {
    name: std::string = "-";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = x - y;
    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += res_adj;
        y_adj -= res_adj;
    }
}

// Rule for multiplication: d/dx (x * y) = y, d/dy (x * y) = x
ad_rule_mul: @register_autodiff type = {
    name: std::string = "*";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = x * y;
    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += y_val * res_adj;
        y_adj += x_val * res_adj;
    }
}

// Rule for division: d/dx (x / y) = 1/y, d/dy (x / y) = -x/y^2
ad_rule_div: @register_autodiff type = {
    name: std::string = "/";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = x / y;
    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += res_adj / y_val;
        y_adj -= x_val / (y_val * y_val) * res_adj;
    }
}

// =============================================================================
// Exponential and Logarithmic Functions
// =============================================================================

// Rule for exp(x): d/dx exp(x) = exp(x)
ad_rule_exp: @register_autodiff type = {
    name: std::string = "exp";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = { return std::exp(x); }
    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += res_val * res_adj;
    }
}

// Rule for log(x): d/dx log(x) = 1/x
ad_rule_log: @register_autodiff type = {
    name: std::string = "log";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = { return log(x); }
    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += res_adj / x_val;
    }
}

// Rule for sqrt(x): d/dx sqrt(x) = 1/(2*sqrt(x))
ad_rule_sqrt: @register_autodiff type = {
    name: std::string = "sqrt";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = { return std::sqrt(x); }
    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += 0.5 * res_adj / res_val;
    }
}

// =============================================================================
// Trigonometric Functions
// =============================================================================

// Rule for sin(x): d/dx sin(x) = cos(x)
ad_rule_sin: @register_autodiff type = {
    name: std::string = "sin";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = { return std::sin(x); }
    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += std::cos(x_val) * res_adj;
    }
}

// Rule for cos(x): d/dx cos(x) = -sin(x)
ad_rule_cos: @register_autodiff type = {
    name: std::string = "cos";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = { return std::cos(x); }
    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj -= std::sin(x_val) * res_adj;
    }
}

// Rule for tan(x): d/dx tan(x) = 1 + tan^2(x)
ad_rule_tan: @register_autodiff type = {
    name: std::string = "tan";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = { return std::tan(x); }
    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += (1.0 + res_val * res_val) * res_adj;
    }
}

// =============================================================================
// Hyperbolic Functions
// =============================================================================

// Rule for tanh(x): d/dx tanh(x) = 1 - tanh^2(x)
ad_rule_tanh: @register_autodiff type = {
    name: std::string = "tanh";
    n_args: int = 1;
    is_member: bool = false;

    forward: (x: double) -> double = { return std::tanh(x); }
    reverse: (res_val: double, res_adj: double, x_val: double, inout x_adj: double) = {
        x_adj += (1.0 - res_val * res_val) * res_adj;
    }
}

// Rule for pow(x, y): d/dx = y*x^(y-1), d/dy = x^y * log(x)
ad_rule_pow: @register_autodiff type = {
    name: std::string = "pow";
    n_args: int = 2;
    is_member: bool = false;

    forward: (x: double, y: double) -> double = { return std::pow(x, y); }
    reverse: (res_val: double, res_adj: double,
              x_val: double, inout x_adj: double,
              y_val: double, inout y_adj: double) = {
        x_adj += y_val * res_val / x_val * res_adj;
        y_adj += res_val * std::log(x_val) * res_adj;
    }
}

}
}
